(() => {
  var t = {
      168: (t) => {
        'use strict';
        t.exports = {
          aliceblue: [240, 248, 255],
          antiquewhite: [250, 235, 215],
          aqua: [0, 255, 255],
          aquamarine: [127, 255, 212],
          azure: [240, 255, 255],
          beige: [245, 245, 220],
          bisque: [255, 228, 196],
          black: [0, 0, 0],
          blanchedalmond: [255, 235, 205],
          blue: [0, 0, 255],
          blueviolet: [138, 43, 226],
          brown: [165, 42, 42],
          burlywood: [222, 184, 135],
          cadetblue: [95, 158, 160],
          chartreuse: [127, 255, 0],
          chocolate: [210, 105, 30],
          coral: [255, 127, 80],
          cornflowerblue: [100, 149, 237],
          cornsilk: [255, 248, 220],
          crimson: [220, 20, 60],
          cyan: [0, 255, 255],
          darkblue: [0, 0, 139],
          darkcyan: [0, 139, 139],
          darkgoldenrod: [184, 134, 11],
          darkgray: [169, 169, 169],
          darkgreen: [0, 100, 0],
          darkgrey: [169, 169, 169],
          darkkhaki: [189, 183, 107],
          darkmagenta: [139, 0, 139],
          darkolivegreen: [85, 107, 47],
          darkorange: [255, 140, 0],
          darkorchid: [153, 50, 204],
          darkred: [139, 0, 0],
          darksalmon: [233, 150, 122],
          darkseagreen: [143, 188, 143],
          darkslateblue: [72, 61, 139],
          darkslategray: [47, 79, 79],
          darkslategrey: [47, 79, 79],
          darkturquoise: [0, 206, 209],
          darkviolet: [148, 0, 211],
          deeppink: [255, 20, 147],
          deepskyblue: [0, 191, 255],
          dimgray: [105, 105, 105],
          dimgrey: [105, 105, 105],
          dodgerblue: [30, 144, 255],
          firebrick: [178, 34, 34],
          floralwhite: [255, 250, 240],
          forestgreen: [34, 139, 34],
          fuchsia: [255, 0, 255],
          gainsboro: [220, 220, 220],
          ghostwhite: [248, 248, 255],
          gold: [255, 215, 0],
          goldenrod: [218, 165, 32],
          gray: [128, 128, 128],
          green: [0, 128, 0],
          greenyellow: [173, 255, 47],
          grey: [128, 128, 128],
          honeydew: [240, 255, 240],
          hotpink: [255, 105, 180],
          indianred: [205, 92, 92],
          indigo: [75, 0, 130],
          ivory: [255, 255, 240],
          khaki: [240, 230, 140],
          lavender: [230, 230, 250],
          lavenderblush: [255, 240, 245],
          lawngreen: [124, 252, 0],
          lemonchiffon: [255, 250, 205],
          lightblue: [173, 216, 230],
          lightcoral: [240, 128, 128],
          lightcyan: [224, 255, 255],
          lightgoldenrodyellow: [250, 250, 210],
          lightgray: [211, 211, 211],
          lightgreen: [144, 238, 144],
          lightgrey: [211, 211, 211],
          lightpink: [255, 182, 193],
          lightsalmon: [255, 160, 122],
          lightseagreen: [32, 178, 170],
          lightskyblue: [135, 206, 250],
          lightslategray: [119, 136, 153],
          lightslategrey: [119, 136, 153],
          lightsteelblue: [176, 196, 222],
          lightyellow: [255, 255, 224],
          lime: [0, 255, 0],
          limegreen: [50, 205, 50],
          linen: [250, 240, 230],
          magenta: [255, 0, 255],
          maroon: [128, 0, 0],
          mediumaquamarine: [102, 205, 170],
          mediumblue: [0, 0, 205],
          mediumorchid: [186, 85, 211],
          mediumpurple: [147, 112, 219],
          mediumseagreen: [60, 179, 113],
          mediumslateblue: [123, 104, 238],
          mediumspringgreen: [0, 250, 154],
          mediumturquoise: [72, 209, 204],
          mediumvioletred: [199, 21, 133],
          midnightblue: [25, 25, 112],
          mintcream: [245, 255, 250],
          mistyrose: [255, 228, 225],
          moccasin: [255, 228, 181],
          navajowhite: [255, 222, 173],
          navy: [0, 0, 128],
          oldlace: [253, 245, 230],
          olive: [128, 128, 0],
          olivedrab: [107, 142, 35],
          orange: [255, 165, 0],
          orangered: [255, 69, 0],
          orchid: [218, 112, 214],
          palegoldenrod: [238, 232, 170],
          palegreen: [152, 251, 152],
          paleturquoise: [175, 238, 238],
          palevioletred: [219, 112, 147],
          papayawhip: [255, 239, 213],
          peachpuff: [255, 218, 185],
          peru: [205, 133, 63],
          pink: [255, 192, 203],
          plum: [221, 160, 221],
          powderblue: [176, 224, 230],
          purple: [128, 0, 128],
          rebeccapurple: [102, 51, 153],
          red: [255, 0, 0],
          rosybrown: [188, 143, 143],
          royalblue: [65, 105, 225],
          saddlebrown: [139, 69, 19],
          salmon: [250, 128, 114],
          sandybrown: [244, 164, 96],
          seagreen: [46, 139, 87],
          seashell: [255, 245, 238],
          sienna: [160, 82, 45],
          silver: [192, 192, 192],
          skyblue: [135, 206, 235],
          slateblue: [106, 90, 205],
          slategray: [112, 128, 144],
          slategrey: [112, 128, 144],
          snow: [255, 250, 250],
          springgreen: [0, 255, 127],
          steelblue: [70, 130, 180],
          tan: [210, 180, 140],
          teal: [0, 128, 128],
          thistle: [216, 191, 216],
          tomato: [255, 99, 71],
          turquoise: [64, 224, 208],
          violet: [238, 130, 238],
          wheat: [245, 222, 179],
          white: [255, 255, 255],
          whitesmoke: [245, 245, 245],
          yellow: [255, 255, 0],
          yellowgreen: [154, 205, 50],
        };
      },
      860: function (t) {
        t.exports = (function () {
          'use strict';
          function t(t, n, s, r, o) {
            !(function t(i, n, s, r, o) {
              for (; r > s; ) {
                if (r - s > 600) {
                  var a = r - s + 1,
                    h = n - s + 1,
                    l = Math.log(a),
                    c = 0.5 * Math.exp((2 * l) / 3),
                    u = 0.5 * Math.sqrt((l * c * (a - c)) / a) * (h - a / 2 < 0 ? -1 : 1);
                  t(
                    i,
                    n,
                    Math.max(s, Math.floor(n - (h * c) / a + u)),
                    Math.min(r, Math.floor(n + ((a - h) * c) / a + u)),
                    o,
                  );
                }
                var d = i[n],
                  g = s,
                  f = r;
                for (e(i, s, n), o(i[r], d) > 0 && e(i, s, r); g < f; ) {
                  for (e(i, g, f), g++, f--; o(i[g], d) < 0; ) g++;
                  for (; o(i[f], d) > 0; ) f--;
                }
                0 === o(i[s], d) ? e(i, s, f) : e(i, ++f, r), f <= n && (s = f + 1), n <= f && (r = f - 1);
              }
            })(t, n, s || 0, r || t.length - 1, o || i);
          }
          function e(t, e, i) {
            var n = t[e];
            (t[e] = t[i]), (t[i] = n);
          }
          function i(t, e) {
            return t < e ? -1 : t > e ? 1 : 0;
          }
          var n = function (t) {
            void 0 === t && (t = 9),
              (this._maxEntries = Math.max(4, t)),
              (this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries))),
              this.clear();
          };
          function s(t, e, i) {
            if (!i) return e.indexOf(t);
            for (var n = 0; n < e.length; n++) if (i(t, e[n])) return n;
            return -1;
          }
          function r(t, e) {
            o(t, 0, t.children.length, e, t);
          }
          function o(t, e, i, n, s) {
            s || (s = f(null)), (s.minX = 1 / 0), (s.minY = 1 / 0), (s.maxX = -1 / 0), (s.maxY = -1 / 0);
            for (var r = e; r < i; r++) {
              var o = t.children[r];
              a(s, t.leaf ? n(o) : o);
            }
            return s;
          }
          function a(t, e) {
            return (
              (t.minX = Math.min(t.minX, e.minX)),
              (t.minY = Math.min(t.minY, e.minY)),
              (t.maxX = Math.max(t.maxX, e.maxX)),
              (t.maxY = Math.max(t.maxY, e.maxY)),
              t
            );
          }
          function h(t, e) {
            return t.minX - e.minX;
          }
          function l(t, e) {
            return t.minY - e.minY;
          }
          function c(t) {
            return (t.maxX - t.minX) * (t.maxY - t.minY);
          }
          function u(t) {
            return t.maxX - t.minX + (t.maxY - t.minY);
          }
          function d(t, e) {
            return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY;
          }
          function g(t, e) {
            return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY;
          }
          function f(t) {
            return { children: t, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          }
          function _(e, i, n, s, r) {
            for (var o = [i, n]; o.length; )
              if (!((n = o.pop()) - (i = o.pop()) <= s)) {
                var a = i + Math.ceil((n - i) / s / 2) * s;
                t(e, a, i, n, r), o.push(i, a, a, n);
              }
          }
          return (
            (n.prototype.all = function () {
              return this._all(this.data, []);
            }),
            (n.prototype.search = function (t) {
              var e = this.data,
                i = [];
              if (!g(t, e)) return i;
              for (var n = this.toBBox, s = []; e; ) {
                for (var r = 0; r < e.children.length; r++) {
                  var o = e.children[r],
                    a = e.leaf ? n(o) : o;
                  g(t, a) && (e.leaf ? i.push(o) : d(t, a) ? this._all(o, i) : s.push(o));
                }
                e = s.pop();
              }
              return i;
            }),
            (n.prototype.collides = function (t) {
              var e = this.data;
              if (!g(t, e)) return !1;
              for (var i = []; e; ) {
                for (var n = 0; n < e.children.length; n++) {
                  var s = e.children[n],
                    r = e.leaf ? this.toBBox(s) : s;
                  if (g(t, r)) {
                    if (e.leaf || d(t, r)) return !0;
                    i.push(s);
                  }
                }
                e = i.pop();
              }
              return !1;
            }),
            (n.prototype.load = function (t) {
              if (!t || !t.length) return this;
              if (t.length < this._minEntries) {
                for (var e = 0; e < t.length; e++) this.insert(t[e]);
                return this;
              }
              var i = this._build(t.slice(), 0, t.length - 1, 0);
              if (this.data.children.length)
                if (this.data.height === i.height) this._splitRoot(this.data, i);
                else {
                  if (this.data.height < i.height) {
                    var n = this.data;
                    (this.data = i), (i = n);
                  }
                  this._insert(i, this.data.height - i.height - 1, !0);
                }
              else this.data = i;
              return this;
            }),
            (n.prototype.insert = function (t) {
              return t && this._insert(t, this.data.height - 1), this;
            }),
            (n.prototype.clear = function () {
              return (this.data = f([])), this;
            }),
            (n.prototype.remove = function (t, e) {
              if (!t) return this;
              for (var i, n, r, o = this.data, a = this.toBBox(t), h = [], l = []; o || h.length; ) {
                if ((o || ((o = h.pop()), (n = h[h.length - 1]), (i = l.pop()), (r = !0)), o.leaf)) {
                  var c = s(t, o.children, e);
                  if (-1 !== c) return o.children.splice(c, 1), h.push(o), this._condense(h), this;
                }
                r || o.leaf || !d(o, a)
                  ? n
                    ? (i++, (o = n.children[i]), (r = !1))
                    : (o = null)
                  : (h.push(o), l.push(i), (i = 0), (n = o), (o = o.children[0]));
              }
              return this;
            }),
            (n.prototype.toBBox = function (t) {
              return t;
            }),
            (n.prototype.compareMinX = function (t, e) {
              return t.minX - e.minX;
            }),
            (n.prototype.compareMinY = function (t, e) {
              return t.minY - e.minY;
            }),
            (n.prototype.toJSON = function () {
              return this.data;
            }),
            (n.prototype.fromJSON = function (t) {
              return (this.data = t), this;
            }),
            (n.prototype._all = function (t, e) {
              for (var i = []; t; ) t.leaf ? e.push.apply(e, t.children) : i.push.apply(i, t.children), (t = i.pop());
              return e;
            }),
            (n.prototype._build = function (t, e, i, n) {
              var s,
                o = i - e + 1,
                a = this._maxEntries;
              if (o <= a) return r((s = f(t.slice(e, i + 1))), this.toBBox), s;
              n || ((n = Math.ceil(Math.log(o) / Math.log(a))), (a = Math.ceil(o / Math.pow(a, n - 1)))),
                ((s = f([])).leaf = !1),
                (s.height = n);
              var h = Math.ceil(o / a),
                l = h * Math.ceil(Math.sqrt(a));
              _(t, e, i, l, this.compareMinX);
              for (var c = e; c <= i; c += l) {
                var u = Math.min(c + l - 1, i);
                _(t, c, u, h, this.compareMinY);
                for (var d = c; d <= u; d += h) {
                  var g = Math.min(d + h - 1, u);
                  s.children.push(this._build(t, d, g, n - 1));
                }
              }
              return r(s, this.toBBox), s;
            }),
            (n.prototype._chooseSubtree = function (t, e, i, n) {
              for (; n.push(e), !e.leaf && n.length - 1 !== i; ) {
                for (var s = 1 / 0, r = 1 / 0, o = void 0, a = 0; a < e.children.length; a++) {
                  var h = e.children[a],
                    l = c(h),
                    u =
                      ((d = t),
                      (g = h),
                      (Math.max(g.maxX, d.maxX) - Math.min(g.minX, d.minX)) *
                        (Math.max(g.maxY, d.maxY) - Math.min(g.minY, d.minY)) -
                        l);
                  u < r ? ((r = u), (s = l < s ? l : s), (o = h)) : u === r && l < s && ((s = l), (o = h));
                }
                e = o || e.children[0];
              }
              var d, g;
              return e;
            }),
            (n.prototype._insert = function (t, e, i) {
              var n = i ? t : this.toBBox(t),
                s = [],
                r = this._chooseSubtree(n, this.data, e, s);
              for (r.children.push(t), a(r, n); e >= 0 && s[e].children.length > this._maxEntries; )
                this._split(s, e), e--;
              this._adjustParentBBoxes(n, s, e);
            }),
            (n.prototype._split = function (t, e) {
              var i = t[e],
                n = i.children.length,
                s = this._minEntries;
              this._chooseSplitAxis(i, s, n);
              var o = this._chooseSplitIndex(i, s, n),
                a = f(i.children.splice(o, i.children.length - o));
              (a.height = i.height),
                (a.leaf = i.leaf),
                r(i, this.toBBox),
                r(a, this.toBBox),
                e ? t[e - 1].children.push(a) : this._splitRoot(i, a);
            }),
            (n.prototype._splitRoot = function (t, e) {
              (this.data = f([t, e])),
                (this.data.height = t.height + 1),
                (this.data.leaf = !1),
                r(this.data, this.toBBox);
            }),
            (n.prototype._chooseSplitIndex = function (t, e, i) {
              for (var n, s, r, a, h, l, u, d = 1 / 0, g = 1 / 0, f = e; f <= i - e; f++) {
                var _ = o(t, 0, f, this.toBBox),
                  p = o(t, f, i, this.toBBox),
                  m =
                    ((s = _),
                    (r = p),
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    (a = Math.max(s.minX, r.minX)),
                    (h = Math.max(s.minY, r.minY)),
                    (l = Math.min(s.maxX, r.maxX)),
                    (u = Math.min(s.maxY, r.maxY)),
                    Math.max(0, l - a) * Math.max(0, u - h)),
                  y = c(_) + c(p);
                m < d ? ((d = m), (n = f), (g = y < g ? y : g)) : m === d && y < g && ((g = y), (n = f));
              }
              return n || i - e;
            }),
            (n.prototype._chooseSplitAxis = function (t, e, i) {
              var n = t.leaf ? this.compareMinX : h,
                s = t.leaf ? this.compareMinY : l;
              this._allDistMargin(t, e, i, n) < this._allDistMargin(t, e, i, s) && t.children.sort(n);
            }),
            (n.prototype._allDistMargin = function (t, e, i, n) {
              t.children.sort(n);
              for (
                var s = this.toBBox, r = o(t, 0, e, s), h = o(t, i - e, i, s), l = u(r) + u(h), c = e;
                c < i - e;
                c++
              ) {
                var d = t.children[c];
                a(r, t.leaf ? s(d) : d), (l += u(r));
              }
              for (var g = i - e - 1; g >= e; g--) {
                var f = t.children[g];
                a(h, t.leaf ? s(f) : f), (l += u(h));
              }
              return l;
            }),
            (n.prototype._adjustParentBBoxes = function (t, e, i) {
              for (var n = i; n >= 0; n--) a(e[n], t);
            }),
            (n.prototype._condense = function (t) {
              for (var e = t.length - 1, i = void 0; e >= 0; e--)
                0 === t[e].children.length
                  ? e > 0
                    ? (i = t[e - 1].children).splice(i.indexOf(t[e]), 1)
                    : this.clear()
                  : r(t[e], this.toBBox);
            }),
            n
          );
        })();
      },
    },
    e = {};
  function i(n) {
    var s = e[n];
    if (void 0 !== s) return s.exports;
    var r = (e[n] = { exports: {} });
    return t[n].call(r.exports, r, r.exports, i), r.exports;
  }
  (() => {
    'use strict';
    function t(e) {
      return (
        (t =
          'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t && 'function' == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              }),
        t(e)
      );
    }
    function e() {
      e = function () {
        return n;
      };
      var i,
        n = {},
        s = Object.prototype,
        r = s.hasOwnProperty,
        o =
          Object.defineProperty ||
          function (t, e, i) {
            t[e] = i.value;
          },
        a = 'function' == typeof Symbol ? Symbol : {},
        h = a.iterator || '@@iterator',
        l = a.asyncIterator || '@@asyncIterator',
        c = a.toStringTag || '@@toStringTag';
      function u(t, e, i) {
        return Object.defineProperty(t, e, { value: i, enumerable: !0, configurable: !0, writable: !0 }), t[e];
      }
      try {
        u({}, '');
      } catch (i) {
        u = function (t, e, i) {
          return (t[e] = i);
        };
      }
      function d(t, e, i, n) {
        var s = e && e.prototype instanceof v ? e : v,
          r = Object.create(s.prototype),
          a = new F(n || []);
        return o(r, '_invoke', { value: R(t, i, a) }), r;
      }
      function g(t, e, i) {
        try {
          return { type: 'normal', arg: t.call(e, i) };
        } catch (t) {
          return { type: 'throw', arg: t };
        }
      }
      n.wrap = d;
      var f = 'suspendedStart',
        _ = 'suspendedYield',
        p = 'executing',
        m = 'completed',
        y = {};
      function v() {}
      function x() {}
      function w() {}
      var C = {};
      u(C, h, function () {
        return this;
      });
      var S = Object.getPrototypeOf,
        E = S && S(S(k([])));
      E && E !== s && r.call(E, h) && (C = E);
      var T = (w.prototype = v.prototype = Object.create(C));
      function b(t) {
        ['next', 'throw', 'return'].forEach(function (e) {
          u(t, e, function (t) {
            return this._invoke(e, t);
          });
        });
      }
      function I(e, i) {
        function n(s, o, a, h) {
          var l = g(e[s], e, o);
          if ('throw' !== l.type) {
            var c = l.arg,
              u = c.value;
            return u && 'object' == t(u) && r.call(u, '__await')
              ? i.resolve(u.__await).then(
                  function (t) {
                    n('next', t, a, h);
                  },
                  function (t) {
                    n('throw', t, a, h);
                  },
                )
              : i.resolve(u).then(
                  function (t) {
                    (c.value = t), a(c);
                  },
                  function (t) {
                    return n('throw', t, a, h);
                  },
                );
          }
          h(l.arg);
        }
        var s;
        o(this, '_invoke', {
          value: function (t, e) {
            function r() {
              return new i(function (i, s) {
                n(t, e, i, s);
              });
            }
            return (s = s ? s.then(r, r) : r());
          },
        });
      }
      function R(t, e, n) {
        var s = f;
        return function (r, o) {
          if (s === p) throw new Error('Generator is already running');
          if (s === m) {
            if ('throw' === r) throw o;
            return { value: i, done: !0 };
          }
          for (n.method = r, n.arg = o; ; ) {
            var a = n.delegate;
            if (a) {
              var h = M(a, n);
              if (h) {
                if (h === y) continue;
                return h;
              }
            }
            if ('next' === n.method) n.sent = n._sent = n.arg;
            else if ('throw' === n.method) {
              if (s === f) throw ((s = m), n.arg);
              n.dispatchException(n.arg);
            } else 'return' === n.method && n.abrupt('return', n.arg);
            s = p;
            var l = g(t, e, n);
            if ('normal' === l.type) {
              if (((s = n.done ? m : _), l.arg === y)) continue;
              return { value: l.arg, done: n.done };
            }
            'throw' === l.type && ((s = m), (n.method = 'throw'), (n.arg = l.arg));
          }
        };
      }
      function M(t, e) {
        var n = e.method,
          s = t.iterator[n];
        if (s === i)
          return (
            (e.delegate = null),
            ('throw' === n &&
              t.iterator.return &&
              ((e.method = 'return'), (e.arg = i), M(t, e), 'throw' === e.method)) ||
              ('return' !== n &&
                ((e.method = 'throw'), (e.arg = new TypeError("The iterator does not provide a '" + n + "' method")))),
            y
          );
        var r = g(s, t.iterator, e.arg);
        if ('throw' === r.type) return (e.method = 'throw'), (e.arg = r.arg), (e.delegate = null), y;
        var o = r.arg;
        return o
          ? o.done
            ? ((e[t.resultName] = o.value),
              (e.next = t.nextLoc),
              'return' !== e.method && ((e.method = 'next'), (e.arg = i)),
              (e.delegate = null),
              y)
            : o
          : ((e.method = 'throw'), (e.arg = new TypeError('iterator result is not an object')), (e.delegate = null), y);
      }
      function P(t) {
        var e = { tryLoc: t[0] };
        1 in t && (e.catchLoc = t[1]), 2 in t && ((e.finallyLoc = t[2]), (e.afterLoc = t[3])), this.tryEntries.push(e);
      }
      function L(t) {
        var e = t.completion || {};
        (e.type = 'normal'), delete e.arg, (t.completion = e);
      }
      function F(t) {
        (this.tryEntries = [{ tryLoc: 'root' }]), t.forEach(P, this), this.reset(!0);
      }
      function k(e) {
        if (e || '' === e) {
          var n = e[h];
          if (n) return n.call(e);
          if ('function' == typeof e.next) return e;
          if (!isNaN(e.length)) {
            var s = -1,
              o = function t() {
                for (; ++s < e.length; ) if (r.call(e, s)) return (t.value = e[s]), (t.done = !1), t;
                return (t.value = i), (t.done = !0), t;
              };
            return (o.next = o);
          }
        }
        throw new TypeError(t(e) + ' is not iterable');
      }
      return (
        (x.prototype = w),
        o(T, 'constructor', { value: w, configurable: !0 }),
        o(w, 'constructor', { value: x, configurable: !0 }),
        (x.displayName = u(w, c, 'GeneratorFunction')),
        (n.isGeneratorFunction = function (t) {
          var e = 'function' == typeof t && t.constructor;
          return !!e && (e === x || 'GeneratorFunction' === (e.displayName || e.name));
        }),
        (n.mark = function (t) {
          return (
            Object.setPrototypeOf ? Object.setPrototypeOf(t, w) : ((t.__proto__ = w), u(t, c, 'GeneratorFunction')),
            (t.prototype = Object.create(T)),
            t
          );
        }),
        (n.awrap = function (t) {
          return { __await: t };
        }),
        b(I.prototype),
        u(I.prototype, l, function () {
          return this;
        }),
        (n.AsyncIterator = I),
        (n.async = function (t, e, i, s, r) {
          void 0 === r && (r = Promise);
          var o = new I(d(t, e, i, s), r);
          return n.isGeneratorFunction(e)
            ? o
            : o.next().then(function (t) {
                return t.done ? t.value : o.next();
              });
        }),
        b(T),
        u(T, c, 'Generator'),
        u(T, h, function () {
          return this;
        }),
        u(T, 'toString', function () {
          return '[object Generator]';
        }),
        (n.keys = function (t) {
          var e = Object(t),
            i = [];
          for (var n in e) i.push(n);
          return (
            i.reverse(),
            function t() {
              for (; i.length; ) {
                var n = i.pop();
                if (n in e) return (t.value = n), (t.done = !1), t;
              }
              return (t.done = !0), t;
            }
          );
        }),
        (n.values = k),
        (F.prototype = {
          constructor: F,
          reset: function (t) {
            if (
              ((this.prev = 0),
              (this.next = 0),
              (this.sent = this._sent = i),
              (this.done = !1),
              (this.delegate = null),
              (this.method = 'next'),
              (this.arg = i),
              this.tryEntries.forEach(L),
              !t)
            )
              for (var e in this) 't' === e.charAt(0) && r.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = i);
          },
          stop: function () {
            this.done = !0;
            var t = this.tryEntries[0].completion;
            if ('throw' === t.type) throw t.arg;
            return this.rval;
          },
          dispatchException: function (t) {
            if (this.done) throw t;
            var e = this;
            function n(n, s) {
              return (a.type = 'throw'), (a.arg = t), (e.next = n), s && ((e.method = 'next'), (e.arg = i)), !!s;
            }
            for (var s = this.tryEntries.length - 1; s >= 0; --s) {
              var o = this.tryEntries[s],
                a = o.completion;
              if ('root' === o.tryLoc) return n('end');
              if (o.tryLoc <= this.prev) {
                var h = r.call(o, 'catchLoc'),
                  l = r.call(o, 'finallyLoc');
                if (h && l) {
                  if (this.prev < o.catchLoc) return n(o.catchLoc, !0);
                  if (this.prev < o.finallyLoc) return n(o.finallyLoc);
                } else if (h) {
                  if (this.prev < o.catchLoc) return n(o.catchLoc, !0);
                } else {
                  if (!l) throw new Error('try statement without catch or finally');
                  if (this.prev < o.finallyLoc) return n(o.finallyLoc);
                }
              }
            }
          },
          abrupt: function (t, e) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var n = this.tryEntries[i];
              if (n.tryLoc <= this.prev && r.call(n, 'finallyLoc') && this.prev < n.finallyLoc) {
                var s = n;
                break;
              }
            }
            s && ('break' === t || 'continue' === t) && s.tryLoc <= e && e <= s.finallyLoc && (s = null);
            var o = s ? s.completion : {};
            return (
              (o.type = t), (o.arg = e), s ? ((this.method = 'next'), (this.next = s.finallyLoc), y) : this.complete(o)
            );
          },
          complete: function (t, e) {
            if ('throw' === t.type) throw t.arg;
            return (
              'break' === t.type || 'continue' === t.type
                ? (this.next = t.arg)
                : 'return' === t.type
                  ? ((this.rval = this.arg = t.arg), (this.method = 'return'), (this.next = 'end'))
                  : 'normal' === t.type && e && (this.next = e),
              y
            );
          },
          finish: function (t) {
            for (var e = this.tryEntries.length - 1; e >= 0; --e) {
              var i = this.tryEntries[e];
              if (i.finallyLoc === t) return this.complete(i.completion, i.afterLoc), L(i), y;
            }
          },
          catch: function (t) {
            for (var e = this.tryEntries.length - 1; e >= 0; --e) {
              var i = this.tryEntries[e];
              if (i.tryLoc === t) {
                var n = i.completion;
                if ('throw' === n.type) {
                  var s = n.arg;
                  L(i);
                }
                return s;
              }
            }
            throw new Error('illegal catch attempt');
          },
          delegateYield: function (t, e, n) {
            return (
              (this.delegate = { iterator: k(t), resultName: e, nextLoc: n }),
              'next' === this.method && (this.arg = i),
              y
            );
          },
        }),
        n
      );
    }
    function n(t, e, i, n, s, r, o) {
      try {
        var a = t[r](o),
          h = a.value;
      } catch (t) {
        return void i(t);
      }
      a.done ? e(h) : Promise.resolve(h).then(n, s);
    }
    var s,
      r,
      o = function (t) {
        var e = t.querySelector('button[data-to-disable]');
        if (e) {
          e.disabled = !0;
          var i = Array.from(t.querySelectorAll('input[type="text"], input[type="number"]')).some(function (t) {
            return '' !== (null == t ? void 0 : t.value.trim());
          });
          e.disabled = !i;
        }
      },
      a =
        ((s = e().mark(function t() {
          var i;
          return e().wrap(function (t) {
            for (;;)
              switch ((t.prev = t.next)) {
                case 0:
                  (i = document.querySelectorAll('[data-toggle-submit-button]')).length > 0 &&
                    i.forEach(function (t) {
                      t instanceof HTMLFormElement &&
                        t.querySelectorAll('input').forEach(function (e) {
                          e.addEventListener('input', function () {
                            o(t);
                          });
                        });
                    });
                case 2:
                case 'end':
                  return t.stop();
              }
          }, t);
        })),
        (r = function () {
          var t = this,
            e = arguments;
          return new Promise(function (i, r) {
            var o = s.apply(t, e);
            function a(t) {
              n(o, i, r, a, h, 'next', t);
            }
            function h(t) {
              n(o, i, r, a, h, 'throw', t);
            }
            a(void 0);
          });
        }),
        function () {
          return r.apply(this, arguments);
        });
    function h(t) {
      return (
        (h =
          'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t && 'function' == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              }),
        h(t)
      );
    }
    function l(t, e) {
      var i = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(t);
        e &&
          (n = n.filter(function (e) {
            return Object.getOwnPropertyDescriptor(t, e).enumerable;
          })),
          i.push.apply(i, n);
      }
      return i;
    }
    function c(t) {
      for (var e = 1; e < arguments.length; e++) {
        var i = null != arguments[e] ? arguments[e] : {};
        e % 2
          ? l(Object(i), !0).forEach(function (e) {
              var n, s, r, o;
              (n = t),
                (s = e),
                (r = i[e]),
                (o = (function (t, e) {
                  if ('object' != h(t) || !t) return t;
                  var i = t[Symbol.toPrimitive];
                  if (void 0 !== i) {
                    var n = i.call(t, 'string');
                    if ('object' != h(n)) return n;
                    throw new TypeError('@@toPrimitive must return a primitive value.');
                  }
                  return String(t);
                })(s)),
                (s = 'symbol' == h(o) ? o : String(o)) in n
                  ? Object.defineProperty(n, s, { value: r, enumerable: !0, configurable: !0, writable: !0 })
                  : (n[s] = r);
            })
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i))
            : l(Object(i)).forEach(function (e) {
                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e));
              });
      }
      return t;
    }
    var u = 'ncea-search-data',
      d = JSON.stringify({ fields: {}, count: {} }),
      g = function () {
        var t = sessionStorage.getItem(u) || d;
        return JSON.parse(t);
      },
      f = function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
          i = g(),
          n = i.fields;
        if (e) n.hasOwnProperty(t.id) && delete n[t.id], sessionStorage.setItem(u, JSON.stringify(i));
        else {
          var s = n[t.id] || {};
          t.querySelectorAll('input').forEach(function (e) {
            e.addEventListener('change', function (r) {
              var o = r.target,
                a = o.name,
                h = o.value,
                l = o.checked;
              (s[a] = 'checkbox' === e.type ? l : h),
                (n[t.id] = c(c({}, n[t.id]), s)),
                sessionStorage.setItem(u, JSON.stringify(i));
            });
          });
        }
      },
      _ = function (t) {
        var e,
          i = null !== (e = g().fields[t.id]) && void 0 !== e ? e : {};
        t.querySelectorAll('input').forEach(function (t) {
          i.hasOwnProperty(t.name) &&
            (['text', 'number'].includes(t.type) && (t.value = i[t.name]),
            'checkbox' === t.type && (t.checked = i[t.name]));
        }),
          clearTimeout(t.detectFieldsStateTimeout),
          (t.detectFieldsStateTimeout = setTimeout(function () {
            o(t);
          }, 500));
      };
    function p(t) {
      return (
        (p =
          'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t && 'function' == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              }),
        p(t)
      );
    }
    function m() {
      m = function () {
        return e;
      };
      var t,
        e = {},
        i = Object.prototype,
        n = i.hasOwnProperty,
        s =
          Object.defineProperty ||
          function (t, e, i) {
            t[e] = i.value;
          },
        r = 'function' == typeof Symbol ? Symbol : {},
        o = r.iterator || '@@iterator',
        a = r.asyncIterator || '@@asyncIterator',
        h = r.toStringTag || '@@toStringTag';
      function l(t, e, i) {
        return Object.defineProperty(t, e, { value: i, enumerable: !0, configurable: !0, writable: !0 }), t[e];
      }
      try {
        l({}, '');
      } catch (t) {
        l = function (t, e, i) {
          return (t[e] = i);
        };
      }
      function c(t, e, i, n) {
        var r = e && e.prototype instanceof v ? e : v,
          o = Object.create(r.prototype),
          a = new F(n || []);
        return s(o, '_invoke', { value: R(t, i, a) }), o;
      }
      function u(t, e, i) {
        try {
          return { type: 'normal', arg: t.call(e, i) };
        } catch (t) {
          return { type: 'throw', arg: t };
        }
      }
      e.wrap = c;
      var d = 'suspendedStart',
        g = 'suspendedYield',
        f = 'executing',
        _ = 'completed',
        y = {};
      function v() {}
      function x() {}
      function w() {}
      var C = {};
      l(C, o, function () {
        return this;
      });
      var S = Object.getPrototypeOf,
        E = S && S(S(k([])));
      E && E !== i && n.call(E, o) && (C = E);
      var T = (w.prototype = v.prototype = Object.create(C));
      function b(t) {
        ['next', 'throw', 'return'].forEach(function (e) {
          l(t, e, function (t) {
            return this._invoke(e, t);
          });
        });
      }
      function I(t, e) {
        function i(s, r, o, a) {
          var h = u(t[s], t, r);
          if ('throw' !== h.type) {
            var l = h.arg,
              c = l.value;
            return c && 'object' == p(c) && n.call(c, '__await')
              ? e.resolve(c.__await).then(
                  function (t) {
                    i('next', t, o, a);
                  },
                  function (t) {
                    i('throw', t, o, a);
                  },
                )
              : e.resolve(c).then(
                  function (t) {
                    (l.value = t), o(l);
                  },
                  function (t) {
                    return i('throw', t, o, a);
                  },
                );
          }
          a(h.arg);
        }
        var r;
        s(this, '_invoke', {
          value: function (t, n) {
            function s() {
              return new e(function (e, s) {
                i(t, n, e, s);
              });
            }
            return (r = r ? r.then(s, s) : s());
          },
        });
      }
      function R(e, i, n) {
        var s = d;
        return function (r, o) {
          if (s === f) throw new Error('Generator is already running');
          if (s === _) {
            if ('throw' === r) throw o;
            return { value: t, done: !0 };
          }
          for (n.method = r, n.arg = o; ; ) {
            var a = n.delegate;
            if (a) {
              var h = M(a, n);
              if (h) {
                if (h === y) continue;
                return h;
              }
            }
            if ('next' === n.method) n.sent = n._sent = n.arg;
            else if ('throw' === n.method) {
              if (s === d) throw ((s = _), n.arg);
              n.dispatchException(n.arg);
            } else 'return' === n.method && n.abrupt('return', n.arg);
            s = f;
            var l = u(e, i, n);
            if ('normal' === l.type) {
              if (((s = n.done ? _ : g), l.arg === y)) continue;
              return { value: l.arg, done: n.done };
            }
            'throw' === l.type && ((s = _), (n.method = 'throw'), (n.arg = l.arg));
          }
        };
      }
      function M(e, i) {
        var n = i.method,
          s = e.iterator[n];
        if (s === t)
          return (
            (i.delegate = null),
            ('throw' === n &&
              e.iterator.return &&
              ((i.method = 'return'), (i.arg = t), M(e, i), 'throw' === i.method)) ||
              ('return' !== n &&
                ((i.method = 'throw'), (i.arg = new TypeError("The iterator does not provide a '" + n + "' method")))),
            y
          );
        var r = u(s, e.iterator, i.arg);
        if ('throw' === r.type) return (i.method = 'throw'), (i.arg = r.arg), (i.delegate = null), y;
        var o = r.arg;
        return o
          ? o.done
            ? ((i[e.resultName] = o.value),
              (i.next = e.nextLoc),
              'return' !== i.method && ((i.method = 'next'), (i.arg = t)),
              (i.delegate = null),
              y)
            : o
          : ((i.method = 'throw'), (i.arg = new TypeError('iterator result is not an object')), (i.delegate = null), y);
      }
      function P(t) {
        var e = { tryLoc: t[0] };
        1 in t && (e.catchLoc = t[1]), 2 in t && ((e.finallyLoc = t[2]), (e.afterLoc = t[3])), this.tryEntries.push(e);
      }
      function L(t) {
        var e = t.completion || {};
        (e.type = 'normal'), delete e.arg, (t.completion = e);
      }
      function F(t) {
        (this.tryEntries = [{ tryLoc: 'root' }]), t.forEach(P, this), this.reset(!0);
      }
      function k(e) {
        if (e || '' === e) {
          var i = e[o];
          if (i) return i.call(e);
          if ('function' == typeof e.next) return e;
          if (!isNaN(e.length)) {
            var s = -1,
              r = function i() {
                for (; ++s < e.length; ) if (n.call(e, s)) return (i.value = e[s]), (i.done = !1), i;
                return (i.value = t), (i.done = !0), i;
              };
            return (r.next = r);
          }
        }
        throw new TypeError(p(e) + ' is not iterable');
      }
      return (
        (x.prototype = w),
        s(T, 'constructor', { value: w, configurable: !0 }),
        s(w, 'constructor', { value: x, configurable: !0 }),
        (x.displayName = l(w, h, 'GeneratorFunction')),
        (e.isGeneratorFunction = function (t) {
          var e = 'function' == typeof t && t.constructor;
          return !!e && (e === x || 'GeneratorFunction' === (e.displayName || e.name));
        }),
        (e.mark = function (t) {
          return (
            Object.setPrototypeOf ? Object.setPrototypeOf(t, w) : ((t.__proto__ = w), l(t, h, 'GeneratorFunction')),
            (t.prototype = Object.create(T)),
            t
          );
        }),
        (e.awrap = function (t) {
          return { __await: t };
        }),
        b(I.prototype),
        l(I.prototype, a, function () {
          return this;
        }),
        (e.AsyncIterator = I),
        (e.async = function (t, i, n, s, r) {
          void 0 === r && (r = Promise);
          var o = new I(c(t, i, n, s), r);
          return e.isGeneratorFunction(i)
            ? o
            : o.next().then(function (t) {
                return t.done ? t.value : o.next();
              });
        }),
        b(T),
        l(T, h, 'Generator'),
        l(T, o, function () {
          return this;
        }),
        l(T, 'toString', function () {
          return '[object Generator]';
        }),
        (e.keys = function (t) {
          var e = Object(t),
            i = [];
          for (var n in e) i.push(n);
          return (
            i.reverse(),
            function t() {
              for (; i.length; ) {
                var n = i.pop();
                if (n in e) return (t.value = n), (t.done = !1), t;
              }
              return (t.done = !0), t;
            }
          );
        }),
        (e.values = k),
        (F.prototype = {
          constructor: F,
          reset: function (e) {
            if (
              ((this.prev = 0),
              (this.next = 0),
              (this.sent = this._sent = t),
              (this.done = !1),
              (this.delegate = null),
              (this.method = 'next'),
              (this.arg = t),
              this.tryEntries.forEach(L),
              !e)
            )
              for (var i in this) 't' === i.charAt(0) && n.call(this, i) && !isNaN(+i.slice(1)) && (this[i] = t);
          },
          stop: function () {
            this.done = !0;
            var t = this.tryEntries[0].completion;
            if ('throw' === t.type) throw t.arg;
            return this.rval;
          },
          dispatchException: function (e) {
            if (this.done) throw e;
            var i = this;
            function s(n, s) {
              return (a.type = 'throw'), (a.arg = e), (i.next = n), s && ((i.method = 'next'), (i.arg = t)), !!s;
            }
            for (var r = this.tryEntries.length - 1; r >= 0; --r) {
              var o = this.tryEntries[r],
                a = o.completion;
              if ('root' === o.tryLoc) return s('end');
              if (o.tryLoc <= this.prev) {
                var h = n.call(o, 'catchLoc'),
                  l = n.call(o, 'finallyLoc');
                if (h && l) {
                  if (this.prev < o.catchLoc) return s(o.catchLoc, !0);
                  if (this.prev < o.finallyLoc) return s(o.finallyLoc);
                } else if (h) {
                  if (this.prev < o.catchLoc) return s(o.catchLoc, !0);
                } else {
                  if (!l) throw new Error('try statement without catch or finally');
                  if (this.prev < o.finallyLoc) return s(o.finallyLoc);
                }
              }
            }
          },
          abrupt: function (t, e) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var s = this.tryEntries[i];
              if (s.tryLoc <= this.prev && n.call(s, 'finallyLoc') && this.prev < s.finallyLoc) {
                var r = s;
                break;
              }
            }
            r && ('break' === t || 'continue' === t) && r.tryLoc <= e && e <= r.finallyLoc && (r = null);
            var o = r ? r.completion : {};
            return (
              (o.type = t), (o.arg = e), r ? ((this.method = 'next'), (this.next = r.finallyLoc), y) : this.complete(o)
            );
          },
          complete: function (t, e) {
            if ('throw' === t.type) throw t.arg;
            return (
              'break' === t.type || 'continue' === t.type
                ? (this.next = t.arg)
                : 'return' === t.type
                  ? ((this.rval = this.arg = t.arg), (this.method = 'return'), (this.next = 'end'))
                  : 'normal' === t.type && e && (this.next = e),
              y
            );
          },
          finish: function (t) {
            for (var e = this.tryEntries.length - 1; e >= 0; --e) {
              var i = this.tryEntries[e];
              if (i.finallyLoc === t) return this.complete(i.completion, i.afterLoc), L(i), y;
            }
          },
          catch: function (t) {
            for (var e = this.tryEntries.length - 1; e >= 0; --e) {
              var i = this.tryEntries[e];
              if (i.tryLoc === t) {
                var n = i.completion;
                if ('throw' === n.type) {
                  var s = n.arg;
                  L(i);
                }
                return s;
              }
            }
            throw new Error('illegal catch attempt');
          },
          delegateYield: function (e, i, n) {
            return (
              (this.delegate = { iterator: k(e), resultName: i, nextLoc: n }),
              'next' === this.method && (this.arg = t),
              y
            );
          },
        }),
        e
      );
    }
    function y(t, e, i, n, s, r, o) {
      try {
        var a = t[r](o),
          h = a.value;
      } catch (t) {
        return void i(t);
      }
      a.done ? e(h) : Promise.resolve(h).then(n, s);
    }
    var v = (function () {
      var t = (function (t) {
        return function () {
          var e = this,
            i = arguments;
          return new Promise(function (n, s) {
            var r = t.apply(e, i);
            function o(t) {
              y(r, n, s, o, a, 'next', t);
            }
            function a(t) {
              y(r, n, s, o, a, 'throw', t);
            }
            o(void 0);
          });
        };
      })(
        m().mark(function t(e) {
          var i, n, s, r;
          return m().wrap(
            function (t) {
              for (;;)
                switch ((t.prev = t.next)) {
                  case 0:
                    return (
                      (t.prev = 0),
                      (i = sessionStorage.getItem(u)),
                      (n = JSON.parse(i)),
                      (t.next = 5),
                      fetch(e, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(n.fields),
                      })
                    );
                  case 5:
                    if (!(s = t.sent).ok) {
                      t.next = 13;
                      break;
                    }
                    return (t.next = 9), s.text();
                  case 9:
                    (r = t.sent), (document.getElementById('results-block').innerHTML = r), (t.next = 14);
                    break;
                  case 13:
                    console.error('Failed to fetch the results view: '.concat(s.status));
                  case 14:
                    t.next = 19;
                    break;
                  case 16:
                    (t.prev = 16),
                      (t.t0 = t.catch(0)),
                      console.error('Error fetching HTML view: '.concat(t.t0.message));
                  case 19:
                  case 'end':
                    return t.stop();
                }
            },
            t,
            null,
            [[0, 16]],
          );
        }),
      );
      return function (e) {
        return t.apply(this, arguments);
      };
    })();
    const x = class {
        constructor(t) {
          this.propagationStopped, this.defaultPrevented, (this.type = t), (this.target = null);
        }
        preventDefault() {
          this.defaultPrevented = !0;
        }
        stopPropagation() {
          this.propagationStopped = !0;
        }
      },
      w = 'propertychange',
      C = class {
        constructor() {
          this.disposed = !1;
        }
        dispose() {
          this.disposed || ((this.disposed = !0), this.disposeInternal());
        }
        disposeInternal() {}
      };
    function S(t, e) {
      return t > e ? 1 : t < e ? -1 : 0;
    }
    function E(t, e, i) {
      if (t[0] <= e) return 0;
      const n = t.length;
      if (e <= t[n - 1]) return n - 1;
      if ('function' == typeof i) {
        for (let s = 1; s < n; ++s) {
          const n = t[s];
          if (n === e) return s;
          if (n < e) return i(e, t[s - 1], n) > 0 ? s - 1 : s;
        }
        return n - 1;
      }
      if (i > 0) {
        for (let i = 1; i < n; ++i) if (t[i] < e) return i - 1;
        return n - 1;
      }
      if (i < 0) {
        for (let i = 1; i < n; ++i) if (t[i] <= e) return i;
        return n - 1;
      }
      for (let i = 1; i < n; ++i) {
        if (t[i] == e) return i;
        if (t[i] < e) return t[i - 1] - e < e - t[i] ? i - 1 : i;
      }
      return n - 1;
    }
    function T(t, e, i) {
      for (; e < i; ) {
        const n = t[e];
        (t[e] = t[i]), (t[i] = n), ++e, --i;
      }
    }
    function b(t, e) {
      const i = Array.isArray(e) ? e : [e],
        n = i.length;
      for (let e = 0; e < n; e++) t[t.length] = i[e];
    }
    function I(t, e) {
      const i = t.length;
      if (i !== e.length) return !1;
      for (let n = 0; n < i; n++) if (t[n] !== e[n]) return !1;
      return !0;
    }
    function R() {
      return !0;
    }
    function M() {
      return !1;
    }
    function P() {}
    function L(t) {
      let e,
        i,
        n,
        s = !1;
      return function () {
        const r = Array.prototype.slice.call(arguments);
        return (s && this === n && I(r, i)) || ((s = !0), (n = this), (i = r), (e = t.apply(this, arguments))), e;
      };
    }
    function F(t) {
      for (const e in t) delete t[e];
    }
    function k(t) {
      let e;
      for (e in t) return !1;
      return !e;
    }
    const A = class extends C {
        constructor(t) {
          super(),
            (this.eventTarget_ = t),
            (this.pendingRemovals_ = null),
            (this.dispatching_ = null),
            (this.listeners_ = null);
        }
        addEventListener(t, e) {
          if (!t || !e) return;
          const i = this.listeners_ || (this.listeners_ = {}),
            n = i[t] || (i[t] = []);
          n.includes(e) || n.push(e);
        }
        dispatchEvent(t) {
          const e = 'string' == typeof t,
            i = e ? t : t.type,
            n = this.listeners_ && this.listeners_[i];
          if (!n) return;
          const s = e ? new x(t) : t;
          s.target || (s.target = this.eventTarget_ || this);
          const r = this.dispatching_ || (this.dispatching_ = {}),
            o = this.pendingRemovals_ || (this.pendingRemovals_ = {});
          let a;
          i in r || ((r[i] = 0), (o[i] = 0)), ++r[i];
          for (let t = 0, e = n.length; t < e; ++t)
            if (
              ((a = 'handleEvent' in n[t] ? n[t].handleEvent(s) : n[t].call(this, s)), !1 === a || s.propagationStopped)
            ) {
              a = !1;
              break;
            }
          if (0 == --r[i]) {
            let t = o[i];
            for (delete o[i]; t--; ) this.removeEventListener(i, P);
            delete r[i];
          }
          return a;
        }
        disposeInternal() {
          this.listeners_ && F(this.listeners_);
        }
        getListeners(t) {
          return (this.listeners_ && this.listeners_[t]) || void 0;
        }
        hasListener(t) {
          return !!this.listeners_ && (t ? t in this.listeners_ : Object.keys(this.listeners_).length > 0);
        }
        removeEventListener(t, e) {
          if (!this.listeners_) return;
          const i = this.listeners_[t];
          if (!i) return;
          const n = i.indexOf(e);
          -1 !== n &&
            (this.pendingRemovals_ && t in this.pendingRemovals_
              ? ((i[n] = P), ++this.pendingRemovals_[t])
              : (i.splice(n, 1), 0 === i.length && delete this.listeners_[t]));
        }
      },
      O = 'change',
      D = 'contextmenu',
      G = 'click',
      N = 'keydown',
      z = 'keypress',
      W = 'touchmove',
      X = 'wheel';
    function j(t, e, i, n, s) {
      if ((n && n !== t && (i = i.bind(n)), s)) {
        const n = i;
        i = function () {
          t.removeEventListener(e, i), n.apply(this, arguments);
        };
      }
      const r = { target: t, type: e, listener: i };
      return t.addEventListener(e, i), r;
    }
    function Y(t, e, i, n) {
      return j(t, e, i, n, !0);
    }
    function B(t) {
      t && t.target && (t.target.removeEventListener(t.type, t.listener), F(t));
    }
    class K extends A {
      constructor() {
        super(),
          (this.on = this.onInternal),
          (this.once = this.onceInternal),
          (this.un = this.unInternal),
          (this.revision_ = 0);
      }
      changed() {
        ++this.revision_, this.dispatchEvent(O);
      }
      getRevision() {
        return this.revision_;
      }
      onInternal(t, e) {
        if (Array.isArray(t)) {
          const i = t.length,
            n = new Array(i);
          for (let s = 0; s < i; ++s) n[s] = j(this, t[s], e);
          return n;
        }
        return j(this, t, e);
      }
      onceInternal(t, e) {
        let i;
        if (Array.isArray(t)) {
          const n = t.length;
          i = new Array(n);
          for (let s = 0; s < n; ++s) i[s] = Y(this, t[s], e);
        } else i = Y(this, t, e);
        return (e.ol_key = i), i;
      }
      unInternal(t, e) {
        const i = e.ol_key;
        if (i)
          !(function (t) {
            if (Array.isArray(t)) for (let e = 0, i = t.length; e < i; ++e) B(t[e]);
            else B(t);
          })(i);
        else if (Array.isArray(t)) for (let i = 0, n = t.length; i < n; ++i) this.removeEventListener(t[i], e);
        else this.removeEventListener(t, e);
      }
    }
    K.prototype.on, K.prototype.once, K.prototype.un;
    const Z = K;
    function V() {
      throw new Error('Unimplemented abstract method.');
    }
    let q = 0;
    function U(t) {
      return t.ol_uid || (t.ol_uid = String(++q));
    }
    class H extends x {
      constructor(t, e, i) {
        super(t), (this.key = e), (this.oldValue = i);
      }
    }
    const $ = class extends Z {
        constructor(t) {
          super(), this.on, this.once, this.un, U(this), (this.values_ = null), void 0 !== t && this.setProperties(t);
        }
        get(t) {
          let e;
          return this.values_ && this.values_.hasOwnProperty(t) && (e = this.values_[t]), e;
        }
        getKeys() {
          return (this.values_ && Object.keys(this.values_)) || [];
        }
        getProperties() {
          return (this.values_ && Object.assign({}, this.values_)) || {};
        }
        getPropertiesInternal() {
          return this.values_;
        }
        hasProperties() {
          return !!this.values_;
        }
        notify(t, e) {
          let i;
          (i = `change:${t}`),
            this.hasListener(i) && this.dispatchEvent(new H(i, t, e)),
            (i = w),
            this.hasListener(i) && this.dispatchEvent(new H(i, t, e));
        }
        addChangeListener(t, e) {
          this.addEventListener(`change:${t}`, e);
        }
        removeChangeListener(t, e) {
          this.removeEventListener(`change:${t}`, e);
        }
        set(t, e, i) {
          const n = this.values_ || (this.values_ = {});
          if (i) n[t] = e;
          else {
            const i = n[t];
            (n[t] = e), i !== e && this.notify(t, i);
          }
        }
        setProperties(t, e) {
          for (const i in t) this.set(i, t[i], e);
        }
        applyProperties(t) {
          t.values_ && Object.assign(this.values_ || (this.values_ = {}), t.values_);
        }
        unset(t, e) {
          if (this.values_ && t in this.values_) {
            const i = this.values_[t];
            delete this.values_[t], k(this.values_) && (this.values_ = null), e || this.notify(t, i);
          }
        }
      },
      J = { CENTER: 'center', RESOLUTION: 'resolution', ROTATION: 'rotation' },
      Q = 42,
      tt = 256,
      et = {
        radians: 6370997 / (2 * Math.PI),
        degrees: (2 * Math.PI * 6370997) / 360,
        ft: 0.3048,
        m: 1,
        'us-ft': 1200 / 3937,
      },
      it = class {
        constructor(t) {
          (this.code_ = t.code),
            (this.units_ = t.units),
            (this.extent_ = void 0 !== t.extent ? t.extent : null),
            (this.worldExtent_ = void 0 !== t.worldExtent ? t.worldExtent : null),
            (this.axisOrientation_ = void 0 !== t.axisOrientation ? t.axisOrientation : 'enu'),
            (this.global_ = void 0 !== t.global && t.global),
            (this.canWrapX_ = !(!this.global_ || !this.extent_)),
            (this.getPointResolutionFunc_ = t.getPointResolution),
            (this.defaultTileGrid_ = null),
            (this.metersPerUnit_ = t.metersPerUnit);
        }
        canWrapX() {
          return this.canWrapX_;
        }
        getCode() {
          return this.code_;
        }
        getExtent() {
          return this.extent_;
        }
        getUnits() {
          return this.units_;
        }
        getMetersPerUnit() {
          return this.metersPerUnit_ || et[this.units_];
        }
        getWorldExtent() {
          return this.worldExtent_;
        }
        getAxisOrientation() {
          return this.axisOrientation_;
        }
        isGlobal() {
          return this.global_;
        }
        setGlobal(t) {
          (this.global_ = t), (this.canWrapX_ = !(!t || !this.extent_));
        }
        getDefaultTileGrid() {
          return this.defaultTileGrid_;
        }
        setDefaultTileGrid(t) {
          this.defaultTileGrid_ = t;
        }
        setExtent(t) {
          (this.extent_ = t), (this.canWrapX_ = !(!this.global_ || !t));
        }
        setWorldExtent(t) {
          this.worldExtent_ = t;
        }
        setGetPointResolution(t) {
          this.getPointResolutionFunc_ = t;
        }
        getPointResolutionFunc() {
          return this.getPointResolutionFunc_;
        }
      },
      nt = 6378137,
      st = Math.PI * nt,
      rt = [-st, -st, st, st],
      ot = [-180, -85, 180, 85],
      at = nt * Math.log(Math.tan(Math.PI / 2));
    class ht extends it {
      constructor(t) {
        super({
          code: t,
          units: 'm',
          extent: rt,
          global: !0,
          worldExtent: ot,
          getPointResolution: function (t, e) {
            return t / Math.cosh(e[1] / nt);
          },
        });
      }
    }
    const lt = [
      new ht('EPSG:3857'),
      new ht('EPSG:102100'),
      new ht('EPSG:102113'),
      new ht('EPSG:900913'),
      new ht('http://www.opengis.net/def/crs/EPSG/0/3857'),
      new ht('http://www.opengis.net/gml/srs/epsg.xml#3857'),
    ];
    const ct = [-180, -90, 180, 90],
      ut = (6378137 * Math.PI) / 180;
    class dt extends it {
      constructor(t, e) {
        super({
          code: t,
          units: 'degrees',
          extent: ct,
          axisOrientation: e,
          global: !0,
          metersPerUnit: ut,
          worldExtent: ct,
        });
      }
    }
    const gt = [
      new dt('CRS:84'),
      new dt('EPSG:4326', 'neu'),
      new dt('urn:ogc:def:crs:OGC:1.3:CRS84'),
      new dt('urn:ogc:def:crs:OGC:2:84'),
      new dt('http://www.opengis.net/def/crs/OGC/1.3/CRS84'),
      new dt('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),
      new dt('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu'),
    ];
    let ft = {},
      _t = {};
    function pt(t, e, i) {
      const n = t.getCode(),
        s = e.getCode();
      n in _t || (_t[n] = {}), (_t[n][s] = i);
    }
    const mt = { UNKNOWN: 0, INTERSECTING: 1, ABOVE: 2, RIGHT: 4, BELOW: 8, LEFT: 16 };
    function yt(t) {
      const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      for (let i = 0, n = t.length; i < n; ++i) Ft(e, t[i]);
      return e;
    }
    function vt(t, e, i) {
      return i
        ? ((i[0] = t[0] - e), (i[1] = t[1] - e), (i[2] = t[2] + e), (i[3] = t[3] + e), i)
        : [t[0] - e, t[1] - e, t[2] + e, t[3] + e];
    }
    function xt(t, e) {
      return e ? ((e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), (e[3] = t[3]), e) : t.slice();
    }
    function wt(t, e, i) {
      let n, s;
      return (
        (n = e < t[0] ? t[0] - e : t[2] < e ? e - t[2] : 0),
        (s = i < t[1] ? t[1] - i : t[3] < i ? i - t[3] : 0),
        n * n + s * s
      );
    }
    function Ct(t, e) {
      return Et(t, e[0], e[1]);
    }
    function St(t, e) {
      return t[0] <= e[0] && e[2] <= t[2] && t[1] <= e[1] && e[3] <= t[3];
    }
    function Et(t, e, i) {
      return t[0] <= e && e <= t[2] && t[1] <= i && i <= t[3];
    }
    function Tt(t, e) {
      const i = t[0],
        n = t[1],
        s = t[2],
        r = t[3],
        o = e[0],
        a = e[1];
      let h = mt.UNKNOWN;
      return (
        o < i ? (h |= mt.LEFT) : o > s && (h |= mt.RIGHT),
        a < n ? (h |= mt.BELOW) : a > r && (h |= mt.ABOVE),
        h === mt.UNKNOWN && (h = mt.INTERSECTING),
        h
      );
    }
    function bt(t, e, i, n, s) {
      return s ? ((s[0] = t), (s[1] = e), (s[2] = i), (s[3] = n), s) : [t, e, i, n];
    }
    function It(t) {
      return bt(1 / 0, 1 / 0, -1 / 0, -1 / 0, t);
    }
    function Rt(t, e) {
      const i = t[0],
        n = t[1];
      return bt(i, n, i, n, e);
    }
    function Mt(t, e, i, n, s) {
      return kt(It(s), t, e, i, n);
    }
    function Pt(t, e) {
      return t[0] == e[0] && t[2] == e[2] && t[1] == e[1] && t[3] == e[3];
    }
    function Lt(t, e) {
      return (
        e[0] < t[0] && (t[0] = e[0]),
        e[2] > t[2] && (t[2] = e[2]),
        e[1] < t[1] && (t[1] = e[1]),
        e[3] > t[3] && (t[3] = e[3]),
        t
      );
    }
    function Ft(t, e) {
      e[0] < t[0] && (t[0] = e[0]),
        e[0] > t[2] && (t[2] = e[0]),
        e[1] < t[1] && (t[1] = e[1]),
        e[1] > t[3] && (t[3] = e[1]);
    }
    function kt(t, e, i, n, s) {
      for (; i < n; i += s) At(t, e[i], e[i + 1]);
      return t;
    }
    function At(t, e, i) {
      (t[0] = Math.min(t[0], e)), (t[1] = Math.min(t[1], i)), (t[2] = Math.max(t[2], e)), (t[3] = Math.max(t[3], i));
    }
    function Ot(t, e) {
      let i;
      return (i = e(Gt(t))), i || ((i = e(Nt(t))), i || ((i = e(Zt(t))), i || ((i = e(Kt(t))), i || !1)));
    }
    function Dt(t) {
      let e = 0;
      return Ut(t) || (e = Vt(t) * Yt(t)), e;
    }
    function Gt(t) {
      return [t[0], t[1]];
    }
    function Nt(t) {
      return [t[2], t[1]];
    }
    function zt(t) {
      return [(t[0] + t[2]) / 2, (t[1] + t[3]) / 2];
    }
    function Wt(t, e) {
      let i;
      if ('bottom-left' === e) i = Gt(t);
      else if ('bottom-right' === e) i = Nt(t);
      else if ('top-left' === e) i = Kt(t);
      else {
        if ('top-right' !== e) throw new Error('Invalid corner');
        i = Zt(t);
      }
      return i;
    }
    function Xt(t, e, i, n, s) {
      const [r, o, a, h, l, c, u, d] = jt(t, e, i, n);
      return bt(Math.min(r, a, l, u), Math.min(o, h, c, d), Math.max(r, a, l, u), Math.max(o, h, c, d), s);
    }
    function jt(t, e, i, n) {
      const s = (e * n[0]) / 2,
        r = (e * n[1]) / 2,
        o = Math.cos(i),
        a = Math.sin(i),
        h = s * o,
        l = s * a,
        c = r * o,
        u = r * a,
        d = t[0],
        g = t[1];
      return [
        d - h + u,
        g - l - c,
        d - h - u,
        g - l + c,
        d + h - u,
        g + l + c,
        d + h + u,
        g + l - c,
        d - h + u,
        g - l - c,
      ];
    }
    function Yt(t) {
      return t[3] - t[1];
    }
    function Bt(t, e, i) {
      const n = i || [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      return (
        qt(t, e)
          ? (t[0] > e[0] ? (n[0] = t[0]) : (n[0] = e[0]),
            t[1] > e[1] ? (n[1] = t[1]) : (n[1] = e[1]),
            t[2] < e[2] ? (n[2] = t[2]) : (n[2] = e[2]),
            t[3] < e[3] ? (n[3] = t[3]) : (n[3] = e[3]))
          : It(n),
        n
      );
    }
    function Kt(t) {
      return [t[0], t[3]];
    }
    function Zt(t) {
      return [t[2], t[3]];
    }
    function Vt(t) {
      return t[2] - t[0];
    }
    function qt(t, e) {
      return t[0] <= e[2] && t[2] >= e[0] && t[1] <= e[3] && t[3] >= e[1];
    }
    function Ut(t) {
      return t[2] < t[0] || t[3] < t[1];
    }
    function Ht(t, e) {
      const i = e.getExtent(),
        n = zt(t);
      if (e.canWrapX() && (n[0] < i[0] || n[0] >= i[2])) {
        const e = Vt(i),
          s = Math.floor((n[0] - i[0]) / e) * e;
        (t[0] -= s), (t[2] -= s);
      }
      return t;
    }
    function $t(t, e) {
      let i = !0;
      for (let n = t.length - 1; n >= 0; --n)
        if (t[n] != e[n]) {
          i = !1;
          break;
        }
      return i;
    }
    function Jt(t, e) {
      const i = Math.cos(e),
        n = Math.sin(e),
        s = t[0] * i - t[1] * n,
        r = t[1] * i + t[0] * n;
      return (t[0] = s), (t[1] = r), t;
    }
    function Qt(t, e) {
      const i = t[0] - e[0],
        n = t[1] - e[1];
      return i * i + n * n;
    }
    function te(t, e) {
      return Math.sqrt(Qt(t, e));
    }
    function ee(t, e) {
      if (e.canWrapX()) {
        const i = Vt(e.getExtent()),
          n = (function (t, e, i) {
            const n = e.getExtent();
            let s = 0;
            return (
              e.canWrapX() && (t[0] < n[0] || t[0] > n[2]) && ((i = i || Vt(n)), (s = Math.floor((t[0] - n[0]) / i))), s
            );
          })(t, e, i);
        n && (t[0] -= n * i);
      }
      return t;
    }
    function ie(t, e, i) {
      return Math.min(Math.max(t, e), i);
    }
    function ne(t, e, i, n, s, r) {
      const o = s - i,
        a = r - n;
      if (0 !== o || 0 !== a) {
        const h = ((t - i) * o + (e - n) * a) / (o * o + a * a);
        h > 1 ? ((i = s), (n = r)) : h > 0 && ((i += o * h), (n += a * h));
      }
      return se(t, e, i, n);
    }
    function se(t, e, i, n) {
      const s = i - t,
        r = n - e;
      return s * s + r * r;
    }
    function re(t) {
      return (t * Math.PI) / 180;
    }
    function oe(t, e) {
      const i = t % e;
      return i * e < 0 ? i + e : i;
    }
    function ae(t, e, i) {
      return t + i * (e - t);
    }
    function he(t, e) {
      const i = Math.pow(10, e);
      return Math.round(t * i) / i;
    }
    function le(t, e) {
      return Math.floor(he(t, e));
    }
    function ce(t, e) {
      return Math.ceil(he(t, e));
    }
    const ue = 6371008.8;
    function de(t, e, i) {
      i = i || ue;
      const n = re(t[1]),
        s = re(e[1]),
        r = (s - n) / 2,
        o = re(e[0] - t[0]) / 2,
        a = Math.sin(r) * Math.sin(r) + Math.sin(o) * Math.sin(o) * Math.cos(n) * Math.cos(s);
      return 2 * i * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }
    const ge = { info: 1, warn: 2, error: 3, none: 4 };
    let fe = ge.info;
    function _e(...t) {
      fe > ge.warn || console.warn(...t);
    }
    let pe = !0;
    function me(t) {
      pe = !(void 0 === t || t);
    }
    function ye(t, e) {
      if (void 0 !== e) for (let i = 0, n = t.length; i < n; ++i) e[i] = t[i];
      else e = t.slice();
      return e;
    }
    function ve(t, e) {
      if (void 0 !== e && t !== e) {
        for (let i = 0, n = t.length; i < n; ++i) e[i] = t[i];
        t = e;
      }
      return t;
    }
    function xe(t) {
      !(function (t, e) {
        ft[t] = e;
      })(t.getCode(), t),
        pt(t, t, ye);
    }
    function we(t) {
      return 'string' == typeof t
        ? ft[(e = t)] || ft[e.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, 'EPSG:$3')] || null
        : t || null;
      var e;
    }
    function Ce(t, e, i, n) {
      let s;
      const r = (t = we(t)).getPointResolutionFunc();
      if (r) {
        if (((s = r(e, i)), n && n !== t.getUnits())) {
          const e = t.getMetersPerUnit();
          e && (s = (s * e) / et[n]);
        }
      } else {
        const r = t.getUnits();
        if (('degrees' == r && !n) || 'degrees' == n) s = e;
        else {
          const o = Ie(t, we('EPSG:4326'));
          if (o === ve && 'degrees' !== r) s = e * t.getMetersPerUnit();
          else {
            let t = [i[0] - e / 2, i[1], i[0] + e / 2, i[1], i[0], i[1] - e / 2, i[0], i[1] + e / 2];
            (t = o(t, t, 2)), (s = (de(t.slice(0, 2), t.slice(2, 4)) + de(t.slice(4, 6), t.slice(6, 8))) / 2);
          }
          const a = n ? et[n] : t.getMetersPerUnit();
          void 0 !== a && (s /= a);
        }
      }
      return s;
    }
    function Se(t) {
      !(function (t) {
        t.forEach(xe);
      })(t),
        t.forEach(function (e) {
          t.forEach(function (t) {
            e !== t && pt(e, t, ye);
          });
        });
    }
    function Ee(t, e) {
      return t ? ('string' == typeof t ? we(t) : t) : we(e);
    }
    function Te(t, e) {
      return me(), Me(t, 'EPSG:4326', void 0 !== e ? e : 'EPSG:3857');
    }
    function be(t, e) {
      if (t === e) return !0;
      const i = t.getUnits() === e.getUnits();
      return (t.getCode() === e.getCode() || Ie(t, e) === ye) && i;
    }
    function Ie(t, e) {
      let i = (function (t, e) {
        let i;
        return t in _t && e in _t[t] && (i = _t[t][e]), i;
      })(t.getCode(), e.getCode());
      return i || (i = ve), i;
    }
    function Re(t, e) {
      return Ie(we(t), we(e));
    }
    function Me(t, e, i) {
      return Re(e, i)(t, void 0, t.length);
    }
    let Pe = null;
    function Le() {
      return Pe;
    }
    function Fe(t, e) {
      return t;
    }
    function ke(t, e) {
      return (
        pe &&
          !$t(t, [0, 0]) &&
          t[0] >= -180 &&
          t[0] <= 180 &&
          t[1] >= -90 &&
          t[1] <= 90 &&
          ((pe = !1), _e('Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.')),
        t
      );
    }
    function Ae(t, e) {
      return t;
    }
    function Oe(t, e) {
      return t;
    }
    function De(t, e) {
      return t;
    }
    var Ge, Ne, ze;
    function We(t, e) {
      if (!t) throw new Error(e);
    }
    function Xe(t, e, i) {
      return function (n, s, r, o, a) {
        if (!n) return;
        if (!s && !e) return n;
        const h = e ? 0 : r[0] * s,
          l = e ? 0 : r[1] * s,
          c = a ? a[0] : 0,
          u = a ? a[1] : 0;
        let d = t[0] + h / 2 + c,
          g = t[2] - h / 2 + c,
          f = t[1] + l / 2 + u,
          _ = t[3] - l / 2 + u;
        d > g && ((d = (g + d) / 2), (g = d)), f > _ && ((f = (_ + f) / 2), (_ = f));
        let p = ie(n[0], d, g),
          m = ie(n[1], f, _);
        if (o && i && s) {
          const t = 30 * s;
          (p += -t * Math.log(1 + Math.max(0, d - n[0]) / t) + t * Math.log(1 + Math.max(0, n[0] - g) / t)),
            (m += -t * Math.log(1 + Math.max(0, f - n[1]) / t) + t * Math.log(1 + Math.max(0, n[1] - _) / t));
        }
        return [p, m];
      };
    }
    function je(t) {
      return t;
    }
    function Ye(t, e, i, n) {
      const s = Vt(e) / i[0],
        r = Yt(e) / i[1];
      return n ? Math.min(t, Math.max(s, r)) : Math.min(t, Math.min(s, r));
    }
    function Be(t, e, i) {
      let n = Math.min(t, e);
      return (
        (n *= Math.log(1 + 50 * Math.max(0, t / e - 1)) / 50 + 1),
        i && ((n = Math.max(n, i)), (n /= Math.log(1 + 50 * Math.max(0, i / t - 1)) / 50 + 1)),
        ie(n, i / 2, 2 * e)
      );
    }
    function Ke(t, e, i, n, s) {
      return (
        (i = void 0 === i || i),
        function (r, o, a, h) {
          if (void 0 !== r) {
            const o = n ? Ye(t, n, a, s) : t;
            return i && h ? Be(r, o, e) : ie(r, e, o);
          }
        }
      );
    }
    function Ze(t) {
      if (void 0 !== t) return 0;
    }
    function Ve(t) {
      if (void 0 !== t) return t;
    }
    function qe(t) {
      return Math.pow(t, 3);
    }
    function Ue(t) {
      return 1 - qe(1 - t);
    }
    function He(t) {
      return 3 * t * t - 2 * t * t * t;
    }
    function $e(t) {
      return t;
    }
    Se(lt),
      Se(gt),
      (Ge = lt),
      (Ne = function (t, e, i) {
        const n = t.length;
        (i = i > 1 ? i : 2), void 0 === e && (e = i > 2 ? t.slice() : new Array(n));
        for (let s = 0; s < n; s += i) {
          e[s] = (st * t[s]) / 180;
          let i = nt * Math.log(Math.tan((Math.PI * (+t[s + 1] + 90)) / 360));
          i > at ? (i = at) : i < -at && (i = -at), (e[s + 1] = i);
        }
        return e;
      }),
      (ze = function (t, e, i) {
        const n = t.length;
        (i = i > 1 ? i : 2), void 0 === e && (e = i > 2 ? t.slice() : new Array(n));
        for (let s = 0; s < n; s += i)
          (e[s] = (180 * t[s]) / st), (e[s + 1] = (360 * Math.atan(Math.exp(t[s + 1] / nt))) / Math.PI - 90);
        return e;
      }),
      gt.forEach(function (t) {
        Ge.forEach(function (e) {
          pt(t, e, Ne), pt(e, t, ze);
        });
      });
    const Je =
        'undefined' != typeof navigator && void 0 !== navigator.userAgent ? navigator.userAgent.toLowerCase() : '',
      Qe = Je.includes('firefox'),
      ti =
        (Je.includes('safari') &&
          !Je.includes('chrom') &&
          (Je.includes('version/15.4') || /cpu (os|iphone os) 15_4 like mac os x/.test(Je)),
        Je.includes('webkit') && !Je.includes('edge')),
      ei = Je.includes('macintosh'),
      ii = 'undefined' != typeof devicePixelRatio ? devicePixelRatio : 1,
      ni =
        'undefined' != typeof WorkerGlobalScope &&
        'undefined' != typeof OffscreenCanvas &&
        self instanceof WorkerGlobalScope,
      si = 'undefined' != typeof Image && Image.prototype.decode,
      ri = (function () {
        let t = !1;
        try {
          const e = Object.defineProperty({}, 'passive', {
            get: function () {
              t = !0;
            },
          });
          window.addEventListener('_', null, e), window.removeEventListener('_', null, e);
        } catch (t) {}
        return t;
      })();
    function oi(t, e) {
      const i = e[0],
        n = e[1];
      return (e[0] = t[0] * i + t[2] * n + t[4]), (e[1] = t[1] * i + t[3] * n + t[5]), e;
    }
    function ai(t, e, i, n, s, r, o, a) {
      const h = Math.sin(r),
        l = Math.cos(r);
      return (
        (t[0] = n * l),
        (t[1] = s * h),
        (t[2] = -n * h),
        (t[3] = s * l),
        (t[4] = o * n * l - a * n * h + e),
        (t[5] = o * s * h + a * s * l + i),
        t
      );
    }
    function hi(t, e) {
      const i = (n = e)[0] * n[3] - n[1] * n[2];
      var n;
      We(0 !== i, 'Transformation matrix cannot be inverted');
      const s = e[0],
        r = e[1],
        o = e[2],
        a = e[3],
        h = e[4],
        l = e[5];
      return (
        (t[0] = a / i),
        (t[1] = -r / i),
        (t[2] = -o / i),
        (t[3] = s / i),
        (t[4] = (o * l - a * h) / i),
        (t[5] = -(s * l - r * h) / i),
        t
      );
    }
    let li;
    function ci(t) {
      const e = 'matrix(' + t.join(', ') + ')';
      if (ni) return e;
      const i = li || (li = document.createElement('div'));
      return (i.style.transform = e), i.style.transform;
    }
    function ui(t, e, i, n, s, r) {
      r = r || [];
      let o = 0;
      for (let a = e; a < i; a += n) {
        const e = t[a],
          i = t[a + 1];
        (r[o++] = s[0] * e + s[2] * i + s[4]), (r[o++] = s[1] * e + s[3] * i + s[5]);
      }
      return r && r.length != o && (r.length = o), r;
    }
    function di(t, e, i, n, s, r, o) {
      o = o || [];
      const a = Math.cos(s),
        h = Math.sin(s),
        l = r[0],
        c = r[1];
      let u = 0;
      for (let s = e; s < i; s += n) {
        const e = t[s] - l,
          i = t[s + 1] - c;
        (o[u++] = l + e * a - i * h), (o[u++] = c + e * h + i * a);
        for (let e = s + 2; e < s + n; ++e) o[u++] = t[e];
      }
      return o && o.length != u && (o.length = u), o;
    }
    new Array(6);
    const gi = [1, 0, 0, 1, 0, 0],
      fi = class extends $ {
        constructor() {
          super(),
            (this.extent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
            (this.extentRevision_ = -1),
            (this.simplifiedGeometryMaxMinSquaredTolerance = 0),
            (this.simplifiedGeometryRevision = 0),
            (this.simplifyTransformedInternal = L((t, e, i) => {
              if (!i) return this.getSimplifiedGeometry(e);
              const n = this.clone();
              return n.applyTransform(i), n.getSimplifiedGeometry(e);
            }));
        }
        simplifyTransformed(t, e) {
          return this.simplifyTransformedInternal(this.getRevision(), t, e);
        }
        clone() {
          return V();
        }
        closestPointXY(t, e, i, n) {
          return V();
        }
        containsXY(t, e) {
          const i = this.getClosestPoint([t, e]);
          return i[0] === t && i[1] === e;
        }
        getClosestPoint(t, e) {
          return (e = e || [NaN, NaN]), this.closestPointXY(t[0], t[1], e, 1 / 0), e;
        }
        intersectsCoordinate(t) {
          return this.containsXY(t[0], t[1]);
        }
        computeExtent(t) {
          return V();
        }
        getExtent(t) {
          if (this.extentRevision_ != this.getRevision()) {
            const t = this.computeExtent(this.extent_);
            (isNaN(t[0]) || isNaN(t[1])) && It(t), (this.extentRevision_ = this.getRevision());
          }
          return (function (t, e) {
            return e ? ((e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), (e[3] = t[3]), e) : t;
          })(this.extent_, t);
        }
        rotate(t, e) {
          V();
        }
        scale(t, e, i) {
          V();
        }
        simplify(t) {
          return this.getSimplifiedGeometry(t * t);
        }
        getSimplifiedGeometry(t) {
          return V();
        }
        getType() {
          return V();
        }
        applyTransform(t) {
          V();
        }
        intersectsExtent(t) {
          return V();
        }
        translate(t, e) {
          V();
        }
        transform(t, e) {
          const i = we(t),
            n =
              'tile-pixels' == i.getUnits()
                ? function (t, n, s) {
                    const r = i.getExtent(),
                      o = i.getWorldExtent(),
                      a = Yt(o) / Yt(r);
                    return ai(gi, o[0], o[3], a, -a, 0, 0, 0), ui(t, 0, t.length, s, gi, n), Re(i, e)(t, n, s);
                  }
                : Re(i, e);
          return this.applyTransform(n), this;
        }
      };
    function _i(t) {
      let e;
      return 'XY' == t ? (e = 2) : 'XYZ' == t || 'XYM' == t ? (e = 3) : 'XYZM' == t && (e = 4), e;
    }
    const pi = class extends fi {
      constructor() {
        super(), (this.layout = 'XY'), (this.stride = 2), this.flatCoordinates;
      }
      computeExtent(t) {
        return Mt(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t);
      }
      getCoordinates() {
        return V();
      }
      getFirstCoordinate() {
        return this.flatCoordinates.slice(0, this.stride);
      }
      getFlatCoordinates() {
        return this.flatCoordinates;
      }
      getLastCoordinate() {
        return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
      }
      getLayout() {
        return this.layout;
      }
      getSimplifiedGeometry(t) {
        if (
          (this.simplifiedGeometryRevision !== this.getRevision() &&
            ((this.simplifiedGeometryMaxMinSquaredTolerance = 0),
            (this.simplifiedGeometryRevision = this.getRevision())),
          t < 0 ||
            (0 !== this.simplifiedGeometryMaxMinSquaredTolerance && t <= this.simplifiedGeometryMaxMinSquaredTolerance))
        )
          return this;
        const e = this.getSimplifiedGeometryInternal(t);
        return e.getFlatCoordinates().length < this.flatCoordinates.length
          ? e
          : ((this.simplifiedGeometryMaxMinSquaredTolerance = t), this);
      }
      getSimplifiedGeometryInternal(t) {
        return this;
      }
      getStride() {
        return this.stride;
      }
      setFlatCoordinates(t, e) {
        (this.stride = _i(t)), (this.layout = t), (this.flatCoordinates = e);
      }
      setCoordinates(t, e) {
        V();
      }
      setLayout(t, e, i) {
        let n;
        if (t) n = _i(t);
        else {
          for (let t = 0; t < i; ++t) {
            if (0 === e.length) return (this.layout = 'XY'), void (this.stride = 2);
            e = e[0];
          }
          (n = e.length),
            (t = (function (t) {
              let e;
              return 2 == t ? (e = 'XY') : 3 == t ? (e = 'XYZ') : 4 == t && (e = 'XYZM'), e;
            })(n));
        }
        (this.layout = t), (this.stride = n);
      }
      applyTransform(t) {
        this.flatCoordinates && (t(this.flatCoordinates, this.flatCoordinates, this.stride), this.changed());
      }
      rotate(t, e) {
        const i = this.getFlatCoordinates();
        if (i) {
          const n = this.getStride();
          di(i, 0, i.length, n, t, e, i), this.changed();
        }
      }
      scale(t, e, i) {
        void 0 === e && (e = t), i || (i = zt(this.getExtent()));
        const n = this.getFlatCoordinates();
        if (n) {
          const s = this.getStride();
          !(function (t, e, i, n, s, r, o, a) {
            a = a || [];
            const h = o[0],
              l = o[1];
            let c = 0;
            for (let e = 0; e < i; e += n) {
              const i = t[e] - h,
                o = t[e + 1] - l;
              (a[c++] = h + s * i), (a[c++] = l + r * o);
              for (let i = e + 2; i < e + n; ++i) a[c++] = t[i];
            }
            a && a.length != c && (a.length = c);
          })(n, 0, n.length, s, t, e, i, n),
            this.changed();
        }
      }
      translate(t, e) {
        const i = this.getFlatCoordinates();
        if (i) {
          const n = this.getStride();
          !(function (t, e, i, n, s, r, o) {
            o = o || [];
            let a = 0;
            for (let e = 0; e < i; e += n) {
              (o[a++] = t[e] + s), (o[a++] = t[e + 1] + r);
              for (let i = e + 2; i < e + n; ++i) o[a++] = t[i];
            }
            o && o.length != a && (o.length = a);
          })(i, 0, i.length, n, t, e, i),
            this.changed();
        }
      }
    };
    function mi(t, e, i, n, s, r, o) {
      const a = t[e],
        h = t[e + 1],
        l = t[i] - a,
        c = t[i + 1] - h;
      let u;
      if (0 === l && 0 === c) u = e;
      else {
        const d = ((s - a) * l + (r - h) * c) / (l * l + c * c);
        if (d > 1) u = i;
        else {
          if (d > 0) {
            for (let s = 0; s < n; ++s) o[s] = ae(t[e + s], t[i + s], d);
            return void (o.length = n);
          }
          u = e;
        }
      }
      for (let e = 0; e < n; ++e) o[e] = t[u + e];
      o.length = n;
    }
    function yi(t, e, i, n, s) {
      let r = t[e],
        o = t[e + 1];
      for (e += n; e < i; e += n) {
        const i = t[e],
          n = t[e + 1],
          a = se(r, o, i, n);
        a > s && (s = a), (r = i), (o = n);
      }
      return s;
    }
    function vi(t, e, i, n, s) {
      for (let r = 0, o = i.length; r < o; ++r) {
        const o = i[r];
        (s = yi(t, e, o, n, s)), (e = o);
      }
      return s;
    }
    function xi(t, e, i, n, s, r, o, a, h, l, c) {
      if (e == i) return l;
      let u, d;
      if (0 === s) {
        if (((d = se(o, a, t[e], t[e + 1])), d < l)) {
          for (u = 0; u < n; ++u) h[u] = t[e + u];
          return (h.length = n), d;
        }
        return l;
      }
      c = c || [NaN, NaN];
      let g = e + n;
      for (; g < i; )
        if ((mi(t, g - n, g, n, o, a, c), (d = se(o, a, c[0], c[1])), d < l)) {
          for (l = d, u = 0; u < n; ++u) h[u] = c[u];
          (h.length = n), (g += n);
        } else g += n * Math.max(((Math.sqrt(d) - Math.sqrt(l)) / s) | 0, 1);
      if (r && (mi(t, i - n, e, n, o, a, c), (d = se(o, a, c[0], c[1])), d < l)) {
        for (l = d, u = 0; u < n; ++u) h[u] = c[u];
        h.length = n;
      }
      return l;
    }
    function wi(t, e, i, n, s, r, o, a, h, l, c) {
      c = c || [NaN, NaN];
      for (let u = 0, d = i.length; u < d; ++u) {
        const d = i[u];
        (l = xi(t, e, d, n, s, r, o, a, h, l, c)), (e = d);
      }
      return l;
    }
    function Ci(t, e, i, n) {
      for (let n = 0, s = i.length; n < s; ++n) t[e++] = i[n];
      return e;
    }
    function Si(t, e, i, n) {
      for (let s = 0, r = i.length; s < r; ++s) {
        const r = i[s];
        for (let i = 0; i < n; ++i) t[e++] = r[i];
      }
      return e;
    }
    function Ei(t, e, i, n, s) {
      s = s || [];
      let r = 0;
      for (let o = 0, a = i.length; o < a; ++o) {
        const a = Si(t, e, i[o], n);
        (s[r++] = a), (e = a);
      }
      return (s.length = r), s;
    }
    function Ti(t, e, i, n, s, r, o) {
      const a = (i - e) / n;
      if (a < 3) {
        for (; e < i; e += n) (r[o++] = t[e]), (r[o++] = t[e + 1]);
        return o;
      }
      const h = new Array(a);
      (h[0] = 1), (h[a - 1] = 1);
      const l = [e, i - n];
      let c = 0;
      for (; l.length > 0; ) {
        const i = l.pop(),
          r = l.pop();
        let o = 0;
        const a = t[r],
          u = t[r + 1],
          d = t[i],
          g = t[i + 1];
        for (let e = r + n; e < i; e += n) {
          const i = ne(t[e], t[e + 1], a, u, d, g);
          i > o && ((c = e), (o = i));
        }
        o > s && ((h[(c - e) / n] = 1), r + n < c && l.push(r, c), c + n < i && l.push(c, i));
      }
      for (let i = 0; i < a; ++i) h[i] && ((r[o++] = t[e + i * n]), (r[o++] = t[e + i * n + 1]));
      return o;
    }
    function bi(t, e, i, n, s, r, o, a) {
      for (let h = 0, l = i.length; h < l; ++h) {
        const l = i[h];
        (o = Ti(t, e, l, n, s, r, o)), a.push(o), (e = l);
      }
      return o;
    }
    function Ii(t, e) {
      return e * Math.round(t / e);
    }
    function Ri(t, e, i, n, s, r, o) {
      if (e == i) return o;
      let a,
        h,
        l = Ii(t[e], s),
        c = Ii(t[e + 1], s);
      (e += n), (r[o++] = l), (r[o++] = c);
      do {
        if (((a = Ii(t[e], s)), (h = Ii(t[e + 1], s)), (e += n) == i)) return (r[o++] = a), (r[o++] = h), o;
      } while (a == l && h == c);
      for (; e < i; ) {
        const i = Ii(t[e], s),
          u = Ii(t[e + 1], s);
        if (((e += n), i == a && u == h)) continue;
        const d = a - l,
          g = h - c,
          f = i - l,
          _ = u - c;
        d * _ == g * f &&
        ((d < 0 && f < d) || d == f || (d > 0 && f > d)) &&
        ((g < 0 && _ < g) || g == _ || (g > 0 && _ > g))
          ? ((a = i), (h = u))
          : ((r[o++] = a), (r[o++] = h), (l = a), (c = h), (a = i), (h = u));
      }
      return (r[o++] = a), (r[o++] = h), o;
    }
    function Mi(t, e, i, n, s, r, o, a) {
      for (let h = 0, l = i.length; h < l; ++h) {
        const l = i[h];
        (o = Ri(t, e, l, n, s, r, o)), a.push(o), (e = l);
      }
      return o;
    }
    function Pi(t, e, i, n, s) {
      s = void 0 !== s ? s : [];
      let r = 0;
      for (let o = e; o < i; o += n) s[r++] = t.slice(o, o + n);
      return (s.length = r), s;
    }
    function Li(t, e, i, n, s) {
      s = void 0 !== s ? s : [];
      let r = 0;
      for (let o = 0, a = i.length; o < a; ++o) {
        const a = i[o];
        (s[r++] = Pi(t, e, a, n, s[r])), (e = a);
      }
      return (s.length = r), s;
    }
    function Fi(t, e, i, n, s) {
      s = void 0 !== s ? s : [];
      let r = 0;
      for (let o = 0, a = i.length; o < a; ++o) {
        const a = i[o];
        (s[r++] = 1 === a.length && a[0] === e ? [] : Li(t, e, a, n, s[r])), (e = a[a.length - 1]);
      }
      return (s.length = r), s;
    }
    function ki(t, e, i, n) {
      let s = 0,
        r = t[i - n],
        o = t[i - n + 1];
      for (; e < i; e += n) {
        const i = t[e],
          n = t[e + 1];
        (s += o * i - r * n), (r = i), (o = n);
      }
      return s / 2;
    }
    function Ai(t, e, i, n) {
      let s = 0;
      for (let r = 0, o = i.length; r < o; ++r) {
        const o = i[r];
        (s += ki(t, e, o, n)), (e = o);
      }
      return s;
    }
    class Oi extends pi {
      constructor(t, e) {
        super(),
          (this.maxDelta_ = -1),
          (this.maxDeltaRevision_ = -1),
          void 0 === e || Array.isArray(t[0]) ? this.setCoordinates(t, e) : this.setFlatCoordinates(e, t);
      }
      clone() {
        return new Oi(this.flatCoordinates.slice(), this.layout);
      }
      closestPointXY(t, e, i, n) {
        return n < wt(this.getExtent(), t, e)
          ? n
          : (this.maxDeltaRevision_ != this.getRevision() &&
              ((this.maxDelta_ = Math.sqrt(yi(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0))),
              (this.maxDeltaRevision_ = this.getRevision())),
            xi(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, !0, t, e, i, n));
      }
      getArea() {
        return ki(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      }
      getCoordinates() {
        return Pi(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      }
      getSimplifiedGeometryInternal(t) {
        const e = [];
        return (
          (e.length = Ti(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e, 0)), new Oi(e, 'XY')
        );
      }
      getType() {
        return 'LinearRing';
      }
      intersectsExtent(t) {
        return !1;
      }
      setCoordinates(t, e) {
        this.setLayout(e, t, 1),
          this.flatCoordinates || (this.flatCoordinates = []),
          (this.flatCoordinates.length = Si(this.flatCoordinates, 0, t, this.stride)),
          this.changed();
      }
    }
    const Di = Oi;
    class Gi extends pi {
      constructor(t, e) {
        super(), this.setCoordinates(t, e);
      }
      clone() {
        const t = new Gi(this.flatCoordinates.slice(), this.layout);
        return t.applyProperties(this), t;
      }
      closestPointXY(t, e, i, n) {
        const s = this.flatCoordinates,
          r = se(t, e, s[0], s[1]);
        if (r < n) {
          const t = this.stride;
          for (let e = 0; e < t; ++e) i[e] = s[e];
          return (i.length = t), r;
        }
        return n;
      }
      getCoordinates() {
        return this.flatCoordinates.slice();
      }
      computeExtent(t) {
        return Rt(this.flatCoordinates, t);
      }
      getType() {
        return 'Point';
      }
      intersectsExtent(t) {
        return Et(t, this.flatCoordinates[0], this.flatCoordinates[1]);
      }
      setCoordinates(t, e) {
        this.setLayout(e, t, 0),
          this.flatCoordinates || (this.flatCoordinates = []),
          (this.flatCoordinates.length = Ci(this.flatCoordinates, 0, t, this.stride)),
          this.changed();
      }
    }
    const Ni = Gi;
    function zi(t, e, i, n, s) {
      return !Ot(s, function (s) {
        return !Wi(t, e, i, n, s[0], s[1]);
      });
    }
    function Wi(t, e, i, n, s, r) {
      let o = 0,
        a = t[i - n],
        h = t[i - n + 1];
      for (; e < i; e += n) {
        const i = t[e],
          n = t[e + 1];
        h <= r
          ? n > r && (i - a) * (r - h) - (s - a) * (n - h) > 0 && o++
          : n <= r && (i - a) * (r - h) - (s - a) * (n - h) < 0 && o--,
          (a = i),
          (h = n);
      }
      return 0 !== o;
    }
    function Xi(t, e, i, n, s, r) {
      if (0 === i.length) return !1;
      if (!Wi(t, e, i[0], n, s, r)) return !1;
      for (let e = 1, o = i.length; e < o; ++e) if (Wi(t, i[e - 1], i[e], n, s, r)) return !1;
      return !0;
    }
    function ji(t, e, i, n, s, r, o) {
      let a, h, l, c, u, d, g;
      const f = s[r + 1],
        _ = [];
      for (let s = 0, r = i.length; s < r; ++s) {
        const r = i[s];
        for (c = t[r - n], d = t[r - n + 1], a = e; a < r; a += n)
          (u = t[a]),
            (g = t[a + 1]),
            ((f <= d && g <= f) || (d <= f && f <= g)) && ((l = ((f - d) / (g - d)) * (u - c) + c), _.push(l)),
            (c = u),
            (d = g);
      }
      let p = NaN,
        m = -1 / 0;
      for (_.sort(S), c = _[0], a = 1, h = _.length; a < h; ++a) {
        u = _[a];
        const s = Math.abs(u - c);
        s > m && ((l = (c + u) / 2), Xi(t, e, i, n, l, f) && ((p = l), (m = s))), (c = u);
      }
      return isNaN(p) && (p = s[r]), o ? (o.push(p, f, m), o) : [p, f, m];
    }
    function Yi(t, e, i, n, s) {
      let r = [];
      for (let o = 0, a = i.length; o < a; ++o) {
        const a = i[o];
        (r = ji(t, e, a, n, s, 2 * o, r)), (e = a[a.length - 1]);
      }
      return r;
    }
    function Bi(t, e, i, n, s) {
      let r;
      for (e += n; e < i; e += n) if (((r = s(t.slice(e - n, e), t.slice(e, e + n))), r)) return r;
      return !1;
    }
    function Ki(t, e, i, n, s) {
      const r = kt([1 / 0, 1 / 0, -1 / 0, -1 / 0], t, e, i, n);
      return (
        !!qt(s, r) &&
        (!!St(s, r) ||
          (r[0] >= s[0] && r[2] <= s[2]) ||
          (r[1] >= s[1] && r[3] <= s[3]) ||
          Bi(t, e, i, n, function (t, e) {
            return (function (t, e, i) {
              let n = !1;
              const s = Tt(t, e),
                r = Tt(t, i);
              if (s === mt.INTERSECTING || r === mt.INTERSECTING) n = !0;
              else {
                const o = t[0],
                  a = t[1],
                  h = t[2],
                  l = t[3],
                  c = e[0],
                  u = e[1],
                  d = i[0],
                  g = i[1],
                  f = (g - u) / (d - c);
                let _, p;
                r & mt.ABOVE && !(s & mt.ABOVE) && ((_ = d - (g - l) / f), (n = _ >= o && _ <= h)),
                  n || !(r & mt.RIGHT) || s & mt.RIGHT || ((p = g - (d - h) * f), (n = p >= a && p <= l)),
                  n || !(r & mt.BELOW) || s & mt.BELOW || ((_ = d - (g - a) / f), (n = _ >= o && _ <= h)),
                  n || !(r & mt.LEFT) || s & mt.LEFT || ((p = g - (d - o) * f), (n = p >= a && p <= l));
              }
              return n;
            })(s, t, e);
          }))
      );
    }
    function Zi(t, e, i, n, s) {
      return !!(
        Ki(t, e, i, n, s) ||
        Wi(t, e, i, n, s[0], s[1]) ||
        Wi(t, e, i, n, s[0], s[3]) ||
        Wi(t, e, i, n, s[2], s[1]) ||
        Wi(t, e, i, n, s[2], s[3])
      );
    }
    function Vi(t, e, i, n, s) {
      if (!Zi(t, e, i[0], n, s)) return !1;
      if (1 === i.length) return !0;
      for (let e = 1, r = i.length; e < r; ++e)
        if (zi(t, i[e - 1], i[e], n, s) && !Ki(t, i[e - 1], i[e], n, s)) return !1;
      return !0;
    }
    function qi(t, e, i, n) {
      for (; e < i - n; ) {
        for (let s = 0; s < n; ++s) {
          const r = t[e + s];
          (t[e + s] = t[i - n + s]), (t[i - n + s] = r);
        }
        (e += n), (i -= n);
      }
    }
    function Ui(t, e, i, n) {
      let s = 0,
        r = t[i - n],
        o = t[i - n + 1];
      for (; e < i; e += n) {
        const i = t[e],
          n = t[e + 1];
        (s += (i - r) * (n + o)), (r = i), (o = n);
      }
      return 0 === s ? void 0 : s > 0;
    }
    function Hi(t, e, i, n, s) {
      s = void 0 !== s && s;
      for (let r = 0, o = i.length; r < o; ++r) {
        const o = i[r],
          a = Ui(t, e, o, n);
        if (0 === r) {
          if ((s && a) || (!s && !a)) return !1;
        } else if ((s && !a) || (!s && a)) return !1;
        e = o;
      }
      return !0;
    }
    function $i(t, e, i, n, s) {
      s = void 0 !== s && s;
      for (let r = 0, o = i.length; r < o; ++r) {
        const o = i[r],
          a = Ui(t, e, o, n);
        (0 === r ? (s && a) || (!s && !a) : (s && !a) || (!s && a)) && qi(t, e, o, n), (e = o);
      }
      return e;
    }
    function Ji(t, e, i, n, s) {
      for (let r = 0, o = i.length; r < o; ++r) e = $i(t, e, i[r], n, s);
      return e;
    }
    class Qi extends pi {
      constructor(t, e, i) {
        super(),
          (this.ends_ = []),
          (this.flatInteriorPointRevision_ = -1),
          (this.flatInteriorPoint_ = null),
          (this.maxDelta_ = -1),
          (this.maxDeltaRevision_ = -1),
          (this.orientedRevision_ = -1),
          (this.orientedFlatCoordinates_ = null),
          void 0 !== e && i ? (this.setFlatCoordinates(e, t), (this.ends_ = i)) : this.setCoordinates(t, e);
      }
      appendLinearRing(t) {
        this.flatCoordinates
          ? b(this.flatCoordinates, t.getFlatCoordinates())
          : (this.flatCoordinates = t.getFlatCoordinates().slice()),
          this.ends_.push(this.flatCoordinates.length),
          this.changed();
      }
      clone() {
        const t = new Qi(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
        return t.applyProperties(this), t;
      }
      closestPointXY(t, e, i, n) {
        return n < wt(this.getExtent(), t, e)
          ? n
          : (this.maxDeltaRevision_ != this.getRevision() &&
              ((this.maxDelta_ = Math.sqrt(vi(this.flatCoordinates, 0, this.ends_, this.stride, 0))),
              (this.maxDeltaRevision_ = this.getRevision())),
            wi(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, !0, t, e, i, n));
      }
      containsXY(t, e) {
        return Xi(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t, e);
      }
      getArea() {
        return Ai(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
      }
      getCoordinates(t) {
        let e;
        return (
          void 0 !== t
            ? ((e = this.getOrientedFlatCoordinates().slice()), $i(e, 0, this.ends_, this.stride, t))
            : (e = this.flatCoordinates),
          Li(e, 0, this.ends_, this.stride)
        );
      }
      getEnds() {
        return this.ends_;
      }
      getFlatInteriorPoint() {
        if (this.flatInteriorPointRevision_ != this.getRevision()) {
          const t = zt(this.getExtent());
          (this.flatInteriorPoint_ = ji(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t, 0)),
            (this.flatInteriorPointRevision_ = this.getRevision());
        }
        return this.flatInteriorPoint_;
      }
      getInteriorPoint() {
        return new Ni(this.getFlatInteriorPoint(), 'XYM');
      }
      getLinearRingCount() {
        return this.ends_.length;
      }
      getLinearRing(t) {
        return t < 0 || this.ends_.length <= t
          ? null
          : new Di(this.flatCoordinates.slice(0 === t ? 0 : this.ends_[t - 1], this.ends_[t]), this.layout);
      }
      getLinearRings() {
        const t = this.layout,
          e = this.flatCoordinates,
          i = this.ends_,
          n = [];
        let s = 0;
        for (let r = 0, o = i.length; r < o; ++r) {
          const o = i[r],
            a = new Di(e.slice(s, o), t);
          n.push(a), (s = o);
        }
        return n;
      }
      getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
          const t = this.flatCoordinates;
          Hi(t, 0, this.ends_, this.stride)
            ? (this.orientedFlatCoordinates_ = t)
            : ((this.orientedFlatCoordinates_ = t.slice()),
              (this.orientedFlatCoordinates_.length = $i(this.orientedFlatCoordinates_, 0, this.ends_, this.stride))),
            (this.orientedRevision_ = this.getRevision());
        }
        return this.orientedFlatCoordinates_;
      }
      getSimplifiedGeometryInternal(t) {
        const e = [],
          i = [];
        return (
          (e.length = Mi(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(t), e, 0, i)), new Qi(e, 'XY', i)
        );
      }
      getType() {
        return 'Polygon';
      }
      intersectsExtent(t) {
        return Vi(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t);
      }
      setCoordinates(t, e) {
        this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
        const i = Ei(this.flatCoordinates, 0, t, this.stride, this.ends_);
        (this.flatCoordinates.length = 0 === i.length ? 0 : i[i.length - 1]), this.changed();
      }
    }
    const tn = Qi;
    function en(t) {
      if (Ut(t)) throw new Error('Cannot create polygon from empty extent');
      const e = t[0],
        i = t[1],
        n = t[2],
        s = t[3],
        r = [e, i, e, s, n, s, n, i, e, i];
      return new Qi(r, 'XY', [r.length]);
    }
    function nn(t, e) {
      setTimeout(function () {
        t(e);
      }, 0);
    }
    function sn(t) {
      return (
        !(t.sourceCenter && t.targetCenter && !$t(t.sourceCenter, t.targetCenter)) &&
        t.sourceResolution === t.targetResolution &&
        t.sourceRotation === t.targetRotation
      );
    }
    function rn(t, e, i, n, s) {
      const r = Math.cos(-s);
      let o = Math.sin(-s),
        a = t[0] * r - t[1] * o,
        h = t[1] * r + t[0] * o;
      return (a += (e[0] / 2 - i[0]) * n), (h += (i[1] - e[1] / 2) * n), (o = -o), [a * r - h * o, h * r + a * o];
    }
    const on = class extends $ {
        constructor(t) {
          super(),
            this.on,
            this.once,
            this.un,
            (t = Object.assign({}, t)),
            (this.hints_ = [0, 0]),
            (this.animations_ = []),
            this.updateAnimationKey_,
            (this.projection_ = Ee(t.projection, 'EPSG:3857')),
            (this.viewportSize_ = [100, 100]),
            (this.targetCenter_ = null),
            this.targetResolution_,
            this.targetRotation_,
            (this.nextCenter_ = null),
            this.nextResolution_,
            this.nextRotation_,
            (this.cancelAnchor_ = void 0),
            t.projection && me(),
            t.center && (t.center = ke(t.center, this.projection_)),
            t.extent && (t.extent = Oe(t.extent, this.projection_)),
            this.applyOptions_(t);
        }
        applyOptions_(t) {
          const e = Object.assign({}, t);
          for (const t in J) delete e[t];
          this.setProperties(e, !0);
          const i = (function (t) {
            let e, i, n;
            let s = void 0 !== t.minZoom ? t.minZoom : 0,
              r = void 0 !== t.maxZoom ? t.maxZoom : 28;
            const o = void 0 !== t.zoomFactor ? t.zoomFactor : 2,
              a = void 0 !== t.multiWorld && t.multiWorld,
              h = void 0 === t.smoothResolutionConstraint || t.smoothResolutionConstraint,
              l = void 0 !== t.showFullExtent && t.showFullExtent,
              c = Ee(t.projection, 'EPSG:3857'),
              u = c.getExtent();
            let d = t.constrainOnlyCenter,
              g = t.extent;
            if ((a || g || !c.isGlobal() || ((d = !1), (g = u)), void 0 !== t.resolutions)) {
              const o = t.resolutions;
              (i = o[s]),
                (n = void 0 !== o[r] ? o[r] : o[o.length - 1]),
                (e = t.constrainResolution
                  ? (function (t, e, i, n) {
                      return (
                        (e = void 0 === e || e),
                        function (s, r, o, a) {
                          if (void 0 !== s) {
                            const h = t[0],
                              l = t[t.length - 1],
                              c = i ? Ye(h, i, o, n) : h;
                            if (a) return e ? Be(s, c, l) : ie(s, l, c);
                            const u = Math.min(c, s),
                              d = Math.floor(E(t, u, r));
                            return t[d] > c && d < t.length - 1 ? t[d + 1] : t[d];
                          }
                        }
                      );
                    })(o, h, !d && g, l)
                  : Ke(i, n, h, !d && g, l));
            } else {
              const a = (u ? Math.max(Vt(u), Yt(u)) : (360 * et.degrees) / c.getMetersPerUnit()) / tt / Math.pow(2, 0),
                f = a / Math.pow(2, 28);
              (i = t.maxResolution),
                void 0 !== i ? (s = 0) : (i = a / Math.pow(o, s)),
                (n = t.minResolution),
                void 0 === n &&
                  (n =
                    void 0 !== t.maxZoom ? (void 0 !== t.maxResolution ? i / Math.pow(o, r) : a / Math.pow(o, r)) : f),
                (r = s + Math.floor(Math.log(i / n) / Math.log(o))),
                (n = i / Math.pow(o, r - s)),
                (e = t.constrainResolution
                  ? (function (t, e, i, n, s, r) {
                      return (
                        (n = void 0 === n || n),
                        (i = void 0 !== i ? i : 0),
                        function (o, a, h, l) {
                          if (void 0 !== o) {
                            const c = s ? Ye(e, s, h, r) : e;
                            if (l) return n ? Be(o, c, i) : ie(o, i, c);
                            const u = 1e-9,
                              d = Math.ceil(Math.log(e / c) / Math.log(t) - u),
                              g = -a * (0.5 - u) + 0.5,
                              f = Math.min(c, o),
                              _ = Math.floor(Math.log(e / f) / Math.log(t) + g),
                              p = Math.max(d, _);
                            return ie(e / Math.pow(t, p), i, c);
                          }
                        }
                      );
                    })(o, i, n, h, !d && g, l)
                  : Ke(i, n, h, !d && g, l));
            }
            return { constraint: e, maxResolution: i, minResolution: n, minZoom: s, zoomFactor: o };
          })(t);
          (this.maxResolution_ = i.maxResolution),
            (this.minResolution_ = i.minResolution),
            (this.zoomFactor_ = i.zoomFactor),
            (this.resolutions_ = t.resolutions),
            (this.padding_ = t.padding),
            (this.minZoom_ = i.minZoom);
          const n = (function (t) {
              if (void 0 !== t.extent) {
                const e = void 0 === t.smoothExtentConstraint || t.smoothExtentConstraint;
                return Xe(t.extent, t.constrainOnlyCenter, e);
              }
              const e = Ee(t.projection, 'EPSG:3857');
              if (!0 !== t.multiWorld && e.isGlobal()) {
                const t = e.getExtent().slice();
                return (t[0] = -1 / 0), (t[2] = 1 / 0), Xe(t, !1, !1);
              }
              return je;
            })(t),
            s = i.constraint,
            r = (function (t) {
              if (void 0 === t.enableRotation || t.enableRotation) {
                const e = t.constrainRotation;
                return void 0 === e || !0 === e
                  ? (function (t) {
                      const e = re(5);
                      return function (t, i) {
                        return i || void 0 === t ? t : Math.abs(t) <= e ? 0 : t;
                      };
                    })()
                  : !1 === e
                    ? Ve
                    : 'number' == typeof e
                      ? (function (t) {
                          const e = (2 * Math.PI) / t;
                          return function (t, i) {
                            return i ? t : void 0 !== t ? (t = Math.floor(t / e + 0.5) * e) : void 0;
                          };
                        })(e)
                      : Ve;
              }
              return Ze;
            })(t);
          (this.constraints_ = { center: n, resolution: s, rotation: r }),
            this.setRotation(void 0 !== t.rotation ? t.rotation : 0),
            this.setCenterInternal(void 0 !== t.center ? t.center : null),
            void 0 !== t.resolution ? this.setResolution(t.resolution) : void 0 !== t.zoom && this.setZoom(t.zoom);
        }
        get padding() {
          return this.padding_;
        }
        set padding(t) {
          let e = this.padding_;
          this.padding_ = t;
          const i = this.getCenterInternal();
          if (i) {
            const n = t || [0, 0, 0, 0];
            e = e || [0, 0, 0, 0];
            const s = this.getResolution(),
              r = (s / 2) * (n[3] - e[3] + e[1] - n[1]),
              o = (s / 2) * (n[0] - e[0] + e[2] - n[2]);
            this.setCenterInternal([i[0] + r, i[1] - o]);
          }
        }
        getUpdatedOptions_(t) {
          const e = this.getProperties();
          return (
            void 0 !== e.resolution ? (e.resolution = this.getResolution()) : (e.zoom = this.getZoom()),
            (e.center = this.getCenterInternal()),
            (e.rotation = this.getRotation()),
            Object.assign({}, e, t)
          );
        }
        animate(t) {
          this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
          const e = new Array(arguments.length);
          for (let t = 0; t < e.length; ++t) {
            let i = arguments[t];
            i.center && ((i = Object.assign({}, i)), (i.center = ke(i.center, this.getProjection()))),
              i.anchor && ((i = Object.assign({}, i)), (i.anchor = ke(i.anchor, this.getProjection()))),
              (e[t] = i);
          }
          this.animateInternal.apply(this, e);
        }
        animateInternal(t) {
          let e,
            i = arguments.length;
          i > 1 && 'function' == typeof arguments[i - 1] && ((e = arguments[i - 1]), --i);
          let n = 0;
          for (; n < i && !this.isDef(); ++n) {
            const t = arguments[n];
            t.center && this.setCenterInternal(t.center),
              void 0 !== t.zoom ? this.setZoom(t.zoom) : t.resolution && this.setResolution(t.resolution),
              void 0 !== t.rotation && this.setRotation(t.rotation);
          }
          if (n === i) return void (e && nn(e, !0));
          let s = Date.now(),
            r = this.targetCenter_.slice(),
            o = this.targetResolution_,
            a = this.targetRotation_;
          const h = [];
          for (; n < i; ++n) {
            const t = arguments[n],
              i = {
                start: s,
                complete: !1,
                anchor: t.anchor,
                duration: void 0 !== t.duration ? t.duration : 1e3,
                easing: t.easing || He,
                callback: e,
              };
            if (
              (t.center && ((i.sourceCenter = r), (i.targetCenter = t.center.slice()), (r = i.targetCenter)),
              void 0 !== t.zoom
                ? ((i.sourceResolution = o),
                  (i.targetResolution = this.getResolutionForZoom(t.zoom)),
                  (o = i.targetResolution))
                : t.resolution &&
                  ((i.sourceResolution = o), (i.targetResolution = t.resolution), (o = i.targetResolution)),
              void 0 !== t.rotation)
            ) {
              i.sourceRotation = a;
              const e = oe(t.rotation - a + Math.PI, 2 * Math.PI) - Math.PI;
              (i.targetRotation = a + e), (a = i.targetRotation);
            }
            sn(i) ? (i.complete = !0) : (s += i.duration), h.push(i);
          }
          this.animations_.push(h), this.setHint(0, 1), this.updateAnimations_();
        }
        getAnimating() {
          return this.hints_[0] > 0;
        }
        getInteracting() {
          return this.hints_[1] > 0;
        }
        cancelAnimations() {
          let t;
          this.setHint(0, -this.hints_[0]);
          for (let e = 0, i = this.animations_.length; e < i; ++e) {
            const i = this.animations_[e];
            if ((i[0].callback && nn(i[0].callback, !1), !t))
              for (let e = 0, n = i.length; e < n; ++e) {
                const n = i[e];
                if (!n.complete) {
                  t = n.anchor;
                  break;
                }
              }
          }
          (this.animations_.length = 0),
            (this.cancelAnchor_ = t),
            (this.nextCenter_ = null),
            (this.nextResolution_ = NaN),
            (this.nextRotation_ = NaN);
        }
        updateAnimations_() {
          if (
            (void 0 !== this.updateAnimationKey_ &&
              (cancelAnimationFrame(this.updateAnimationKey_), (this.updateAnimationKey_ = void 0)),
            !this.getAnimating())
          )
            return;
          const t = Date.now();
          let e = !1;
          for (let i = this.animations_.length - 1; i >= 0; --i) {
            const n = this.animations_[i];
            let s = !0;
            for (let i = 0, r = n.length; i < r; ++i) {
              const r = n[i];
              if (r.complete) continue;
              const o = t - r.start;
              let a = r.duration > 0 ? o / r.duration : 1;
              a >= 1 ? ((r.complete = !0), (a = 1)) : (s = !1);
              const h = r.easing(a);
              if (r.sourceCenter) {
                const t = r.sourceCenter[0],
                  e = r.sourceCenter[1],
                  i = r.targetCenter[0],
                  n = r.targetCenter[1];
                this.nextCenter_ = r.targetCenter;
                const s = t + h * (i - t),
                  o = e + h * (n - e);
                this.targetCenter_ = [s, o];
              }
              if (r.sourceResolution && r.targetResolution) {
                const t =
                  1 === h ? r.targetResolution : r.sourceResolution + h * (r.targetResolution - r.sourceResolution);
                if (r.anchor) {
                  const e = this.getViewportSize_(this.getRotation()),
                    i = this.constraints_.resolution(t, 0, e, !0);
                  this.targetCenter_ = this.calculateCenterZoom(i, r.anchor);
                }
                (this.nextResolution_ = r.targetResolution), (this.targetResolution_ = t), this.applyTargetState_(!0);
              }
              if (void 0 !== r.sourceRotation && void 0 !== r.targetRotation) {
                const t =
                  1 === h
                    ? oe(r.targetRotation + Math.PI, 2 * Math.PI) - Math.PI
                    : r.sourceRotation + h * (r.targetRotation - r.sourceRotation);
                if (r.anchor) {
                  const e = this.constraints_.rotation(t, !0);
                  this.targetCenter_ = this.calculateCenterRotate(e, r.anchor);
                }
                (this.nextRotation_ = r.targetRotation), (this.targetRotation_ = t);
              }
              if ((this.applyTargetState_(!0), (e = !0), !r.complete)) break;
            }
            if (s) {
              (this.animations_[i] = null),
                this.setHint(0, -1),
                (this.nextCenter_ = null),
                (this.nextResolution_ = NaN),
                (this.nextRotation_ = NaN);
              const t = n[0].callback;
              t && nn(t, !0);
            }
          }
          (this.animations_ = this.animations_.filter(Boolean)),
            e &&
              void 0 === this.updateAnimationKey_ &&
              (this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this)));
        }
        calculateCenterRotate(t, e) {
          let i;
          const n = this.getCenterInternal();
          var s, r;
          return (
            void 0 !== n &&
              ((i = [n[0] - e[0], n[1] - e[1]]),
              Jt(i, t - this.getRotation()),
              (r = e),
              ((s = i)[0] += +r[0]),
              (s[1] += +r[1])),
            i
          );
        }
        calculateCenterZoom(t, e) {
          let i;
          const n = this.getCenterInternal(),
            s = this.getResolution();
          return (
            void 0 !== n && void 0 !== s && (i = [e[0] - (t * (e[0] - n[0])) / s, e[1] - (t * (e[1] - n[1])) / s]), i
          );
        }
        getViewportSize_(t) {
          const e = this.viewportSize_;
          if (t) {
            const i = e[0],
              n = e[1];
            return [
              Math.abs(i * Math.cos(t)) + Math.abs(n * Math.sin(t)),
              Math.abs(i * Math.sin(t)) + Math.abs(n * Math.cos(t)),
            ];
          }
          return e;
        }
        setViewportSize(t) {
          (this.viewportSize_ = Array.isArray(t) ? t.slice() : [100, 100]),
            this.getAnimating() || this.resolveConstraints(0);
        }
        getCenter() {
          const t = this.getCenterInternal();
          return t ? Fe(t, this.getProjection()) : t;
        }
        getCenterInternal() {
          return this.get(J.CENTER);
        }
        getConstraints() {
          return this.constraints_;
        }
        getConstrainResolution() {
          return this.get('constrainResolution');
        }
        getHints(t) {
          return void 0 !== t ? ((t[0] = this.hints_[0]), (t[1] = this.hints_[1]), t) : this.hints_.slice();
        }
        calculateExtent(t) {
          return Ae(this.calculateExtentInternal(t), this.getProjection());
        }
        calculateExtentInternal(t) {
          t = t || this.getViewportSizeMinusPadding_();
          const e = this.getCenterInternal();
          We(e, 'The view center is not defined');
          const i = this.getResolution();
          We(void 0 !== i, 'The view resolution is not defined');
          const n = this.getRotation();
          return We(void 0 !== n, 'The view rotation is not defined'), Xt(e, i, n, t);
        }
        getMaxResolution() {
          return this.maxResolution_;
        }
        getMinResolution() {
          return this.minResolution_;
        }
        getMaxZoom() {
          return this.getZoomForResolution(this.minResolution_);
        }
        setMaxZoom(t) {
          this.applyOptions_(this.getUpdatedOptions_({ maxZoom: t }));
        }
        getMinZoom() {
          return this.getZoomForResolution(this.maxResolution_);
        }
        setMinZoom(t) {
          this.applyOptions_(this.getUpdatedOptions_({ minZoom: t }));
        }
        setConstrainResolution(t) {
          this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: t }));
        }
        getProjection() {
          return this.projection_;
        }
        getResolution() {
          return this.get(J.RESOLUTION);
        }
        getResolutions() {
          return this.resolutions_;
        }
        getResolutionForExtent(t, e) {
          return this.getResolutionForExtentInternal(Oe(t, this.getProjection()), e);
        }
        getResolutionForExtentInternal(t, e) {
          e = e || this.getViewportSizeMinusPadding_();
          const i = Vt(t) / e[0],
            n = Yt(t) / e[1];
          return Math.max(i, n);
        }
        getResolutionForValueFunction(t) {
          t = t || 2;
          const e = this.getConstrainedResolution(this.maxResolution_),
            i = this.minResolution_,
            n = Math.log(e / i) / Math.log(t);
          return function (i) {
            return e / Math.pow(t, i * n);
          };
        }
        getRotation() {
          return this.get(J.ROTATION);
        }
        getValueForResolutionFunction(t) {
          const e = Math.log(t || 2),
            i = this.getConstrainedResolution(this.maxResolution_),
            n = this.minResolution_,
            s = Math.log(i / n) / e;
          return function (t) {
            return Math.log(i / t) / e / s;
          };
        }
        getViewportSizeMinusPadding_(t) {
          let e = this.getViewportSize_(t);
          const i = this.padding_;
          return i && (e = [e[0] - i[1] - i[3], e[1] - i[0] - i[2]]), e;
        }
        getState() {
          const t = this.getProjection(),
            e = this.getResolution(),
            i = this.getRotation();
          let n = this.getCenterInternal();
          const s = this.padding_;
          if (s) {
            const t = this.getViewportSizeMinusPadding_();
            n = rn(n, this.getViewportSize_(), [t[0] / 2 + s[3], t[1] / 2 + s[0]], e, i);
          }
          return {
            center: n.slice(0),
            projection: void 0 !== t ? t : null,
            resolution: e,
            nextCenter: this.nextCenter_,
            nextResolution: this.nextResolution_,
            nextRotation: this.nextRotation_,
            rotation: i,
            zoom: this.getZoom(),
          };
        }
        getViewStateAndExtent() {
          return { viewState: this.getState(), extent: this.calculateExtent() };
        }
        getZoom() {
          let t;
          const e = this.getResolution();
          return void 0 !== e && (t = this.getZoomForResolution(e)), t;
        }
        getZoomForResolution(t) {
          let e,
            i,
            n = this.minZoom_ || 0;
          if (this.resolutions_) {
            const s = E(this.resolutions_, t, 1);
            (n = s),
              (e = this.resolutions_[s]),
              (i = s == this.resolutions_.length - 1 ? 2 : e / this.resolutions_[s + 1]);
          } else (e = this.maxResolution_), (i = this.zoomFactor_);
          return n + Math.log(e / t) / Math.log(i);
        }
        getResolutionForZoom(t) {
          if (this.resolutions_) {
            if (this.resolutions_.length <= 1) return 0;
            const e = ie(Math.floor(t), 0, this.resolutions_.length - 2),
              i = this.resolutions_[e] / this.resolutions_[e + 1];
            return this.resolutions_[e] / Math.pow(i, ie(t - e, 0, 1));
          }
          return this.maxResolution_ / Math.pow(this.zoomFactor_, t - this.minZoom_);
        }
        fit(t, e) {
          let i;
          if (
            (We(
              Array.isArray(t) || 'function' == typeof t.getSimplifiedGeometry,
              'Invalid extent or geometry provided as `geometry`',
            ),
            Array.isArray(t))
          )
            We(!Ut(t), 'Cannot fit empty extent provided as `geometry`'), (i = en(Oe(t, this.getProjection())));
          else if ('Circle' === t.getType()) {
            const e = Oe(t.getExtent(), this.getProjection());
            (i = en(e)), i.rotate(this.getRotation(), zt(e));
          } else {
            const e = Le();
            i = e ? t.clone().transform(e, this.getProjection()) : t;
          }
          this.fitInternal(i, e);
        }
        rotatedExtentForGeometry(t) {
          const e = this.getRotation(),
            i = Math.cos(e),
            n = Math.sin(-e),
            s = t.getFlatCoordinates(),
            r = t.getStride();
          let o = 1 / 0,
            a = 1 / 0,
            h = -1 / 0,
            l = -1 / 0;
          for (let t = 0, e = s.length; t < e; t += r) {
            const e = s[t] * i - s[t + 1] * n,
              r = s[t] * n + s[t + 1] * i;
            (o = Math.min(o, e)), (a = Math.min(a, r)), (h = Math.max(h, e)), (l = Math.max(l, r));
          }
          return [o, a, h, l];
        }
        fitInternal(t, e) {
          let i = (e = e || {}).size;
          i || (i = this.getViewportSizeMinusPadding_());
          const n = void 0 !== e.padding ? e.padding : [0, 0, 0, 0],
            s = void 0 !== e.nearest && e.nearest;
          let r;
          r =
            void 0 !== e.minResolution
              ? e.minResolution
              : void 0 !== e.maxZoom
                ? this.getResolutionForZoom(e.maxZoom)
                : 0;
          const o = this.rotatedExtentForGeometry(t);
          let a = this.getResolutionForExtentInternal(o, [i[0] - n[1] - n[3], i[1] - n[0] - n[2]]);
          (a = isNaN(a) ? r : Math.max(a, r)), (a = this.getConstrainedResolution(a, s ? 0 : 1));
          const h = this.getRotation(),
            l = Math.sin(h),
            c = Math.cos(h),
            u = zt(o);
          (u[0] += ((n[1] - n[3]) / 2) * a), (u[1] += ((n[0] - n[2]) / 2) * a);
          const d = u[0] * c - u[1] * l,
            g = u[1] * c + u[0] * l,
            f = this.getConstrainedCenter([d, g], a),
            _ = e.callback ? e.callback : P;
          void 0 !== e.duration
            ? this.animateInternal({ resolution: a, center: f, duration: e.duration, easing: e.easing }, _)
            : ((this.targetResolution_ = a), (this.targetCenter_ = f), this.applyTargetState_(!1, !0), nn(_, !0));
        }
        centerOn(t, e, i) {
          this.centerOnInternal(ke(t, this.getProjection()), e, i);
        }
        centerOnInternal(t, e, i) {
          this.setCenterInternal(rn(t, e, i, this.getResolution(), this.getRotation()));
        }
        calculateCenterShift(t, e, i, n) {
          let s;
          const r = this.padding_;
          if (r && t) {
            const o = this.getViewportSizeMinusPadding_(-i),
              a = rn(t, n, [o[0] / 2 + r[3], o[1] / 2 + r[0]], e, i);
            s = [t[0] - a[0], t[1] - a[1]];
          }
          return s;
        }
        isDef() {
          return !!this.getCenterInternal() && void 0 !== this.getResolution();
        }
        adjustCenter(t) {
          const e = Fe(this.targetCenter_, this.getProjection());
          this.setCenter([e[0] + t[0], e[1] + t[1]]);
        }
        adjustCenterInternal(t) {
          const e = this.targetCenter_;
          this.setCenterInternal([e[0] + t[0], e[1] + t[1]]);
        }
        adjustResolution(t, e) {
          (e = e && ke(e, this.getProjection())), this.adjustResolutionInternal(t, e);
        }
        adjustResolutionInternal(t, e) {
          const i = this.getAnimating() || this.getInteracting(),
            n = this.getViewportSize_(this.getRotation()),
            s = this.constraints_.resolution(this.targetResolution_ * t, 0, n, i);
          e && (this.targetCenter_ = this.calculateCenterZoom(s, e)),
            (this.targetResolution_ *= t),
            this.applyTargetState_();
        }
        adjustZoom(t, e) {
          this.adjustResolution(Math.pow(this.zoomFactor_, -t), e);
        }
        adjustRotation(t, e) {
          e && (e = ke(e, this.getProjection())), this.adjustRotationInternal(t, e);
        }
        adjustRotationInternal(t, e) {
          const i = this.getAnimating() || this.getInteracting(),
            n = this.constraints_.rotation(this.targetRotation_ + t, i);
          e && (this.targetCenter_ = this.calculateCenterRotate(n, e)),
            (this.targetRotation_ += t),
            this.applyTargetState_();
        }
        setCenter(t) {
          this.setCenterInternal(t ? ke(t, this.getProjection()) : t);
        }
        setCenterInternal(t) {
          (this.targetCenter_ = t), this.applyTargetState_();
        }
        setHint(t, e) {
          return (this.hints_[t] += e), this.changed(), this.hints_[t];
        }
        setResolution(t) {
          (this.targetResolution_ = t), this.applyTargetState_();
        }
        setRotation(t) {
          (this.targetRotation_ = t), this.applyTargetState_();
        }
        setZoom(t) {
          this.setResolution(this.getResolutionForZoom(t));
        }
        applyTargetState_(t, e) {
          const i = this.getAnimating() || this.getInteracting() || e,
            n = this.constraints_.rotation(this.targetRotation_, i),
            s = this.getViewportSize_(n),
            r = this.constraints_.resolution(this.targetResolution_, 0, s, i),
            o = this.constraints_.center(
              this.targetCenter_,
              r,
              s,
              i,
              this.calculateCenterShift(this.targetCenter_, r, n, s),
            );
          this.get(J.ROTATION) !== n && this.set(J.ROTATION, n),
            this.get(J.RESOLUTION) !== r && (this.set(J.RESOLUTION, r), this.set('zoom', this.getZoom(), !0)),
            (o && this.get(J.CENTER) && $t(this.get(J.CENTER), o)) || this.set(J.CENTER, o),
            this.getAnimating() && !t && this.cancelAnimations(),
            (this.cancelAnchor_ = void 0);
        }
        resolveConstraints(t, e, i) {
          t = void 0 !== t ? t : 200;
          const n = e || 0,
            s = this.constraints_.rotation(this.targetRotation_),
            r = this.getViewportSize_(s),
            o = this.constraints_.resolution(this.targetResolution_, n, r),
            a = this.constraints_.center(
              this.targetCenter_,
              o,
              r,
              !1,
              this.calculateCenterShift(this.targetCenter_, o, s, r),
            );
          if (0 === t && !this.cancelAnchor_)
            return (
              (this.targetResolution_ = o),
              (this.targetRotation_ = s),
              (this.targetCenter_ = a),
              void this.applyTargetState_()
            );
          (i = i || (0 === t ? this.cancelAnchor_ : void 0)),
            (this.cancelAnchor_ = void 0),
            (this.getResolution() === o &&
              this.getRotation() === s &&
              this.getCenterInternal() &&
              $t(this.getCenterInternal(), a)) ||
              (this.getAnimating() && this.cancelAnimations(),
              this.animateInternal({ rotation: s, center: a, resolution: o, duration: t, easing: Ue, anchor: i }));
        }
        beginInteraction() {
          this.resolveConstraints(0), this.setHint(1, 1);
        }
        endInteraction(t, e, i) {
          (i = i && ke(i, this.getProjection())), this.endInteractionInternal(t, e, i);
        }
        endInteractionInternal(t, e, i) {
          this.getInteracting() && (this.setHint(1, -1), this.resolveConstraints(t, e, i));
        }
        getConstrainedCenter(t, e) {
          const i = this.getViewportSize_(this.getRotation());
          return this.constraints_.center(t, e || this.getResolution(), i);
        }
        getConstrainedZoom(t, e) {
          const i = this.getResolutionForZoom(t);
          return this.getZoomForResolution(this.getConstrainedResolution(i, e));
        }
        getConstrainedResolution(t, e) {
          e = e || 0;
          const i = this.getViewportSize_(this.getRotation());
          return this.constraints_.resolution(t, e, i);
        }
      },
      an = 'add',
      hn = 'remove',
      ln = 'length';
    class cn extends x {
      constructor(t, e, i) {
        super(t), (this.element = e), (this.index = i);
      }
    }
    const un = class extends $ {
        constructor(t, e) {
          if (
            (super(),
            this.on,
            this.once,
            this.un,
            (e = e || {}),
            (this.unique_ = !!e.unique),
            (this.array_ = t || []),
            this.unique_)
          )
            for (let t = 0, e = this.array_.length; t < e; ++t) this.assertUnique_(this.array_[t], t);
          this.updateLength_();
        }
        clear() {
          for (; this.getLength() > 0; ) this.pop();
        }
        extend(t) {
          for (let e = 0, i = t.length; e < i; ++e) this.push(t[e]);
          return this;
        }
        forEach(t) {
          const e = this.array_;
          for (let i = 0, n = e.length; i < n; ++i) t(e[i], i, e);
        }
        getArray() {
          return this.array_;
        }
        item(t) {
          return this.array_[t];
        }
        getLength() {
          return this.get(ln);
        }
        insertAt(t, e) {
          if (t < 0 || t > this.getLength()) throw new Error('Index out of bounds: ' + t);
          this.unique_ && this.assertUnique_(e),
            this.array_.splice(t, 0, e),
            this.updateLength_(),
            this.dispatchEvent(new cn(an, e, t));
        }
        pop() {
          return this.removeAt(this.getLength() - 1);
        }
        push(t) {
          this.unique_ && this.assertUnique_(t);
          const e = this.getLength();
          return this.insertAt(e, t), this.getLength();
        }
        remove(t) {
          const e = this.array_;
          for (let i = 0, n = e.length; i < n; ++i) if (e[i] === t) return this.removeAt(i);
        }
        removeAt(t) {
          if (t < 0 || t >= this.getLength()) return;
          const e = this.array_[t];
          return this.array_.splice(t, 1), this.updateLength_(), this.dispatchEvent(new cn(hn, e, t)), e;
        }
        setAt(t, e) {
          if (t >= this.getLength()) return void this.insertAt(t, e);
          if (t < 0) throw new Error('Index out of bounds: ' + t);
          this.unique_ && this.assertUnique_(e, t);
          const i = this.array_[t];
          (this.array_[t] = e), this.dispatchEvent(new cn(hn, i, t)), this.dispatchEvent(new cn(an, e, t));
        }
        updateLength_() {
          this.set(ln, this.array_.length);
        }
        assertUnique_(t, e) {
          for (let i = 0, n = this.array_.length; i < n; ++i)
            if (this.array_[i] === t && i !== e) throw new Error('Duplicate item added to a unique collection');
        }
      },
      dn = { name: 'rgb', min: [0, 0, 0], max: [255, 255, 255], channel: ['red', 'green', 'blue'], alias: ['RGB'] };
    var gn = {
      name: 'xyz',
      min: [0, 0, 0],
      channel: ['X', 'Y', 'Z'],
      alias: ['XYZ', 'ciexyz', 'cie1931'],
      whitepoint: {
        2: {
          A: [109.85, 100, 35.585],
          C: [98.074, 100, 118.232],
          D50: [96.422, 100, 82.521],
          D55: [95.682, 100, 92.149],
          D65: [95.045592705167, 100, 108.9057750759878],
          D75: [94.972, 100, 122.638],
          F2: [99.187, 100, 67.395],
          F7: [95.044, 100, 108.755],
          F11: [100.966, 100, 64.37],
          E: [100, 100, 100],
        },
        10: {
          A: [111.144, 100, 35.2],
          C: [97.285, 100, 116.145],
          D50: [96.72, 100, 81.427],
          D55: [95.799, 100, 90.926],
          D65: [94.811, 100, 107.304],
          D75: [94.416, 100, 120.641],
          F2: [103.28, 100, 69.026],
          F7: [95.792, 100, 107.687],
          F11: [103.866, 100, 65.627],
          E: [100, 100, 100],
        },
      },
    };
    (gn.max = gn.whitepoint[2].D65),
      (gn.rgb = function (t, e) {
        e = e || gn.whitepoint[2].E;
        var i,
          n,
          s,
          r = t[0] / e[0],
          o = t[1] / e[1],
          a = t[2] / e[2];
        return (
          (n = -0.96924363628087 * r + 1.87596750150772 * o + 0.041555057407175 * a),
          (s = 0.055630079696993 * r + -0.20397695888897 * o + 1.056971514242878 * a),
          (i =
            (i = 3.240969941904521 * r + -1.537383177570093 * o + -0.498610760293 * a) > 0.0031308
              ? 1.055 * Math.pow(i, 1 / 2.4) - 0.055
              : (i *= 12.92)),
          (n = n > 0.0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : (n *= 12.92)),
          (s = s > 0.0031308 ? 1.055 * Math.pow(s, 1 / 2.4) - 0.055 : (s *= 12.92)),
          [
            255 * (i = Math.min(Math.max(0, i), 1)),
            255 * (n = Math.min(Math.max(0, n), 1)),
            255 * (s = Math.min(Math.max(0, s), 1)),
          ]
        );
      }),
      (dn.xyz = function (t, e) {
        var i = t[0] / 255,
          n = t[1] / 255,
          s = t[2] / 255,
          r =
            0.21263900587151 * (i = i > 0.04045 ? Math.pow((i + 0.055) / 1.055, 2.4) : i / 12.92) +
            0.71516867876775 * (n = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92) +
            0.072192315360733 * (s = s > 0.04045 ? Math.pow((s + 0.055) / 1.055, 2.4) : s / 12.92),
          o = 0.019330818715591 * i + 0.11919477979462 * n + 0.95053215224966 * s;
        return [
          (0.41239079926595 * i + 0.35758433938387 * n + 0.18048078840183 * s) * (e = e || gn.whitepoint[2].E)[0],
          r * e[1],
          o * e[2],
        ];
      });
    const fn = gn,
      _n = {
        name: 'luv',
        min: [0, -134, -140],
        max: [100, 224, 122],
        channel: ['lightness', 'u', 'v'],
        alias: ['LUV', 'cieluv', 'cie1976'],
        xyz: function (t, e, i) {
          var n, s, r, o, a, h, l, c, u;
          return (
            (r = t[0]),
            (o = t[1]),
            (a = t[2]),
            0 === r
              ? [0, 0, 0]
              : ((e = e || 'D65'),
                (i = i || 2),
                (n =
                  o / (13 * r) +
                    (4 * (l = fn.whitepoint[i][e][0])) /
                      (l + 15 * (c = fn.whitepoint[i][e][1]) + 3 * (u = fn.whitepoint[i][e][2])) || 0),
                (s = a / (13 * r) + (9 * c) / (l + 15 * c + 3 * u) || 0),
                [
                  (9 * (h = r > 8 ? c * Math.pow((r + 16) / 116, 3) : c * r * 0.0011070564598794539) * n) / (4 * s) ||
                    0,
                  h,
                  (h * (12 - 3 * n - 20 * s)) / (4 * s) || 0,
                ])
          );
        },
      };
    fn.luv = function (t, e, i) {
      var n, s, r, o, a, h, l, c, u, d, g;
      (e = e || 'D65'),
        (i = i || 2),
        (d =
          (4 * (l = fn.whitepoint[i][e][0])) /
          (l + 15 * (c = fn.whitepoint[i][e][1]) + 3 * (u = fn.whitepoint[i][e][2]))),
        (g = (9 * c) / (l + 15 * c + 3 * u)),
        (n = (4 * (o = t[0])) / (o + 15 * (a = t[1]) + 3 * (h = t[2])) || 0),
        (s = (9 * a) / (o + 15 * a + 3 * h) || 0);
      var f = a / c;
      return [
        (r = f <= 0.008856451679035631 ? 903.2962962962961 * f : 116 * Math.pow(f, 1 / 3) - 16),
        13 * r * (n - d),
        13 * r * (s - g),
      ];
    };
    var pn = {
      name: 'lchuv',
      channel: ['lightness', 'chroma', 'hue'],
      alias: ['LCHuv', 'cielchuv'],
      min: [0, 0, 0],
      max: [100, 100, 360],
      luv: function (t) {
        var e,
          i = t[0],
          n = t[1];
        return (e = (t[2] / 360) * 2 * Math.PI), [i, n * Math.cos(e), n * Math.sin(e)];
      },
      xyz: function (t) {
        return _n.xyz(pn.luv(t));
      },
    };
    const mn = pn;
    (_n.lchuv = function (t) {
      var e = t[0],
        i = t[1],
        n = t[2],
        s = Math.sqrt(i * i + n * n),
        r = (360 * Math.atan2(n, i)) / 2 / Math.PI;
      return r < 0 && (r += 360), [e, s, r];
    }),
      (fn.lchuv = function (t) {
        return _n.lchuv(fn.luv(t));
      });
    var yn = i(168);
    const vn = function (t) {
      var e,
        i,
        n = [],
        s = 1;
      if ('number' == typeof t) return { space: 'rgb', values: [t >>> 16, (65280 & t) >>> 8, 255 & t], alpha: 1 };
      if ('number' == typeof t) return { space: 'rgb', values: [t >>> 16, (65280 & t) >>> 8, 255 & t], alpha: 1 };
      if (((t = String(t).toLowerCase()), yn[t])) (n = yn[t].slice()), (i = 'rgb');
      else if ('transparent' === t) (s = 0), (i = 'rgb'), (n = [0, 0, 0]);
      else if ('#' === t[0]) {
        var r = t.slice(1),
          o = r.length;
        (s = 1),
          o <= 4
            ? ((n = [parseInt(r[0] + r[0], 16), parseInt(r[1] + r[1], 16), parseInt(r[2] + r[2], 16)]),
              4 === o && (s = parseInt(r[3] + r[3], 16) / 255))
            : ((n = [parseInt(r[0] + r[1], 16), parseInt(r[2] + r[3], 16), parseInt(r[4] + r[5], 16)]),
              8 === o && (s = parseInt(r[6] + r[7], 16) / 255)),
          n[0] || (n[0] = 0),
          n[1] || (n[1] = 0),
          n[2] || (n[2] = 0),
          (i = 'rgb');
      } else if (
        (e =
          /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(
            t,
          ))
      ) {
        var a = e[1],
          h = 'cmyk' === (i = a.replace(/a$/, '')) ? 4 : 'gray' === i ? 1 : 3;
        (n = e[2].trim().split(/\s*[,\/]\s*|\s+/)),
          'color' === i && (i = n.shift()),
          (s =
            (n = n.map(function (t, e) {
              if ('%' === t[t.length - 1])
                return (
                  (t = parseFloat(t) / 100),
                  3 === e
                    ? t
                    : 'rgb' === i
                      ? 255 * t
                      : 'h' === i[0]
                        ? 100 * t
                        : 'l' !== i[0] || e
                          ? 'lab' === i
                            ? 125 * t
                            : 'lch' === i
                              ? e < 2
                                ? 150 * t
                                : 360 * t
                              : 'o' !== i[0] || e
                                ? 'oklab' === i
                                  ? 0.4 * t
                                  : 'oklch' === i
                                    ? e < 2
                                      ? 0.4 * t
                                      : 360 * t
                                    : t
                                : t
                          : 100 * t
                );
              if ('h' === i[e] || (2 === e && 'h' === i[i.length - 1])) {
                if (void 0 !== xn[t]) return xn[t];
                if (t.endsWith('deg')) return parseFloat(t);
                if (t.endsWith('turn')) return 360 * parseFloat(t);
                if (t.endsWith('grad')) return (360 * parseFloat(t)) / 400;
                if (t.endsWith('rad')) return (180 * parseFloat(t)) / Math.PI;
              }
              return 'none' === t ? 0 : parseFloat(t);
            })).length > h
              ? n.pop()
              : 1);
      } else
        /[0-9](?:\s|\/|,)/.test(t) &&
          ((n = t.match(/([0-9]+)/g).map(function (t) {
            return parseFloat(t);
          })),
          (i =
            t
              .match(/([a-z])/gi)
              ?.join('')
              ?.toLowerCase() || 'rgb'));
      return { space: i, values: n, alpha: s };
    };
    var xn = { red: 0, orange: 60, yellow: 120, green: 180, blue: 240, purple: 300 };
    const wn = {
      name: 'hsl',
      min: [0, 0, 0],
      max: [360, 100, 100],
      channel: ['hue', 'saturation', 'lightness'],
      alias: ['HSL'],
      rgb: function (t) {
        var e,
          i,
          n,
          s,
          r,
          o = t[0] / 360,
          a = t[1] / 100,
          h = t[2] / 100,
          l = 0;
        if (0 === a) return [(r = 255 * h), r, r];
        for (e = 2 * h - (i = h < 0.5 ? h * (1 + a) : h + a - h * a), s = [0, 0, 0]; l < 3; )
          (n = o + (1 / 3) * -(l - 1)) < 0 ? n++ : n > 1 && n--,
            (r = 6 * n < 1 ? e + 6 * (i - e) * n : 2 * n < 1 ? i : 3 * n < 2 ? e + (i - e) * (2 / 3 - n) * 6 : e),
            (s[l++] = 255 * r);
        return s;
      },
    };
    function Cn(t) {
      return 'string' == typeof t ? t : Ln(t);
    }
    dn.hsl = function (t) {
      var e,
        i,
        n = t[0] / 255,
        s = t[1] / 255,
        r = t[2] / 255,
        o = Math.min(n, s, r),
        a = Math.max(n, s, r),
        h = a - o;
      return (
        a === o
          ? (e = 0)
          : n === a
            ? (e = (s - r) / h)
            : s === a
              ? (e = 2 + (r - n) / h)
              : r === a && (e = 4 + (n - s) / h),
        (e = Math.min(60 * e, 360)) < 0 && (e += 360),
        (i = (o + a) / 2),
        [e, 100 * (a === o ? 0 : i <= 0.5 ? h / (a + o) : h / (2 - a - o)), 100 * i]
      );
    };
    const Sn = 1024,
      En = {};
    let Tn = 0;
    function bn(t) {
      if (4 === t.length) return t;
      const e = t.slice();
      return (e[3] = 1), e;
    }
    function In(t) {
      const e = fn.lchuv(dn.xyz(t));
      return (e[3] = t[3]), e;
    }
    function Rn(t) {
      if (En.hasOwnProperty(t)) return En[t];
      if (Tn >= Sn) {
        let t = 0;
        for (const e in En) 0 == (3 & t++) && (delete En[e], --Tn);
      }
      const e = (function (t) {
        var e;
        Array.isArray(t) && t.raw && (t = String.raw(...arguments)), t instanceof Number && (t = +t);
        var i = vn(t);
        if (!i.space) return [];
        const n = 'h' === i.space[0] ? wn.min : dn.min,
          s = 'h' === i.space[0] ? wn.max : dn.max;
        return (
          ((e = Array(3))[0] = Math.min(Math.max(i.values[0], n[0]), s[0])),
          (e[1] = Math.min(Math.max(i.values[1], n[1]), s[1])),
          (e[2] = Math.min(Math.max(i.values[2], n[2]), s[2])),
          'h' === i.space[0] && (e = wn.rgb(e)),
          e.push(Math.min(Math.max(i.alpha, 0), 1)),
          e
        );
      })(t);
      if (4 !== e.length) throw new Error('Failed to parse "' + t + '" as color');
      for (const i of e) if (isNaN(i)) throw new Error('Failed to parse "' + t + '" as color');
      return Pn(e), (En[t] = e), ++Tn, e;
    }
    function Mn(t) {
      return Array.isArray(t) ? t : Rn(t);
    }
    function Pn(t) {
      return (
        (t[0] = ie((t[0] + 0.5) | 0, 0, 255)),
        (t[1] = ie((t[1] + 0.5) | 0, 0, 255)),
        (t[2] = ie((t[2] + 0.5) | 0, 0, 255)),
        (t[3] = ie(t[3], 0, 1)),
        t
      );
    }
    function Ln(t) {
      let e = t[0];
      e != (0 | e) && (e = (e + 0.5) | 0);
      let i = t[1];
      i != (0 | i) && (i = (i + 0.5) | 0);
      let n = t[2];
      return (
        n != (0 | n) && (n = (n + 0.5) | 0),
        'rgba(' + e + ',' + i + ',' + n + ',' + (void 0 === t[3] ? 1 : Math.round(100 * t[3]) / 100) + ')'
      );
    }
    function Fn(t, e, i) {
      return e + ':' + t + ':' + (i ? Cn(i) : 'null');
    }
    const kn = new (class {
        constructor() {
          (this.cache_ = {}), (this.cacheSize_ = 0), (this.maxCacheSize_ = 32);
        }
        clear() {
          (this.cache_ = {}), (this.cacheSize_ = 0);
        }
        canExpireCache() {
          return this.cacheSize_ > this.maxCacheSize_;
        }
        expire() {
          if (this.canExpireCache()) {
            let t = 0;
            for (const e in this.cache_) {
              const i = this.cache_[e];
              0 != (3 & t++) || i.hasListener() || (delete this.cache_[e], --this.cacheSize_);
            }
          }
        }
        get(t, e, i) {
          const n = Fn(t, e, i);
          return n in this.cache_ ? this.cache_[n] : null;
        }
        set(t, e, i, n) {
          const s = Fn(t, e, i);
          (this.cache_[s] = n), ++this.cacheSize_;
        }
        setSize(t) {
          (this.maxCacheSize_ = t), this.expire();
        }
      })(),
      An = 'opacity',
      On = 'visible',
      Dn = 'extent',
      Gn = 'zIndex',
      Nn = 'maxResolution',
      zn = 'minResolution',
      Wn = 'maxZoom',
      Xn = 'minZoom',
      jn = 'source',
      Yn = class extends $ {
        constructor(t) {
          super(), this.on, this.once, this.un, (this.background_ = t.background);
          const e = Object.assign({}, t);
          'object' == typeof t.properties && (delete e.properties, Object.assign(e, t.properties)),
            (e[An] = void 0 !== t.opacity ? t.opacity : 1),
            We('number' == typeof e[An], 'Layer opacity must be a number'),
            (e[On] = void 0 === t.visible || t.visible),
            (e[Gn] = t.zIndex),
            (e[Nn] = void 0 !== t.maxResolution ? t.maxResolution : 1 / 0),
            (e[zn] = void 0 !== t.minResolution ? t.minResolution : 0),
            (e[Xn] = void 0 !== t.minZoom ? t.minZoom : -1 / 0),
            (e[Wn] = void 0 !== t.maxZoom ? t.maxZoom : 1 / 0),
            (this.className_ = void 0 !== e.className ? e.className : 'ol-layer'),
            delete e.className,
            this.setProperties(e),
            (this.state_ = null);
        }
        getBackground() {
          return this.background_;
        }
        getClassName() {
          return this.className_;
        }
        getLayerState(t) {
          const e = this.state_ || { layer: this, managed: void 0 === t || t },
            i = this.getZIndex();
          return (
            (e.opacity = ie(Math.round(100 * this.getOpacity()) / 100, 0, 1)),
            (e.visible = this.getVisible()),
            (e.extent = this.getExtent()),
            (e.zIndex = void 0 !== i || e.managed ? i : 1 / 0),
            (e.maxResolution = this.getMaxResolution()),
            (e.minResolution = Math.max(this.getMinResolution(), 0)),
            (e.minZoom = this.getMinZoom()),
            (e.maxZoom = this.getMaxZoom()),
            (this.state_ = e),
            e
          );
        }
        getLayersArray(t) {
          return V();
        }
        getLayerStatesArray(t) {
          return V();
        }
        getExtent() {
          return this.get(Dn);
        }
        getMaxResolution() {
          return this.get(Nn);
        }
        getMinResolution() {
          return this.get(zn);
        }
        getMinZoom() {
          return this.get(Xn);
        }
        getMaxZoom() {
          return this.get(Wn);
        }
        getOpacity() {
          return this.get(An);
        }
        getSourceState() {
          return V();
        }
        getVisible() {
          return this.get(On);
        }
        getZIndex() {
          return this.get(Gn);
        }
        setBackground(t) {
          (this.background_ = t), this.changed();
        }
        setExtent(t) {
          this.set(Dn, t);
        }
        setMaxResolution(t) {
          this.set(Nn, t);
        }
        setMinResolution(t) {
          this.set(zn, t);
        }
        setMaxZoom(t) {
          this.set(Wn, t);
        }
        setMinZoom(t) {
          this.set(Xn, t);
        }
        setOpacity(t) {
          We('number' == typeof t, 'Layer opacity must be a number'), this.set(An, t);
        }
        setVisible(t) {
          this.set(On, t);
        }
        setZIndex(t) {
          this.set(Gn, t);
        }
        disposeInternal() {
          this.state_ && ((this.state_.layer = null), (this.state_ = null)), super.disposeInternal();
        }
      },
      Bn = 'prerender',
      Kn = 'postrender',
      Zn = 'precompose',
      Vn = 'rendercomplete';
    function qn(t, e) {
      if (!t.visible) return !1;
      const i = e.resolution;
      if (i < t.minResolution || i >= t.maxResolution) return !1;
      const n = e.zoom;
      return n > t.minZoom && n <= t.maxZoom;
    }
    const Un = class extends Yn {
      constructor(t) {
        const e = Object.assign({}, t);
        delete e.source,
          super(e),
          this.on,
          this.once,
          this.un,
          (this.mapPrecomposeKey_ = null),
          (this.mapRenderKey_ = null),
          (this.sourceChangeKey_ = null),
          (this.renderer_ = null),
          (this.sourceReady_ = !1),
          (this.rendered = !1),
          t.render && (this.render = t.render),
          t.map && this.setMap(t.map),
          this.addChangeListener(jn, this.handleSourcePropertyChange_);
        const i = t.source ? t.source : null;
        this.setSource(i);
      }
      getLayersArray(t) {
        return (t = t || []).push(this), t;
      }
      getLayerStatesArray(t) {
        return (t = t || []).push(this.getLayerState()), t;
      }
      getSource() {
        return this.get(jn) || null;
      }
      getRenderSource() {
        return this.getSource();
      }
      getSourceState() {
        const t = this.getSource();
        return t ? t.getState() : 'undefined';
      }
      handleSourceChange_() {
        this.changed(),
          this.sourceReady_ ||
            'ready' !== this.getSource().getState() ||
            ((this.sourceReady_ = !0), this.dispatchEvent('sourceready'));
      }
      handleSourcePropertyChange_() {
        this.sourceChangeKey_ && (B(this.sourceChangeKey_), (this.sourceChangeKey_ = null)), (this.sourceReady_ = !1);
        const t = this.getSource();
        t &&
          ((this.sourceChangeKey_ = j(t, O, this.handleSourceChange_, this)),
          'ready' === t.getState() &&
            ((this.sourceReady_ = !0),
            setTimeout(() => {
              this.dispatchEvent('sourceready');
            }, 0))),
          this.changed();
      }
      getFeatures(t) {
        return this.renderer_ ? this.renderer_.getFeatures(t) : Promise.resolve([]);
      }
      getData(t) {
        return this.renderer_ && this.rendered ? this.renderer_.getData(t) : null;
      }
      isVisible(t) {
        let e;
        const i = this.getMapInternal();
        let n;
        !t && i && (t = i.getView()),
          (e = t instanceof on ? { viewState: t.getState(), extent: t.calculateExtent() } : t),
          !e.layerStatesArray && i && (e.layerStatesArray = i.getLayerGroup().getLayerStatesArray()),
          (n = e.layerStatesArray ? e.layerStatesArray.find((t) => t.layer === this) : this.getLayerState());
        const s = this.getExtent();
        return qn(n, e.viewState) && (!s || qt(s, e.extent));
      }
      getAttributions(t) {
        if (!this.isVisible(t)) return [];
        let e;
        const i = this.getSource();
        if ((i && (e = i.getAttributions()), !e)) return [];
        let n = e(t instanceof on ? t.getViewStateAndExtent() : t);
        return Array.isArray(n) || (n = [n]), n;
      }
      render(t, e) {
        const i = this.getRenderer();
        return i.prepareFrame(t) ? ((this.rendered = !0), i.renderFrame(t, e)) : null;
      }
      unrender() {
        this.rendered = !1;
      }
      setMapInternal(t) {
        t || this.unrender(), this.set('map', t);
      }
      getMapInternal() {
        return this.get('map');
      }
      setMap(t) {
        this.mapPrecomposeKey_ && (B(this.mapPrecomposeKey_), (this.mapPrecomposeKey_ = null)),
          t || this.changed(),
          this.mapRenderKey_ && (B(this.mapRenderKey_), (this.mapRenderKey_ = null)),
          t &&
            ((this.mapPrecomposeKey_ = j(
              t,
              Zn,
              function (t) {
                const e = t.frameState.layerStatesArray,
                  i = this.getLayerState(!1);
                We(
                  !e.some(function (t) {
                    return t.layer === i.layer;
                  }),
                  'A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.',
                ),
                  e.push(i);
              },
              this,
            )),
            (this.mapRenderKey_ = j(this, O, t.render, t)),
            this.changed());
      }
      setSource(t) {
        this.set(jn, t);
      }
      getRenderer() {
        return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_;
      }
      hasRenderer() {
        return !!this.renderer_;
      }
      createRenderer() {
        return null;
      }
      disposeInternal() {
        this.renderer_ && (this.renderer_.dispose(), delete this.renderer_),
          this.setSource(null),
          super.disposeInternal();
      }
    };
    function Hn(t, e) {
      kn.expire();
    }
    const $n = class extends C {
        constructor(t) {
          super(), (this.map_ = t);
        }
        dispatchRenderEvent(t, e) {
          V();
        }
        calculateMatrices2D(t) {
          const e = t.viewState,
            i = t.coordinateToPixelTransform,
            n = t.pixelToCoordinateTransform;
          ai(
            i,
            t.size[0] / 2,
            t.size[1] / 2,
            1 / e.resolution,
            -1 / e.resolution,
            -e.rotation,
            -e.center[0],
            -e.center[1],
          ),
            hi(n, i);
        }
        forEachFeatureAtCoordinate(t, e, i, n, s, r, o, a) {
          let h;
          const l = e.viewState;
          function c(t, e, i, n) {
            return s.call(r, e, t ? i : null, n);
          }
          const u = l.projection,
            d = ee(t.slice(), u),
            g = [[0, 0]];
          if (u.canWrapX() && n) {
            const t = Vt(u.getExtent());
            g.push([-t, 0], [t, 0]);
          }
          const f = e.layerStatesArray,
            _ = f.length,
            p = [],
            m = [];
          for (let n = 0; n < g.length; n++)
            for (let s = _ - 1; s >= 0; --s) {
              const r = f[s],
                u = r.layer;
              if (u.hasRenderer() && qn(r, l) && o.call(a, u)) {
                const s = u.getRenderer(),
                  o = u.getSource();
                if (s && o) {
                  const a = o.getWrapX() ? d : t,
                    l = c.bind(null, r.managed);
                  (m[0] = a[0] + g[n][0]), (m[1] = a[1] + g[n][1]), (h = s.forEachFeatureAtCoordinate(m, e, i, l, p));
                }
                if (h) return h;
              }
            }
          if (0 === p.length) return;
          const y = 1 / p.length;
          return (
            p.forEach((t, e) => (t.distanceSq += e * y)),
            p.sort((t, e) => t.distanceSq - e.distanceSq),
            p.some((t) => (h = t.callback(t.feature, t.layer, t.geometry))),
            h
          );
        }
        hasFeatureAtCoordinate(t, e, i, n, s, r) {
          return void 0 !== this.forEachFeatureAtCoordinate(t, e, i, n, R, this, s, r);
        }
        getMap() {
          return this.map_;
        }
        renderFrame(t) {
          V();
        }
        flushDeclutterItems(t) {}
        scheduleExpireIconCache(t) {
          kn.canExpireCache() && t.postRenderFunctions.push(Hn);
        }
      },
      Jn = class extends x {
        constructor(t, e, i, n) {
          super(t), (this.inversePixelTransform = e), (this.frameState = i), (this.context = n);
        }
      },
      Qn = 'ol-hidden',
      ts = 'ol-unselectable',
      es = 'ol-control',
      is = 'ol-collapsed',
      ns = new RegExp(
        [
          '^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)',
          '(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)',
          '(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)',
          '(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?',
          '(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))',
          '(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))',
          '?\\s*([-,\\"\\\'\\sa-z]+?)\\s*$',
        ].join(''),
        'i',
      ),
      ss = ['style', 'variant', 'weight', 'size', 'lineHeight', 'family'],
      rs = function (t) {
        const e = t.match(ns);
        if (!e) return null;
        const i = { lineHeight: 'normal', size: '1.2em', style: 'normal', weight: 'normal', variant: 'normal' };
        for (let t = 0, n = ss.length; t < n; ++t) {
          const n = e[t + 1];
          void 0 !== n && (i[ss[t]] = n);
        }
        return (i.families = i.family.split(/,\s?/)), i;
      };
    function os(t, e, i, n) {
      let s;
      return (
        (s =
          i && i.length ? i.shift() : ni ? new OffscreenCanvas(t || 300, e || 300) : document.createElement('canvas')),
        t && (s.width = t),
        e && (s.height = e),
        s.getContext('2d', n)
      );
    }
    function as(t) {
      const e = t.canvas;
      (e.width = 1), (e.height = 1), t.clearRect(0, 0, 1, 1);
    }
    function hs(t, e) {
      const i = e.parentNode;
      i && i.replaceChild(t, e);
    }
    function ls(t) {
      return t && t.parentNode ? t.parentNode.removeChild(t) : null;
    }
    const cs = '10px sans-serif',
      us = '#000',
      ds = 'round',
      gs = [],
      fs = 'round',
      _s = '#000',
      ps = 'center',
      ms = 'middle',
      ys = [0, 0, 0, 0],
      vs = new $();
    let xs,
      ws = null;
    const Cs = {},
      Ss = (function () {
        const t = '32px ',
          e = ['monospace', 'serif'],
          i = e.length,
          n = 'wmytzilWMYTZIL@#/&?$%10';
        let s, r;
        function o(s, o, a) {
          let h = !0;
          for (let l = 0; l < i; ++l) {
            const i = e[l];
            if (((r = bs(s + ' ' + o + ' ' + t + i, n)), a != i)) {
              const e = bs(s + ' ' + o + ' ' + t + a + ',' + i, n);
              h = h && e != r;
            }
          }
          return !!h;
        }
        function a() {
          let t = !0;
          const e = vs.getKeys();
          for (let i = 0, n = e.length; i < n; ++i) {
            const n = e[i];
            vs.get(n) < 100 &&
              (o.apply(this, n.split('\n'))
                ? (F(Cs), (ws = null), (xs = void 0), vs.set(n, 100))
                : (vs.set(n, vs.get(n) + 1, !0), (t = !1)));
          }
          t && (clearInterval(s), (s = void 0));
        }
        return function (t) {
          const e = rs(t);
          if (!e) return;
          const i = e.families;
          for (let t = 0, n = i.length; t < n; ++t) {
            const n = i[t],
              r = e.style + '\n' + e.weight + '\n' + n;
            void 0 === vs.get(r) &&
              (vs.set(r, 100, !0),
              o(e.style, e.weight, n) || (vs.set(r, 0, !0), void 0 === s && (s = setInterval(a, 32))));
          }
        };
      })(),
      Es = (function () {
        let t;
        return function (e) {
          let i = Cs[e];
          if (null == i) {
            if (ni) {
              const t = rs(e),
                n = Ts(e, 'Žg');
              i =
                (isNaN(Number(t.lineHeight)) ? 1.2 : Number(t.lineHeight)) *
                (n.actualBoundingBoxAscent + n.actualBoundingBoxDescent);
            } else
              t ||
                ((t = document.createElement('div')),
                (t.innerHTML = 'M'),
                (t.style.minHeight = '0'),
                (t.style.maxHeight = 'none'),
                (t.style.height = 'auto'),
                (t.style.padding = '0'),
                (t.style.border = 'none'),
                (t.style.position = 'absolute'),
                (t.style.display = 'block'),
                (t.style.left = '-99999px')),
                (t.style.font = e),
                document.body.appendChild(t),
                (i = t.offsetHeight),
                document.body.removeChild(t);
            Cs[e] = i;
          }
          return i;
        };
      })();
    function Ts(t, e) {
      return ws || (ws = os(1, 1)), t != xs && ((ws.font = t), (xs = ws.font)), ws.measureText(e);
    }
    function bs(t, e) {
      return Ts(t, e).width;
    }
    function Is(t, e, i) {
      if (e in i) return i[e];
      const n = e.split('\n').reduce((e, i) => Math.max(e, bs(t, i)), 0);
      return (i[e] = n), n;
    }
    const Rs = class extends $n {
      constructor(t) {
        super(t),
          (this.fontChangeListenerKey_ = j(vs, w, t.redrawText.bind(t))),
          (this.element_ = document.createElement('div'));
        const e = this.element_.style;
        (e.position = 'absolute'),
          (e.width = '100%'),
          (e.height = '100%'),
          (e.zIndex = '0'),
          (this.element_.className = ts + ' ol-layers');
        const i = t.getViewport();
        i.insertBefore(this.element_, i.firstChild || null),
          (this.children_ = []),
          (this.renderedVisible_ = !0),
          (this.declutterLayers_ = []);
      }
      dispatchRenderEvent(t, e) {
        const i = this.getMap();
        if (i.hasListener(t)) {
          const n = new Jn(t, void 0, e);
          i.dispatchEvent(n);
        }
      }
      disposeInternal() {
        B(this.fontChangeListenerKey_), this.element_.parentNode.removeChild(this.element_), super.disposeInternal();
      }
      renderFrame(t) {
        if (!t)
          return void (this.renderedVisible_ && ((this.element_.style.display = 'none'), (this.renderedVisible_ = !1)));
        this.calculateMatrices2D(t), this.dispatchRenderEvent(Zn, t);
        const e = t.layerStatesArray.sort(function (t, e) {
            return t.zIndex - e.zIndex;
          }),
          i = t.viewState;
        this.children_.length = 0;
        const n = this.declutterLayers_;
        n.length = 0;
        let s = null;
        for (let r = 0, o = e.length; r < o; ++r) {
          const o = e[r];
          t.layerIndex = r;
          const a = o.layer,
            h = a.getSourceState();
          if (!qn(o, i) || ('ready' != h && 'undefined' != h)) {
            a.unrender();
            continue;
          }
          const l = a.render(t, s);
          l && (l !== s && (this.children_.push(l), (s = l)), 'getDeclutter' in a && n.push(a));
        }
        this.flushDeclutterItems(t),
          (function (t, e) {
            const i = t.childNodes;
            for (let n = 0; ; ++n) {
              const s = i[n],
                r = e[n];
              if (!s && !r) break;
              s !== r && (s ? (r ? t.insertBefore(r, s) : (t.removeChild(s), --n)) : t.appendChild(r));
            }
          })(this.element_, this.children_),
          this.dispatchRenderEvent('postcompose', t),
          this.renderedVisible_ || ((this.element_.style.display = ''), (this.renderedVisible_ = !0)),
          this.scheduleExpireIconCache(t);
      }
      flushDeclutterItems(t) {
        const e = this.declutterLayers_;
        for (let i = e.length - 1; i >= 0; --i) e[i].renderDeclutter(t);
        e.length = 0;
      }
    };
    class Ms extends x {
      constructor(t, e) {
        super(t), (this.layer = e);
      }
    }
    const Ps = 'layers';
    class Ls extends Yn {
      constructor(t) {
        t = t || {};
        const e = Object.assign({}, t);
        delete e.layers;
        let i = t.layers;
        super(e),
          this.on,
          this.once,
          this.un,
          (this.layersListenerKeys_ = []),
          (this.listenerKeys_ = {}),
          this.addChangeListener(Ps, this.handleLayersChanged_),
          i
            ? Array.isArray(i)
              ? (i = new un(i.slice(), { unique: !0 }))
              : We('function' == typeof i.getArray, 'Expected `layers` to be an array or a `Collection`')
            : (i = new un(void 0, { unique: !0 })),
          this.setLayers(i);
      }
      handleLayerChange_() {
        this.changed();
      }
      handleLayersChanged_() {
        this.layersListenerKeys_.forEach(B), (this.layersListenerKeys_.length = 0);
        const t = this.getLayers();
        this.layersListenerKeys_.push(j(t, an, this.handleLayersAdd_, this), j(t, hn, this.handleLayersRemove_, this));
        for (const t in this.listenerKeys_) this.listenerKeys_[t].forEach(B);
        F(this.listenerKeys_);
        const e = t.getArray();
        for (let t = 0, i = e.length; t < i; t++) {
          const i = e[t];
          this.registerLayerListeners_(i), this.dispatchEvent(new Ms('addlayer', i));
        }
        this.changed();
      }
      registerLayerListeners_(t) {
        const e = [j(t, w, this.handleLayerChange_, this), j(t, O, this.handleLayerChange_, this)];
        t instanceof Ls &&
          e.push(
            j(t, 'addlayer', this.handleLayerGroupAdd_, this),
            j(t, 'removelayer', this.handleLayerGroupRemove_, this),
          ),
          (this.listenerKeys_[U(t)] = e);
      }
      handleLayerGroupAdd_(t) {
        this.dispatchEvent(new Ms('addlayer', t.layer));
      }
      handleLayerGroupRemove_(t) {
        this.dispatchEvent(new Ms('removelayer', t.layer));
      }
      handleLayersAdd_(t) {
        const e = t.element;
        this.registerLayerListeners_(e), this.dispatchEvent(new Ms('addlayer', e)), this.changed();
      }
      handleLayersRemove_(t) {
        const e = t.element,
          i = U(e);
        this.listenerKeys_[i].forEach(B),
          delete this.listenerKeys_[i],
          this.dispatchEvent(new Ms('removelayer', e)),
          this.changed();
      }
      getLayers() {
        return this.get(Ps);
      }
      setLayers(t) {
        const e = this.getLayers();
        if (e) {
          const t = e.getArray();
          for (let e = 0, i = t.length; e < i; ++e) this.dispatchEvent(new Ms('removelayer', t[e]));
        }
        this.set(Ps, t);
      }
      getLayersArray(t) {
        return (
          (t = void 0 !== t ? t : []),
          this.getLayers().forEach(function (e) {
            e.getLayersArray(t);
          }),
          t
        );
      }
      getLayerStatesArray(t) {
        const e = void 0 !== t ? t : [],
          i = e.length;
        this.getLayers().forEach(function (t) {
          t.getLayerStatesArray(e);
        });
        const n = this.getLayerState();
        let s = n.zIndex;
        t || void 0 !== n.zIndex || (s = 0);
        for (let t = i, r = e.length; t < r; t++) {
          const i = e[t];
          (i.opacity *= n.opacity),
            (i.visible = i.visible && n.visible),
            (i.maxResolution = Math.min(i.maxResolution, n.maxResolution)),
            (i.minResolution = Math.max(i.minResolution, n.minResolution)),
            (i.minZoom = Math.max(i.minZoom, n.minZoom)),
            (i.maxZoom = Math.min(i.maxZoom, n.maxZoom)),
            void 0 !== n.extent && (void 0 !== i.extent ? (i.extent = Bt(i.extent, n.extent)) : (i.extent = n.extent)),
            void 0 === i.zIndex && (i.zIndex = s);
        }
        return e;
      }
      getSourceState() {
        return 'ready';
      }
    }
    const Fs = Ls,
      ks = class extends x {
        constructor(t, e, i) {
          super(t), (this.map = e), (this.frameState = void 0 !== i ? i : null);
        }
      },
      As = class extends ks {
        constructor(t, e, i, n, s, r) {
          super(t, e, s),
            (this.originalEvent = i),
            (this.pixel_ = null),
            (this.coordinate_ = null),
            (this.dragging = void 0 !== n && n),
            (this.activePointers = r);
        }
        get pixel() {
          return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_;
        }
        set pixel(t) {
          this.pixel_ = t;
        }
        get coordinate() {
          return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_;
        }
        set coordinate(t) {
          this.coordinate_ = t;
        }
        preventDefault() {
          super.preventDefault(), 'preventDefault' in this.originalEvent && this.originalEvent.preventDefault();
        }
        stopPropagation() {
          super.stopPropagation(), 'stopPropagation' in this.originalEvent && this.originalEvent.stopPropagation();
        }
      },
      Os = {
        SINGLECLICK: 'singleclick',
        CLICK: G,
        DBLCLICK: 'dblclick',
        POINTERDRAG: 'pointerdrag',
        POINTERMOVE: 'pointermove',
        POINTERDOWN: 'pointerdown',
        POINTERUP: 'pointerup',
        POINTEROVER: 'pointerover',
        POINTEROUT: 'pointerout',
        POINTERENTER: 'pointerenter',
        POINTERLEAVE: 'pointerleave',
        POINTERCANCEL: 'pointercancel',
      },
      Ds = 'pointerdown',
      Gs = class extends A {
        constructor(t, e) {
          super(t),
            (this.map_ = t),
            this.clickTimeoutId_,
            (this.emulateClicks_ = !1),
            (this.dragging_ = !1),
            (this.dragListenerKeys_ = []),
            (this.moveTolerance_ = void 0 === e ? 1 : e),
            (this.down_ = null);
          const i = this.map_.getViewport();
          (this.activePointers_ = []),
            (this.trackedTouches_ = {}),
            (this.element_ = i),
            (this.pointerdownListenerKey_ = j(i, Ds, this.handlePointerDown_, this)),
            this.originalPointerMoveEvent_,
            (this.relayedListenerKey_ = j(i, 'pointermove', this.relayMoveEvent_, this)),
            (this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this)),
            this.element_.addEventListener(W, this.boundHandleTouchMove_, !!ri && { passive: !1 });
        }
        emulateClick_(t) {
          let e = new As(Os.CLICK, this.map_, t);
          this.dispatchEvent(e),
            void 0 !== this.clickTimeoutId_
              ? (clearTimeout(this.clickTimeoutId_),
                (this.clickTimeoutId_ = void 0),
                (e = new As(Os.DBLCLICK, this.map_, t)),
                this.dispatchEvent(e))
              : (this.clickTimeoutId_ = setTimeout(() => {
                  this.clickTimeoutId_ = void 0;
                  const e = new As(Os.SINGLECLICK, this.map_, t);
                  this.dispatchEvent(e);
                }, 250));
        }
        updateActivePointers_(t) {
          const e = t,
            i = e.pointerId;
          if (e.type == Os.POINTERUP || e.type == Os.POINTERCANCEL) {
            delete this.trackedTouches_[i];
            for (const t in this.trackedTouches_)
              if (this.trackedTouches_[t].target !== e.target) {
                delete this.trackedTouches_[t];
                break;
              }
          } else (e.type != Os.POINTERDOWN && e.type != Os.POINTERMOVE) || (this.trackedTouches_[i] = e);
          this.activePointers_ = Object.values(this.trackedTouches_);
        }
        handlePointerUp_(t) {
          this.updateActivePointers_(t);
          const e = new As(Os.POINTERUP, this.map_, t, void 0, void 0, this.activePointers_);
          this.dispatchEvent(e),
            this.emulateClicks_ &&
              !e.defaultPrevented &&
              !this.dragging_ &&
              this.isMouseActionButton_(t) &&
              this.emulateClick_(this.down_),
            0 === this.activePointers_.length &&
              (this.dragListenerKeys_.forEach(B),
              (this.dragListenerKeys_.length = 0),
              (this.dragging_ = !1),
              (this.down_ = null));
        }
        isMouseActionButton_(t) {
          return 0 === t.button;
        }
        handlePointerDown_(t) {
          (this.emulateClicks_ = 0 === this.activePointers_.length), this.updateActivePointers_(t);
          const e = new As(Os.POINTERDOWN, this.map_, t, void 0, void 0, this.activePointers_);
          if (
            (this.dispatchEvent(e),
            (this.down_ = new PointerEvent(t.type, t)),
            Object.defineProperty(this.down_, 'target', { writable: !1, value: t.target }),
            0 === this.dragListenerKeys_.length)
          ) {
            const t = this.map_.getOwnerDocument();
            this.dragListenerKeys_.push(
              j(t, Os.POINTERMOVE, this.handlePointerMove_, this),
              j(t, Os.POINTERUP, this.handlePointerUp_, this),
              j(this.element_, Os.POINTERCANCEL, this.handlePointerUp_, this),
            ),
              this.element_.getRootNode &&
                this.element_.getRootNode() !== t &&
                this.dragListenerKeys_.push(j(this.element_.getRootNode(), Os.POINTERUP, this.handlePointerUp_, this));
          }
        }
        handlePointerMove_(t) {
          if (this.isMoving_(t)) {
            this.updateActivePointers_(t), (this.dragging_ = !0);
            const e = new As(Os.POINTERDRAG, this.map_, t, this.dragging_, void 0, this.activePointers_);
            this.dispatchEvent(e);
          }
        }
        relayMoveEvent_(t) {
          this.originalPointerMoveEvent_ = t;
          const e = !(!this.down_ || !this.isMoving_(t));
          this.dispatchEvent(new As(Os.POINTERMOVE, this.map_, t, e));
        }
        handleTouchMove_(t) {
          const e = this.originalPointerMoveEvent_;
          (e && !e.defaultPrevented) || ('boolean' == typeof t.cancelable && !0 !== t.cancelable) || t.preventDefault();
        }
        isMoving_(t) {
          return (
            this.dragging_ ||
            Math.abs(t.clientX - this.down_.clientX) > this.moveTolerance_ ||
            Math.abs(t.clientY - this.down_.clientY) > this.moveTolerance_
          );
        }
        disposeInternal() {
          this.relayedListenerKey_ && (B(this.relayedListenerKey_), (this.relayedListenerKey_ = null)),
            this.element_.removeEventListener(W, this.boundHandleTouchMove_),
            this.pointerdownListenerKey_ && (B(this.pointerdownListenerKey_), (this.pointerdownListenerKey_ = null)),
            this.dragListenerKeys_.forEach(B),
            (this.dragListenerKeys_.length = 0),
            (this.element_ = null),
            super.disposeInternal();
        }
      },
      Ns = 'postrender',
      zs = 'loadstart',
      Ws = 'loadend',
      Xs = 'layergroup',
      js = 'size',
      Ys = 'target',
      Bs = 'view',
      Ks = 1 / 0,
      Zs = class {
        constructor(t, e) {
          (this.priorityFunction_ = t),
            (this.keyFunction_ = e),
            (this.elements_ = []),
            (this.priorities_ = []),
            (this.queuedElements_ = {});
        }
        clear() {
          (this.elements_.length = 0), (this.priorities_.length = 0), F(this.queuedElements_);
        }
        dequeue() {
          const t = this.elements_,
            e = this.priorities_,
            i = t[0];
          1 == t.length ? ((t.length = 0), (e.length = 0)) : ((t[0] = t.pop()), (e[0] = e.pop()), this.siftUp_(0));
          const n = this.keyFunction_(i);
          return delete this.queuedElements_[n], i;
        }
        enqueue(t) {
          We(
            !(this.keyFunction_(t) in this.queuedElements_),
            'Tried to enqueue an `element` that was already added to the queue',
          );
          const e = this.priorityFunction_(t);
          return (
            e != Ks &&
            (this.elements_.push(t),
            this.priorities_.push(e),
            (this.queuedElements_[this.keyFunction_(t)] = !0),
            this.siftDown_(0, this.elements_.length - 1),
            !0)
          );
        }
        getCount() {
          return this.elements_.length;
        }
        getLeftChildIndex_(t) {
          return 2 * t + 1;
        }
        getRightChildIndex_(t) {
          return 2 * t + 2;
        }
        getParentIndex_(t) {
          return (t - 1) >> 1;
        }
        heapify_() {
          let t;
          for (t = (this.elements_.length >> 1) - 1; t >= 0; t--) this.siftUp_(t);
        }
        isEmpty() {
          return 0 === this.elements_.length;
        }
        isKeyQueued(t) {
          return t in this.queuedElements_;
        }
        isQueued(t) {
          return this.isKeyQueued(this.keyFunction_(t));
        }
        siftUp_(t) {
          const e = this.elements_,
            i = this.priorities_,
            n = e.length,
            s = e[t],
            r = i[t],
            o = t;
          for (; t < n >> 1; ) {
            const s = this.getLeftChildIndex_(t),
              r = this.getRightChildIndex_(t),
              o = r < n && i[r] < i[s] ? r : s;
            (e[t] = e[o]), (i[t] = i[o]), (t = o);
          }
          (e[t] = s), (i[t] = r), this.siftDown_(o, t);
        }
        siftDown_(t, e) {
          const i = this.elements_,
            n = this.priorities_,
            s = i[e],
            r = n[e];
          for (; e > t; ) {
            const t = this.getParentIndex_(e);
            if (!(n[t] > r)) break;
            (i[e] = i[t]), (n[e] = n[t]), (e = t);
          }
          (i[e] = s), (n[e] = r);
        }
        reprioritize() {
          const t = this.priorityFunction_,
            e = this.elements_,
            i = this.priorities_;
          let n = 0;
          const s = e.length;
          let r, o, a;
          for (o = 0; o < s; ++o)
            (r = e[o]),
              (a = t(r)),
              a == Ks ? delete this.queuedElements_[this.keyFunction_(r)] : ((i[n] = a), (e[n++] = r));
          (e.length = n), (i.length = n), this.heapify_();
        }
      },
      Vs = class extends Zs {
        constructor(t, e) {
          super(
            function (e) {
              return t.apply(null, e);
            },
            function (t) {
              return t[0].getKey();
            },
          ),
            (this.boundHandleTileChange_ = this.handleTileChange.bind(this)),
            (this.tileChangeCallback_ = e),
            (this.tilesLoading_ = 0),
            (this.tilesLoadingKeys_ = {});
        }
        enqueue(t) {
          const e = super.enqueue(t);
          return e && t[0].addEventListener(O, this.boundHandleTileChange_), e;
        }
        getTilesLoading() {
          return this.tilesLoading_;
        }
        handleTileChange(t) {
          const e = t.target,
            i = e.getState();
          if (2 === i || 3 === i || 4 === i) {
            3 !== i && e.removeEventListener(O, this.boundHandleTileChange_);
            const t = e.getKey();
            t in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[t], --this.tilesLoading_),
              this.tileChangeCallback_();
          }
        }
        loadMoreTiles(t, e) {
          let i,
            n,
            s,
            r = 0;
          for (; this.tilesLoading_ < t && r < e && this.getCount() > 0; )
            (n = this.dequeue()[0]),
              (s = n.getKey()),
              (i = n.getState()),
              0 !== i ||
                s in this.tilesLoadingKeys_ ||
                ((this.tilesLoadingKeys_[s] = !0), ++this.tilesLoading_, ++r, n.load());
        }
      },
      qs = class extends $ {
        constructor(t) {
          super();
          const e = t.element;
          !e || t.target || e.style.pointerEvents || (e.style.pointerEvents = 'auto'),
            (this.element = e || null),
            (this.target_ = null),
            (this.map_ = null),
            (this.listenerKeys = []),
            t.render && (this.render = t.render),
            t.target && this.setTarget(t.target);
        }
        disposeInternal() {
          ls(this.element), super.disposeInternal();
        }
        getMap() {
          return this.map_;
        }
        setMap(t) {
          this.map_ && ls(this.element);
          for (let t = 0, e = this.listenerKeys.length; t < e; ++t) B(this.listenerKeys[t]);
          (this.listenerKeys.length = 0),
            (this.map_ = t),
            t &&
              ((this.target_ ? this.target_ : t.getOverlayContainerStopEvent()).appendChild(this.element),
              this.render !== P && this.listenerKeys.push(j(t, Ns, this.render, this)),
              t.render());
        }
        render(t) {}
        setTarget(t) {
          this.target_ = 'string' == typeof t ? document.getElementById(t) : t;
        }
      },
      Us = class extends qs {
        constructor(t) {
          (t = t || {}),
            super({ element: document.createElement('div'), render: t.render, target: t.target }),
            (this.ulElement_ = document.createElement('ul')),
            (this.collapsed_ = void 0 === t.collapsed || t.collapsed),
            (this.userCollapsed_ = this.collapsed_),
            (this.overrideCollapsible_ = void 0 !== t.collapsible),
            (this.collapsible_ = void 0 === t.collapsible || t.collapsible),
            this.collapsible_ || (this.collapsed_ = !1);
          const e = void 0 !== t.className ? t.className : 'ol-attribution',
            i = void 0 !== t.tipLabel ? t.tipLabel : 'Attributions',
            n = void 0 !== t.expandClassName ? t.expandClassName : e + '-expand',
            s = void 0 !== t.collapseLabel ? t.collapseLabel : '›',
            r = void 0 !== t.collapseClassName ? t.collapseClassName : e + '-collapse';
          'string' == typeof s
            ? ((this.collapseLabel_ = document.createElement('span')),
              (this.collapseLabel_.textContent = s),
              (this.collapseLabel_.className = r))
            : (this.collapseLabel_ = s);
          const o = void 0 !== t.label ? t.label : 'i';
          'string' == typeof o
            ? ((this.label_ = document.createElement('span')),
              (this.label_.textContent = o),
              (this.label_.className = n))
            : (this.label_ = o);
          const a = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
          (this.toggleButton_ = document.createElement('button')),
            this.toggleButton_.setAttribute('type', 'button'),
            this.toggleButton_.setAttribute('aria-expanded', String(!this.collapsed_)),
            (this.toggleButton_.title = i),
            this.toggleButton_.appendChild(a),
            this.toggleButton_.addEventListener(G, this.handleClick_.bind(this), !1);
          const h =
              e +
              ' ' +
              ts +
              ' ' +
              es +
              (this.collapsed_ && this.collapsible_ ? ' ' + is : '') +
              (this.collapsible_ ? '' : ' ol-uncollapsible'),
            l = this.element;
          (l.className = h),
            l.appendChild(this.toggleButton_),
            l.appendChild(this.ulElement_),
            (this.renderedAttributions_ = []),
            (this.renderedVisible_ = !0);
        }
        collectSourceAttributions_(t) {
          const e = Array.from(
              new Set(
                this.getMap()
                  .getAllLayers()
                  .flatMap((e) => e.getAttributions(t)),
              ),
            ),
            i = !this.getMap()
              .getAllLayers()
              .some((t) => t.getSource() && !1 === t.getSource().getAttributionsCollapsible());
          return this.overrideCollapsible_ || this.setCollapsible(i), e;
        }
        updateElement_(t) {
          if (!t)
            return void (
              this.renderedVisible_ && ((this.element.style.display = 'none'), (this.renderedVisible_ = !1))
            );
          const e = this.collectSourceAttributions_(t),
            i = e.length > 0;
          if (
            (this.renderedVisible_ != i &&
              ((this.element.style.display = i ? '' : 'none'), (this.renderedVisible_ = i)),
            !I(e, this.renderedAttributions_))
          ) {
            !(function (t) {
              for (; t.lastChild; ) t.removeChild(t.lastChild);
            })(this.ulElement_);
            for (let t = 0, i = e.length; t < i; ++t) {
              const i = document.createElement('li');
              (i.innerHTML = e[t]), this.ulElement_.appendChild(i);
            }
            this.renderedAttributions_ = e;
          }
        }
        handleClick_(t) {
          t.preventDefault(), this.handleToggle_(), (this.userCollapsed_ = this.collapsed_);
        }
        handleToggle_() {
          this.element.classList.toggle(is),
            this.collapsed_ ? hs(this.collapseLabel_, this.label_) : hs(this.label_, this.collapseLabel_),
            (this.collapsed_ = !this.collapsed_),
            this.toggleButton_.setAttribute('aria-expanded', String(!this.collapsed_));
        }
        getCollapsible() {
          return this.collapsible_;
        }
        setCollapsible(t) {
          this.collapsible_ !== t &&
            ((this.collapsible_ = t),
            this.element.classList.toggle('ol-uncollapsible'),
            this.userCollapsed_ && this.handleToggle_());
        }
        setCollapsed(t) {
          (this.userCollapsed_ = t), this.collapsible_ && this.collapsed_ !== t && this.handleToggle_();
        }
        getCollapsed() {
          return this.collapsed_;
        }
        render(t) {
          this.updateElement_(t.frameState);
        }
      },
      Hs = class extends qs {
        constructor(t) {
          (t = t || {}), super({ element: document.createElement('div'), render: t.render, target: t.target });
          const e = void 0 !== t.className ? t.className : 'ol-rotate',
            i = void 0 !== t.label ? t.label : '⇧',
            n = void 0 !== t.compassClassName ? t.compassClassName : 'ol-compass';
          (this.label_ = null),
            'string' == typeof i
              ? ((this.label_ = document.createElement('span')),
                (this.label_.className = n),
                (this.label_.textContent = i))
              : ((this.label_ = i), this.label_.classList.add(n));
          const s = t.tipLabel ? t.tipLabel : 'Reset rotation',
            r = document.createElement('button');
          (r.className = e + '-reset'),
            r.setAttribute('type', 'button'),
            (r.title = s),
            r.appendChild(this.label_),
            r.addEventListener(G, this.handleClick_.bind(this), !1);
          const o = e + ' ' + ts + ' ' + es,
            a = this.element;
          (a.className = o),
            a.appendChild(r),
            (this.callResetNorth_ = t.resetNorth ? t.resetNorth : void 0),
            (this.duration_ = void 0 !== t.duration ? t.duration : 250),
            (this.autoHide_ = void 0 === t.autoHide || t.autoHide),
            (this.rotation_ = void 0),
            this.autoHide_ && this.element.classList.add(Qn);
        }
        handleClick_(t) {
          t.preventDefault(), void 0 !== this.callResetNorth_ ? this.callResetNorth_() : this.resetNorth_();
        }
        resetNorth_() {
          const t = this.getMap().getView();
          if (!t) return;
          const e = t.getRotation();
          void 0 !== e &&
            (this.duration_ > 0 && e % (2 * Math.PI) != 0
              ? t.animate({ rotation: 0, duration: this.duration_, easing: Ue })
              : t.setRotation(0));
        }
        render(t) {
          const e = t.frameState;
          if (!e) return;
          const i = e.viewState.rotation;
          if (i != this.rotation_) {
            const t = 'rotate(' + i + 'rad)';
            if (this.autoHide_) {
              const t = this.element.classList.contains(Qn);
              t || 0 !== i ? t && 0 !== i && this.element.classList.remove(Qn) : this.element.classList.add(Qn);
            }
            this.label_.style.transform = t;
          }
          this.rotation_ = i;
        }
      },
      $s = class extends qs {
        constructor(t) {
          (t = t || {}), super({ element: document.createElement('div'), target: t.target });
          const e = void 0 !== t.className ? t.className : 'ol-zoom',
            i = void 0 !== t.delta ? t.delta : 1,
            n = void 0 !== t.zoomInClassName ? t.zoomInClassName : e + '-in',
            s = void 0 !== t.zoomOutClassName ? t.zoomOutClassName : e + '-out',
            r = void 0 !== t.zoomInLabel ? t.zoomInLabel : '+',
            o = void 0 !== t.zoomOutLabel ? t.zoomOutLabel : '–',
            a = void 0 !== t.zoomInTipLabel ? t.zoomInTipLabel : 'Zoom in',
            h = void 0 !== t.zoomOutTipLabel ? t.zoomOutTipLabel : 'Zoom out',
            l = document.createElement('button');
          (l.className = n),
            l.setAttribute('type', 'button'),
            (l.title = a),
            l.appendChild('string' == typeof r ? document.createTextNode(r) : r),
            l.addEventListener(G, this.handleClick_.bind(this, i), !1);
          const c = document.createElement('button');
          (c.className = s),
            c.setAttribute('type', 'button'),
            (c.title = h),
            c.appendChild('string' == typeof o ? document.createTextNode(o) : o),
            c.addEventListener(G, this.handleClick_.bind(this, -i), !1);
          const u = e + ' ' + ts + ' ' + es,
            d = this.element;
          (d.className = u),
            d.appendChild(l),
            d.appendChild(c),
            (this.duration_ = void 0 !== t.duration ? t.duration : 250);
        }
        handleClick_(t, e) {
          e.preventDefault(), this.zoomByDelta_(t);
        }
        zoomByDelta_(t) {
          const e = this.getMap().getView();
          if (!e) return;
          const i = e.getZoom();
          if (void 0 !== i) {
            const n = e.getConstrainedZoom(i + t);
            this.duration_ > 0
              ? (e.getAnimating() && e.cancelAnimations(), e.animate({ zoom: n, duration: this.duration_, easing: Ue }))
              : e.setZoom(n);
          }
        }
      },
      Js = 'active';
    function Qs(t, e, i, n) {
      const s = t.getZoom();
      if (void 0 === s) return;
      const r = t.getConstrainedZoom(s + e),
        o = t.getResolutionForZoom(r);
      t.getAnimating() && t.cancelAnimations(),
        t.animate({ resolution: o, anchor: i, duration: void 0 !== n ? n : 250, easing: Ue });
    }
    const tr = class extends $ {
        constructor(t) {
          super(),
            this.on,
            this.once,
            this.un,
            t && t.handleEvent && (this.handleEvent = t.handleEvent),
            (this.map_ = null),
            this.setActive(!0);
        }
        getActive() {
          return this.get(Js);
        }
        getMap() {
          return this.map_;
        }
        handleEvent(t) {
          return !0;
        }
        setActive(t) {
          this.set(Js, t);
        }
        setMap(t) {
          this.map_ = t;
        }
      },
      er = class extends tr {
        constructor(t) {
          super(),
            (t = t || {}),
            (this.delta_ = t.delta ? t.delta : 1),
            (this.duration_ = void 0 !== t.duration ? t.duration : 250);
        }
        handleEvent(t) {
          let e = !1;
          if (t.type == Os.DBLCLICK) {
            const i = t.originalEvent,
              n = t.map,
              s = t.coordinate,
              r = i.shiftKey ? -this.delta_ : this.delta_;
            Qs(n.getView(), r, s, this.duration_), i.preventDefault(), (e = !0);
          }
          return !e;
        }
      };
    function ir(t) {
      const e = t.length;
      let i = 0,
        n = 0;
      for (let s = 0; s < e; s++) (i += t[s].clientX), (n += t[s].clientY);
      return { clientX: i / e, clientY: n / e };
    }
    const nr = class extends tr {
      constructor(t) {
        super((t = t || {})),
          t.handleDownEvent && (this.handleDownEvent = t.handleDownEvent),
          t.handleDragEvent && (this.handleDragEvent = t.handleDragEvent),
          t.handleMoveEvent && (this.handleMoveEvent = t.handleMoveEvent),
          t.handleUpEvent && (this.handleUpEvent = t.handleUpEvent),
          t.stopDown && (this.stopDown = t.stopDown),
          (this.handlingDownUpSequence = !1),
          (this.targetPointers = []);
      }
      getPointerCount() {
        return this.targetPointers.length;
      }
      handleDownEvent(t) {
        return !1;
      }
      handleDragEvent(t) {}
      handleEvent(t) {
        if (!t.originalEvent) return !0;
        let e = !1;
        if ((this.updateTrackedPointers_(t), this.handlingDownUpSequence)) {
          if (t.type == Os.POINTERDRAG) this.handleDragEvent(t), t.originalEvent.preventDefault();
          else if (t.type == Os.POINTERUP) {
            const e = this.handleUpEvent(t);
            this.handlingDownUpSequence = e && this.targetPointers.length > 0;
          }
        } else if (t.type == Os.POINTERDOWN) {
          const i = this.handleDownEvent(t);
          (this.handlingDownUpSequence = i), (e = this.stopDown(i));
        } else t.type == Os.POINTERMOVE && this.handleMoveEvent(t);
        return !e;
      }
      handleMoveEvent(t) {}
      handleUpEvent(t) {
        return !1;
      }
      stopDown(t) {
        return t;
      }
      updateTrackedPointers_(t) {
        t.activePointers && (this.targetPointers = t.activePointers);
      }
    };
    function sr(t) {
      const e = arguments;
      return function (t) {
        let i = !0;
        for (let n = 0, s = e.length; n < s && ((i = i && e[n](t)), i); ++n);
        return i;
      };
    }
    const rr = function (t) {
        const e = t.originalEvent;
        return e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
      },
      or = function (t) {
        return (
          !t.map.getTargetElement().hasAttribute('tabindex') ||
          (function (t) {
            const e = t.map.getTargetElement(),
              i = t.map.getOwnerDocument().activeElement;
            return e.contains(i);
          })(t)
        );
      },
      ar = R,
      hr = function (t) {
        const e = t.originalEvent;
        return 0 == e.button && !(ti && ei && e.ctrlKey);
      },
      lr = M,
      cr = function (t) {
        const e = t.originalEvent;
        return !e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey;
      },
      ur = function (t) {
        const e = t.originalEvent;
        return !e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
      },
      dr = function (t) {
        const e = t.originalEvent,
          i = e.target.tagName;
        return 'INPUT' !== i && 'SELECT' !== i && 'TEXTAREA' !== i && !e.target.isContentEditable;
      },
      gr = function (t) {
        const e = t.originalEvent;
        return We(void 0 !== e, 'mapBrowserEvent must originate from a pointer event'), 'mouse' == e.pointerType;
      },
      fr = function (t) {
        const e = t.originalEvent;
        return We(void 0 !== e, 'mapBrowserEvent must originate from a pointer event'), e.isPrimary && 0 === e.button;
      },
      _r = class extends nr {
        constructor(t) {
          super({ stopDown: M }),
            (t = t || {}),
            (this.kinetic_ = t.kinetic),
            (this.lastCentroid = null),
            this.lastPointersCount_,
            (this.panning_ = !1);
          const e = t.condition ? t.condition : sr(cr, fr);
          (this.condition_ = t.onFocusOnly ? sr(or, e) : e), (this.noKinetic_ = !1);
        }
        handleDragEvent(t) {
          const e = t.map;
          this.panning_ || ((this.panning_ = !0), e.getView().beginInteraction());
          const i = this.targetPointers,
            n = e.getEventPixel(ir(i));
          if (i.length == this.lastPointersCount_) {
            if ((this.kinetic_ && this.kinetic_.update(n[0], n[1]), this.lastCentroid)) {
              const e = [this.lastCentroid[0] - n[0], n[1] - this.lastCentroid[1]],
                i = t.map.getView();
              (s = e),
                (r = i.getResolution()),
                (s[0] *= r),
                (s[1] *= r),
                Jt(e, i.getRotation()),
                i.adjustCenterInternal(e);
            }
          } else this.kinetic_ && this.kinetic_.begin();
          var s, r;
          (this.lastCentroid = n), (this.lastPointersCount_ = i.length), t.originalEvent.preventDefault();
        }
        handleUpEvent(t) {
          const e = t.map,
            i = e.getView();
          if (0 === this.targetPointers.length) {
            if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
              const t = this.kinetic_.getDistance(),
                n = this.kinetic_.getAngle(),
                s = i.getCenterInternal(),
                r = e.getPixelFromCoordinateInternal(s),
                o = e.getCoordinateFromPixelInternal([r[0] - t * Math.cos(n), r[1] - t * Math.sin(n)]);
              i.animateInternal({ center: i.getConstrainedCenter(o), duration: 500, easing: Ue });
            }
            return this.panning_ && ((this.panning_ = !1), i.endInteraction()), !1;
          }
          return this.kinetic_ && this.kinetic_.begin(), (this.lastCentroid = null), !0;
        }
        handleDownEvent(t) {
          if (this.targetPointers.length > 0 && this.condition_(t)) {
            const e = t.map.getView();
            return (
              (this.lastCentroid = null),
              e.getAnimating() && e.cancelAnimations(),
              this.kinetic_ && this.kinetic_.begin(),
              (this.noKinetic_ = this.targetPointers.length > 1),
              !0
            );
          }
          return !1;
        }
      },
      pr = class extends nr {
        constructor(t) {
          (t = t || {}),
            super({ stopDown: M }),
            (this.condition_ = t.condition ? t.condition : rr),
            (this.lastAngle_ = void 0),
            (this.duration_ = void 0 !== t.duration ? t.duration : 250);
        }
        handleDragEvent(t) {
          if (!gr(t)) return;
          const e = t.map,
            i = e.getView();
          if (i.getConstraints().rotation === Ze) return;
          const n = e.getSize(),
            s = t.pixel,
            r = Math.atan2(n[1] / 2 - s[1], s[0] - n[0] / 2);
          if (void 0 !== this.lastAngle_) {
            const t = r - this.lastAngle_;
            i.adjustRotationInternal(-t);
          }
          this.lastAngle_ = r;
        }
        handleUpEvent(t) {
          return !gr(t) || (t.map.getView().endInteraction(this.duration_), !1);
        }
        handleDownEvent(t) {
          return (
            !!gr(t) &&
            !(!hr(t) || !this.condition_(t)) &&
            (t.map.getView().beginInteraction(), (this.lastAngle_ = void 0), !0)
          );
        }
      },
      mr = class extends C {
        constructor(t) {
          super(),
            (this.geometry_ = null),
            (this.element_ = document.createElement('div')),
            (this.element_.style.position = 'absolute'),
            (this.element_.style.pointerEvents = 'auto'),
            (this.element_.className = 'ol-box ' + t),
            (this.map_ = null),
            (this.startPixel_ = null),
            (this.endPixel_ = null);
        }
        disposeInternal() {
          this.setMap(null);
        }
        render_() {
          const t = this.startPixel_,
            e = this.endPixel_,
            i = 'px',
            n = this.element_.style;
          (n.left = Math.min(t[0], e[0]) + i),
            (n.top = Math.min(t[1], e[1]) + i),
            (n.width = Math.abs(e[0] - t[0]) + i),
            (n.height = Math.abs(e[1] - t[1]) + i);
        }
        setMap(t) {
          if (this.map_) {
            this.map_.getOverlayContainer().removeChild(this.element_);
            const t = this.element_.style;
            (t.left = 'inherit'), (t.top = 'inherit'), (t.width = 'inherit'), (t.height = 'inherit');
          }
          (this.map_ = t), this.map_ && this.map_.getOverlayContainer().appendChild(this.element_);
        }
        setPixels(t, e) {
          (this.startPixel_ = t), (this.endPixel_ = e), this.createOrUpdateGeometry(), this.render_();
        }
        createOrUpdateGeometry() {
          const t = this.startPixel_,
            e = this.endPixel_,
            i = [t, [t[0], e[1]], e, [e[0], t[1]]].map(this.map_.getCoordinateFromPixelInternal, this.map_);
          (i[4] = i[0].slice()), this.geometry_ ? this.geometry_.setCoordinates([i]) : (this.geometry_ = new tn([i]));
        }
        getGeometry() {
          return this.geometry_;
        }
      };
    class yr extends x {
      constructor(t, e, i) {
        super(t), (this.coordinate = e), (this.mapBrowserEvent = i);
      }
    }
    const vr = class extends nr {
        constructor(t) {
          super(),
            this.on,
            this.once,
            this.un,
            (t = t || {}),
            (this.box_ = new mr(t.className || 'ol-dragbox')),
            (this.minArea_ = void 0 !== t.minArea ? t.minArea : 64),
            t.onBoxEnd && (this.onBoxEnd = t.onBoxEnd),
            (this.startPixel_ = null),
            (this.condition_ = t.condition ? t.condition : hr),
            (this.boxEndCondition_ = t.boxEndCondition ? t.boxEndCondition : this.defaultBoxEndCondition);
        }
        defaultBoxEndCondition(t, e, i) {
          const n = i[0] - e[0],
            s = i[1] - e[1];
          return n * n + s * s >= this.minArea_;
        }
        getGeometry() {
          return this.box_.getGeometry();
        }
        handleDragEvent(t) {
          this.box_.setPixels(this.startPixel_, t.pixel), this.dispatchEvent(new yr('boxdrag', t.coordinate, t));
        }
        handleUpEvent(t) {
          this.box_.setMap(null);
          const e = this.boxEndCondition_(t, this.startPixel_, t.pixel);
          return e && this.onBoxEnd(t), this.dispatchEvent(new yr(e ? 'boxend' : 'boxcancel', t.coordinate, t)), !1;
        }
        handleDownEvent(t) {
          return (
            !!this.condition_(t) &&
            ((this.startPixel_ = t.pixel),
            this.box_.setMap(t.map),
            this.box_.setPixels(this.startPixel_, this.startPixel_),
            this.dispatchEvent(new yr('boxstart', t.coordinate, t)),
            !0)
          );
        }
        onBoxEnd(t) {}
      },
      xr = class extends vr {
        constructor(t) {
          super({
            condition: (t = t || {}).condition ? t.condition : ur,
            className: t.className || 'ol-dragzoom',
            minArea: t.minArea,
          }),
            (this.duration_ = void 0 !== t.duration ? t.duration : 200),
            (this.out_ = void 0 !== t.out && t.out);
        }
        onBoxEnd(t) {
          const e = this.getMap().getView();
          let i = this.getGeometry();
          if (this.out_) {
            const t = e.rotatedExtentForGeometry(i),
              n = e.getResolutionForExtentInternal(t),
              s = e.getResolution() / n;
            (i = i.clone()), i.scale(s * s);
          }
          e.fitInternal(i, { duration: this.duration_, easing: Ue });
        }
      },
      wr = 'ArrowLeft',
      Cr = 'ArrowRight',
      Sr = 'ArrowDown',
      Er = class extends tr {
        constructor(t) {
          super(),
            (t = t || {}),
            (this.defaultCondition_ = function (t) {
              return cr(t) && dr(t);
            }),
            (this.condition_ = void 0 !== t.condition ? t.condition : this.defaultCondition_),
            (this.duration_ = void 0 !== t.duration ? t.duration : 100),
            (this.pixelDelta_ = void 0 !== t.pixelDelta ? t.pixelDelta : 128);
        }
        handleEvent(t) {
          let e = !1;
          if (t.type == N) {
            const i = t.originalEvent,
              n = i.key;
            if (this.condition_(t) && (n == Sr || n == wr || n == Cr || 'ArrowUp' == n)) {
              const s = t.map.getView(),
                r = s.getResolution() * this.pixelDelta_;
              let o = 0,
                a = 0;
              n == Sr ? (a = -r) : n == wr ? (o = -r) : n == Cr ? (o = r) : (a = r);
              const h = [o, a];
              Jt(h, s.getRotation()),
                (function (t, e, i) {
                  const n = t.getCenterInternal();
                  if (n) {
                    const s = [n[0] + e[0], n[1] + e[1]];
                    t.animateInternal({
                      duration: void 0 !== i ? i : 250,
                      easing: $e,
                      center: t.getConstrainedCenter(s),
                    });
                  }
                })(s, h, this.duration_),
                i.preventDefault(),
                (e = !0);
            }
          }
          return !e;
        }
      },
      Tr = class extends tr {
        constructor(t) {
          super(),
            (t = t || {}),
            (this.condition_ = t.condition
              ? t.condition
              : function (t) {
                  return (
                    !(function (t) {
                      const e = t.originalEvent;
                      return ei ? e.metaKey : e.ctrlKey;
                    })(t) && dr(t)
                  );
                }),
            (this.delta_ = t.delta ? t.delta : 1),
            (this.duration_ = void 0 !== t.duration ? t.duration : 100);
        }
        handleEvent(t) {
          let e = !1;
          if (t.type == N || t.type == z) {
            const i = t.originalEvent,
              n = i.key;
            if (this.condition_(t) && ('+' === n || '-' === n)) {
              const s = t.map,
                r = '+' === n ? this.delta_ : -this.delta_;
              Qs(s.getView(), r, void 0, this.duration_), i.preventDefault(), (e = !0);
            }
          }
          return !e;
        }
      },
      br = class {
        constructor(t, e, i) {
          (this.decay_ = t),
            (this.minVelocity_ = e),
            (this.delay_ = i),
            (this.points_ = []),
            (this.angle_ = 0),
            (this.initialVelocity_ = 0);
        }
        begin() {
          (this.points_.length = 0), (this.angle_ = 0), (this.initialVelocity_ = 0);
        }
        update(t, e) {
          this.points_.push(t, e, Date.now());
        }
        end() {
          if (this.points_.length < 6) return !1;
          const t = Date.now() - this.delay_,
            e = this.points_.length - 3;
          if (this.points_[e + 2] < t) return !1;
          let i = e - 3;
          for (; i > 0 && this.points_[i + 2] > t; ) i -= 3;
          const n = this.points_[e + 2] - this.points_[i + 2];
          if (n < 1e3 / 60) return !1;
          const s = this.points_[e] - this.points_[i],
            r = this.points_[e + 1] - this.points_[i + 1];
          return (
            (this.angle_ = Math.atan2(r, s)),
            (this.initialVelocity_ = Math.sqrt(s * s + r * r) / n),
            this.initialVelocity_ > this.minVelocity_
          );
        }
        getDistance() {
          return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
        }
        getAngle() {
          return this.angle_;
        }
      },
      Ir = class extends tr {
        constructor(t) {
          super((t = t || {})),
            (this.totalDelta_ = 0),
            (this.lastDelta_ = 0),
            (this.maxDelta_ = void 0 !== t.maxDelta ? t.maxDelta : 1),
            (this.duration_ = void 0 !== t.duration ? t.duration : 250),
            (this.timeout_ = void 0 !== t.timeout ? t.timeout : 80),
            (this.useAnchor_ = void 0 === t.useAnchor || t.useAnchor),
            (this.constrainResolution_ = void 0 !== t.constrainResolution && t.constrainResolution);
          const e = t.condition ? t.condition : ar;
          (this.condition_ = t.onFocusOnly ? sr(or, e) : e),
            (this.lastAnchor_ = null),
            (this.startTime_ = void 0),
            this.timeoutId_,
            (this.mode_ = void 0),
            (this.trackpadEventGap_ = 400),
            this.trackpadTimeoutId_,
            (this.deltaPerZoom_ = 300);
        }
        endInteraction_() {
          this.trackpadTimeoutId_ = void 0;
          const t = this.getMap();
          t &&
            t.getView().endInteraction(void 0, this.lastDelta_ ? (this.lastDelta_ > 0 ? 1 : -1) : 0, this.lastAnchor_);
        }
        handleEvent(t) {
          if (!this.condition_(t)) return !0;
          if (t.type !== X) return !0;
          const e = t.map,
            i = t.originalEvent;
          let n;
          if (
            (i.preventDefault(),
            this.useAnchor_ && (this.lastAnchor_ = t.coordinate),
            t.type == X &&
              ((n = i.deltaY),
              Qe && i.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (n /= ii),
              i.deltaMode === WheelEvent.DOM_DELTA_LINE && (n *= 40)),
            0 === n)
          )
            return !1;
          this.lastDelta_ = n;
          const s = Date.now();
          void 0 === this.startTime_ && (this.startTime_ = s),
            (!this.mode_ || s - this.startTime_ > this.trackpadEventGap_) &&
              (this.mode_ = Math.abs(n) < 4 ? 'trackpad' : 'wheel');
          const r = e.getView();
          if ('trackpad' === this.mode_ && !r.getConstrainResolution() && !this.constrainResolution_)
            return (
              this.trackpadTimeoutId_
                ? clearTimeout(this.trackpadTimeoutId_)
                : (r.getAnimating() && r.cancelAnimations(), r.beginInteraction()),
              (this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_)),
              r.adjustZoom(-n / this.deltaPerZoom_, this.lastAnchor_),
              (this.startTime_ = s),
              !1
            );
          this.totalDelta_ += n;
          const o = Math.max(this.timeout_ - (s - this.startTime_), 0);
          return (
            clearTimeout(this.timeoutId_), (this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, e), o)), !1
          );
        }
        handleWheelZoom_(t) {
          const e = t.getView();
          e.getAnimating() && e.cancelAnimations();
          let i =
            -ie(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) /
            this.deltaPerZoom_;
          (e.getConstrainResolution() || this.constrainResolution_) && (i = i ? (i > 0 ? 1 : -1) : 0),
            Qs(e, i, this.lastAnchor_, this.duration_),
            (this.mode_ = void 0),
            (this.totalDelta_ = 0),
            (this.lastAnchor_ = null),
            (this.startTime_ = void 0),
            (this.timeoutId_ = void 0);
        }
        setMouseAnchor(t) {
          (this.useAnchor_ = t), t || (this.lastAnchor_ = null);
        }
      },
      Rr = class extends nr {
        constructor(t) {
          const e = (t = t || {});
          e.stopDown || (e.stopDown = M),
            super(e),
            (this.anchor_ = null),
            (this.lastAngle_ = void 0),
            (this.rotating_ = !1),
            (this.rotationDelta_ = 0),
            (this.threshold_ = void 0 !== t.threshold ? t.threshold : 0.3),
            (this.duration_ = void 0 !== t.duration ? t.duration : 250);
        }
        handleDragEvent(t) {
          let e = 0;
          const i = this.targetPointers[0],
            n = this.targetPointers[1],
            s = Math.atan2(n.clientY - i.clientY, n.clientX - i.clientX);
          if (void 0 !== this.lastAngle_) {
            const t = s - this.lastAngle_;
            (this.rotationDelta_ += t),
              !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = !0),
              (e = t);
          }
          this.lastAngle_ = s;
          const r = t.map,
            o = r.getView();
          o.getConstraints().rotation !== Ze &&
            ((this.anchor_ = r.getCoordinateFromPixelInternal(r.getEventPixel(ir(this.targetPointers)))),
            this.rotating_ && (r.render(), o.adjustRotationInternal(e, this.anchor_)));
        }
        handleUpEvent(t) {
          return !(this.targetPointers.length < 2) || (t.map.getView().endInteraction(this.duration_), !1);
        }
        handleDownEvent(t) {
          if (this.targetPointers.length >= 2) {
            const e = t.map;
            return (
              (this.anchor_ = null),
              (this.lastAngle_ = void 0),
              (this.rotating_ = !1),
              (this.rotationDelta_ = 0),
              this.handlingDownUpSequence || e.getView().beginInteraction(),
              !0
            );
          }
          return !1;
        }
      },
      Mr = class extends nr {
        constructor(t) {
          const e = (t = t || {});
          e.stopDown || (e.stopDown = M),
            super(e),
            (this.anchor_ = null),
            (this.duration_ = void 0 !== t.duration ? t.duration : 400),
            (this.lastDistance_ = void 0),
            (this.lastScaleDelta_ = 1);
        }
        handleDragEvent(t) {
          let e = 1;
          const i = this.targetPointers[0],
            n = this.targetPointers[1],
            s = i.clientX - n.clientX,
            r = i.clientY - n.clientY,
            o = Math.sqrt(s * s + r * r);
          void 0 !== this.lastDistance_ && (e = this.lastDistance_ / o), (this.lastDistance_ = o);
          const a = t.map,
            h = a.getView();
          1 != e && (this.lastScaleDelta_ = e),
            (this.anchor_ = a.getCoordinateFromPixelInternal(a.getEventPixel(ir(this.targetPointers)))),
            a.render(),
            h.adjustResolutionInternal(e, this.anchor_);
        }
        handleUpEvent(t) {
          if (this.targetPointers.length < 2) {
            const e = t.map.getView(),
              i = this.lastScaleDelta_ > 1 ? 1 : -1;
            return e.endInteraction(this.duration_, i), !1;
          }
          return !0;
        }
        handleDownEvent(t) {
          if (this.targetPointers.length >= 2) {
            const e = t.map;
            return (
              (this.anchor_ = null),
              (this.lastDistance_ = void 0),
              (this.lastScaleDelta_ = 1),
              this.handlingDownUpSequence || e.getView().beginInteraction(),
              !0
            );
          }
          return !1;
        }
      };
    function Pr(t) {
      return t[0] > 0 && t[1] > 0;
    }
    function Lr(t, e) {
      return Array.isArray(t) ? t : (void 0 === e ? (e = [t, t]) : ((e[0] = t), (e[1] = t)), e);
    }
    function Fr(t) {
      t instanceof Un ? t.setMapInternal(null) : t instanceof Fs && t.getLayers().forEach(Fr);
    }
    function kr(t, e) {
      if (t instanceof Un) t.setMapInternal(e);
      else if (t instanceof Fs) {
        const i = t.getLayers().getArray();
        for (let t = 0, n = i.length; t < n; ++t) kr(i[t], e);
      }
    }
    class Ar extends $ {
      constructor(t) {
        if (
          (super(),
          this.on,
          this.once,
          this.un,
          (this.id_ = void 0),
          (this.geometryName_ = 'geometry'),
          (this.style_ = null),
          (this.styleFunction_ = void 0),
          (this.geometryChangeKey_ = null),
          this.addChangeListener(this.geometryName_, this.handleGeometryChanged_),
          t)
        )
          if ('function' == typeof t.getSimplifiedGeometry) {
            const e = t;
            this.setGeometry(e);
          } else {
            const e = t;
            this.setProperties(e);
          }
      }
      clone() {
        const t = new Ar(this.hasProperties() ? this.getProperties() : null);
        t.setGeometryName(this.getGeometryName());
        const e = this.getGeometry();
        e && t.setGeometry(e.clone());
        const i = this.getStyle();
        return i && t.setStyle(i), t;
      }
      getGeometry() {
        return this.get(this.geometryName_);
      }
      getId() {
        return this.id_;
      }
      getGeometryName() {
        return this.geometryName_;
      }
      getStyle() {
        return this.style_;
      }
      getStyleFunction() {
        return this.styleFunction_;
      }
      handleGeometryChange_() {
        this.changed();
      }
      handleGeometryChanged_() {
        this.geometryChangeKey_ && (B(this.geometryChangeKey_), (this.geometryChangeKey_ = null));
        const t = this.getGeometry();
        t && (this.geometryChangeKey_ = j(t, O, this.handleGeometryChange_, this)), this.changed();
      }
      setGeometry(t) {
        this.set(this.geometryName_, t);
      }
      setStyle(t) {
        (this.style_ = t),
          (this.styleFunction_ = t
            ? (function (t) {
                if ('function' == typeof t) return t;
                let e;
                return (
                  Array.isArray(t)
                    ? (e = t)
                    : (We(
                        'function' == typeof t.getZIndex,
                        'Expected an `ol/style/Style` or an array of `ol/style/Style.js`',
                      ),
                      (e = [t])),
                  function () {
                    return e;
                  }
                );
              })(t)
            : void 0),
          this.changed();
      }
      setId(t) {
        (this.id_ = t), this.changed();
      }
      setGeometryName(t) {
        this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_),
          (this.geometryName_ = t),
          this.addChangeListener(this.geometryName_, this.handleGeometryChanged_),
          this.handleGeometryChanged_();
      }
    }
    const Or = Ar;
    var Dr = i(860);
    class Gr {
      constructor(t) {
        (this.opacity_ = t.opacity),
          (this.rotateWithView_ = t.rotateWithView),
          (this.rotation_ = t.rotation),
          (this.scale_ = t.scale),
          (this.scaleArray_ = Lr(t.scale)),
          (this.displacement_ = t.displacement),
          (this.declutterMode_ = t.declutterMode);
      }
      clone() {
        const t = this.getScale();
        return new Gr({
          opacity: this.getOpacity(),
          scale: Array.isArray(t) ? t.slice() : t,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode(),
        });
      }
      getOpacity() {
        return this.opacity_;
      }
      getRotateWithView() {
        return this.rotateWithView_;
      }
      getRotation() {
        return this.rotation_;
      }
      getScale() {
        return this.scale_;
      }
      getScaleArray() {
        return this.scaleArray_;
      }
      getDisplacement() {
        return this.displacement_;
      }
      getDeclutterMode() {
        return this.declutterMode_;
      }
      getAnchor() {
        return V();
      }
      getImage(t) {
        return V();
      }
      getHitDetectionImage() {
        return V();
      }
      getPixelRatio(t) {
        return 1;
      }
      getImageState() {
        return V();
      }
      getImageSize() {
        return V();
      }
      getOrigin() {
        return V();
      }
      getSize() {
        return V();
      }
      setDisplacement(t) {
        this.displacement_ = t;
      }
      setOpacity(t) {
        this.opacity_ = t;
      }
      setRotateWithView(t) {
        this.rotateWithView_ = t;
      }
      setRotation(t) {
        this.rotation_ = t;
      }
      setScale(t) {
        (this.scale_ = t), (this.scaleArray_ = Lr(t));
      }
      listenImageChange(t) {
        V();
      }
      load() {
        V();
      }
      unlistenImageChange(t) {
        V();
      }
    }
    const Nr = Gr;
    function zr(t) {
      return Array.isArray(t) ? Ln(t) : t;
    }
    class Wr extends Nr {
      constructor(t) {
        super({
          opacity: 1,
          rotateWithView: void 0 !== t.rotateWithView && t.rotateWithView,
          rotation: void 0 !== t.rotation ? t.rotation : 0,
          scale: void 0 !== t.scale ? t.scale : 1,
          displacement: void 0 !== t.displacement ? t.displacement : [0, 0],
          declutterMode: t.declutterMode,
        }),
          this.canvases_,
          (this.hitDetectionCanvas_ = null),
          (this.fill_ = void 0 !== t.fill ? t.fill : null),
          (this.origin_ = [0, 0]),
          (this.points_ = t.points),
          (this.radius_ = void 0 !== t.radius ? t.radius : t.radius1),
          (this.radius2_ = t.radius2),
          (this.angle_ = void 0 !== t.angle ? t.angle : 0),
          (this.stroke_ = void 0 !== t.stroke ? t.stroke : null),
          this.size_,
          this.renderOptions_,
          this.render();
      }
      clone() {
        const t = this.getScale(),
          e = new Wr({
            fill: this.getFill() ? this.getFill().clone() : void 0,
            points: this.getPoints(),
            radius: this.getRadius(),
            radius2: this.getRadius2(),
            angle: this.getAngle(),
            stroke: this.getStroke() ? this.getStroke().clone() : void 0,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            scale: Array.isArray(t) ? t.slice() : t,
            displacement: this.getDisplacement().slice(),
            declutterMode: this.getDeclutterMode(),
          });
        return e.setOpacity(this.getOpacity()), e;
      }
      getAnchor() {
        const t = this.size_,
          e = this.getDisplacement(),
          i = this.getScaleArray();
        return [t[0] / 2 - e[0] / i[0], t[1] / 2 + e[1] / i[1]];
      }
      getAngle() {
        return this.angle_;
      }
      getFill() {
        return this.fill_;
      }
      setFill(t) {
        (this.fill_ = t), this.render();
      }
      getHitDetectionImage() {
        return (
          this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(this.renderOptions_)),
          this.hitDetectionCanvas_
        );
      }
      getImage(t) {
        let e = this.canvases_[t];
        if (!e) {
          const i = this.renderOptions_,
            n = os(i.size * t, i.size * t);
          this.draw_(i, n, t), (e = n.canvas), (this.canvases_[t] = e);
        }
        return e;
      }
      getPixelRatio(t) {
        return t;
      }
      getImageSize() {
        return this.size_;
      }
      getImageState() {
        return 2;
      }
      getOrigin() {
        return this.origin_;
      }
      getPoints() {
        return this.points_;
      }
      getRadius() {
        return this.radius_;
      }
      getRadius2() {
        return this.radius2_;
      }
      getSize() {
        return this.size_;
      }
      getStroke() {
        return this.stroke_;
      }
      setStroke(t) {
        (this.stroke_ = t), this.render();
      }
      listenImageChange(t) {}
      load() {}
      unlistenImageChange(t) {}
      calculateLineJoinSize_(t, e, i) {
        if (0 === e || this.points_ === 1 / 0 || ('bevel' !== t && 'miter' !== t)) return e;
        let n = this.radius_,
          s = void 0 === this.radius2_ ? n : this.radius2_;
        if (n < s) {
          const t = n;
          (n = s), (s = t);
        }
        const r = void 0 === this.radius2_ ? this.points_ : 2 * this.points_,
          o = (2 * Math.PI) / r,
          a = s * Math.sin(o),
          h = n - Math.sqrt(s * s - a * a),
          l = Math.sqrt(a * a + h * h),
          c = l / a;
        if ('miter' === t && c <= i) return c * e;
        const u = e / 2 / c,
          d = (e / 2) * (h / l),
          g = Math.sqrt((n + u) * (n + u) + d * d) - n;
        if (void 0 === this.radius2_ || 'bevel' === t) return 2 * g;
        const f = n * Math.sin(o),
          _ = s - Math.sqrt(n * n - f * f),
          p = Math.sqrt(f * f + _ * _) / f;
        if (p <= i) {
          const t = (p * e) / 2 - s - n;
          return 2 * Math.max(g, t);
        }
        return 2 * g;
      }
      createRenderOptions() {
        let t,
          e = ds,
          i = fs,
          n = 0,
          s = null,
          r = 0,
          o = 0;
        this.stroke_ &&
          ((t = zr(this.stroke_.getColor() ?? _s)),
          (o = this.stroke_.getWidth() ?? 1),
          (s = this.stroke_.getLineDash()),
          (r = this.stroke_.getLineDashOffset() ?? 0),
          (i = this.stroke_.getLineJoin() ?? fs),
          (e = this.stroke_.getLineCap() ?? ds),
          (n = this.stroke_.getMiterLimit() ?? 10));
        const a = this.calculateLineJoinSize_(i, o, n),
          h = Math.max(this.radius_, this.radius2_ || 0);
        return {
          strokeStyle: t,
          strokeWidth: o,
          size: Math.ceil(2 * h + a),
          lineCap: e,
          lineDash: s,
          lineDashOffset: r,
          lineJoin: i,
          miterLimit: n,
        };
      }
      render() {
        this.renderOptions_ = this.createRenderOptions();
        const t = this.renderOptions_.size;
        (this.canvases_ = {}), (this.hitDetectionCanvas_ = null), (this.size_ = [t, t]);
      }
      draw_(t, e, i) {
        if ((e.scale(i, i), e.translate(t.size / 2, t.size / 2), this.createPath_(e), this.fill_)) {
          let t = this.fill_.getColor();
          null === t && (t = us), (e.fillStyle = zr(t)), e.fill();
        }
        t.strokeStyle &&
          ((e.strokeStyle = t.strokeStyle),
          (e.lineWidth = t.strokeWidth),
          t.lineDash && (e.setLineDash(t.lineDash), (e.lineDashOffset = t.lineDashOffset)),
          (e.lineCap = t.lineCap),
          (e.lineJoin = t.lineJoin),
          (e.miterLimit = t.miterLimit),
          e.stroke());
      }
      createHitDetectionCanvas_(t) {
        let e;
        if (this.fill_) {
          let i = this.fill_.getColor(),
            n = 0;
          'string' == typeof i && (i = Mn(i)),
            null === i ? (n = 1) : Array.isArray(i) && (n = 4 === i.length ? i[3] : 1),
            0 === n && ((e = os(t.size, t.size)), this.drawHitDetectionCanvas_(t, e));
        }
        return e ? e.canvas : this.getImage(1);
      }
      createPath_(t) {
        let e = this.points_;
        const i = this.radius_;
        if (e === 1 / 0) t.arc(0, 0, i, 0, 2 * Math.PI);
        else {
          const n = void 0 === this.radius2_ ? i : this.radius2_;
          void 0 !== this.radius2_ && (e *= 2);
          const s = this.angle_ - Math.PI / 2,
            r = (2 * Math.PI) / e;
          for (let o = 0; o < e; o++) {
            const e = s + o * r,
              a = o % 2 == 0 ? i : n;
            t.lineTo(a * Math.cos(e), a * Math.sin(e));
          }
          t.closePath();
        }
      }
      drawHitDetectionCanvas_(t, e) {
        e.translate(t.size / 2, t.size / 2),
          this.createPath_(e),
          (e.fillStyle = us),
          e.fill(),
          t.strokeStyle &&
            ((e.strokeStyle = t.strokeStyle),
            (e.lineWidth = t.strokeWidth),
            t.lineDash && (e.setLineDash(t.lineDash), (e.lineDashOffset = t.lineDashOffset)),
            (e.lineJoin = t.lineJoin),
            (e.miterLimit = t.miterLimit),
            e.stroke());
      }
    }
    const Xr = Wr;
    class jr extends Xr {
      constructor(t) {
        super({
          points: 1 / 0,
          fill: (t = t || { radius: 5 }).fill,
          radius: t.radius,
          stroke: t.stroke,
          scale: void 0 !== t.scale ? t.scale : 1,
          rotation: void 0 !== t.rotation ? t.rotation : 0,
          rotateWithView: void 0 !== t.rotateWithView && t.rotateWithView,
          displacement: void 0 !== t.displacement ? t.displacement : [0, 0],
          declutterMode: t.declutterMode,
        });
      }
      clone() {
        const t = this.getScale(),
          e = new jr({
            fill: this.getFill() ? this.getFill().clone() : void 0,
            stroke: this.getStroke() ? this.getStroke().clone() : void 0,
            radius: this.getRadius(),
            scale: Array.isArray(t) ? t.slice() : t,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            displacement: this.getDisplacement().slice(),
            declutterMode: this.getDeclutterMode(),
          });
        return e.setOpacity(this.getOpacity()), e;
      }
      setRadius(t) {
        (this.radius_ = t), this.render();
      }
    }
    const Yr = jr;
    class Br {
      constructor(t) {
        (t = t || {}), (this.color_ = void 0 !== t.color ? t.color : null);
      }
      clone() {
        const t = this.getColor();
        return new Br({ color: Array.isArray(t) ? t.slice() : t || void 0 });
      }
      getColor() {
        return this.color_;
      }
      setColor(t) {
        this.color_ = t;
      }
    }
    const Kr = Br;
    class Zr {
      constructor(t) {
        (t = t || {}),
          (this.color_ = void 0 !== t.color ? t.color : null),
          (this.lineCap_ = t.lineCap),
          (this.lineDash_ = void 0 !== t.lineDash ? t.lineDash : null),
          (this.lineDashOffset_ = t.lineDashOffset),
          (this.lineJoin_ = t.lineJoin),
          (this.miterLimit_ = t.miterLimit),
          (this.width_ = t.width);
      }
      clone() {
        const t = this.getColor();
        return new Zr({
          color: Array.isArray(t) ? t.slice() : t || void 0,
          lineCap: this.getLineCap(),
          lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
          lineDashOffset: this.getLineDashOffset(),
          lineJoin: this.getLineJoin(),
          miterLimit: this.getMiterLimit(),
          width: this.getWidth(),
        });
      }
      getColor() {
        return this.color_;
      }
      getLineCap() {
        return this.lineCap_;
      }
      getLineDash() {
        return this.lineDash_;
      }
      getLineDashOffset() {
        return this.lineDashOffset_;
      }
      getLineJoin() {
        return this.lineJoin_;
      }
      getMiterLimit() {
        return this.miterLimit_;
      }
      getWidth() {
        return this.width_;
      }
      setColor(t) {
        this.color_ = t;
      }
      setLineCap(t) {
        this.lineCap_ = t;
      }
      setLineDash(t) {
        this.lineDash_ = t;
      }
      setLineDashOffset(t) {
        this.lineDashOffset_ = t;
      }
      setLineJoin(t) {
        this.lineJoin_ = t;
      }
      setMiterLimit(t) {
        this.miterLimit_ = t;
      }
      setWidth(t) {
        this.width_ = t;
      }
    }
    const Vr = Zr;
    class qr {
      constructor(t) {
        (t = t || {}),
          (this.geometry_ = null),
          (this.geometryFunction_ = $r),
          void 0 !== t.geometry && this.setGeometry(t.geometry),
          (this.fill_ = void 0 !== t.fill ? t.fill : null),
          (this.image_ = void 0 !== t.image ? t.image : null),
          (this.renderer_ = void 0 !== t.renderer ? t.renderer : null),
          (this.hitDetectionRenderer_ = void 0 !== t.hitDetectionRenderer ? t.hitDetectionRenderer : null),
          (this.stroke_ = void 0 !== t.stroke ? t.stroke : null),
          (this.text_ = void 0 !== t.text ? t.text : null),
          (this.zIndex_ = t.zIndex);
      }
      clone() {
        let t = this.getGeometry();
        return (
          t && 'object' == typeof t && (t = t.clone()),
          new qr({
            geometry: t ?? void 0,
            fill: this.getFill() ? this.getFill().clone() : void 0,
            image: this.getImage() ? this.getImage().clone() : void 0,
            renderer: this.getRenderer() ?? void 0,
            stroke: this.getStroke() ? this.getStroke().clone() : void 0,
            text: this.getText() ? this.getText().clone() : void 0,
            zIndex: this.getZIndex(),
          })
        );
      }
      getRenderer() {
        return this.renderer_;
      }
      setRenderer(t) {
        this.renderer_ = t;
      }
      setHitDetectionRenderer(t) {
        this.hitDetectionRenderer_ = t;
      }
      getHitDetectionRenderer() {
        return this.hitDetectionRenderer_;
      }
      getGeometry() {
        return this.geometry_;
      }
      getGeometryFunction() {
        return this.geometryFunction_;
      }
      getFill() {
        return this.fill_;
      }
      setFill(t) {
        this.fill_ = t;
      }
      getImage() {
        return this.image_;
      }
      setImage(t) {
        this.image_ = t;
      }
      getStroke() {
        return this.stroke_;
      }
      setStroke(t) {
        this.stroke_ = t;
      }
      getText() {
        return this.text_;
      }
      setText(t) {
        this.text_ = t;
      }
      getZIndex() {
        return this.zIndex_;
      }
      setGeometry(t) {
        'function' == typeof t
          ? (this.geometryFunction_ = t)
          : 'string' == typeof t
            ? (this.geometryFunction_ = function (e) {
                return e.get(t);
              })
            : t
              ? void 0 !== t &&
                (this.geometryFunction_ = function () {
                  return t;
                })
              : (this.geometryFunction_ = $r),
          (this.geometry_ = t);
      }
      setZIndex(t) {
        this.zIndex_ = t;
      }
    }
    let Ur = null;
    function Hr(t, e) {
      if (!Ur) {
        const t = new Kr({ color: 'rgba(255,255,255,0.4)' }),
          e = new Vr({ color: '#3399CC', width: 1.25 });
        Ur = [new qr({ image: new Yr({ fill: t, stroke: e, radius: 5 }), fill: t, stroke: e })];
      }
      return Ur;
    }
    function $r(t) {
      return t.getGeometry();
    }
    const Jr = qr;
    let Qr = null;
    class to extends A {
      constructor(t, e, i, n, s) {
        super(),
          (this.hitDetectionImage_ = null),
          (this.image_ = t),
          (this.crossOrigin_ = i),
          (this.canvas_ = {}),
          (this.color_ = s),
          (this.imageState_ = void 0 === n ? 0 : n),
          (this.size_ = t && t.width && t.height ? [t.width, t.height] : null),
          (this.src_ = e),
          this.tainted_;
      }
      initializeImage_() {
        (this.image_ = new Image()), null !== this.crossOrigin_ && (this.image_.crossOrigin = this.crossOrigin_);
      }
      isTainted_() {
        if (void 0 === this.tainted_ && 2 === this.imageState_) {
          Qr || (Qr = os(1, 1, void 0, { willReadFrequently: !0 })), Qr.drawImage(this.image_, 0, 0);
          try {
            Qr.getImageData(0, 0, 1, 1), (this.tainted_ = !1);
          } catch (t) {
            (Qr = null), (this.tainted_ = !0);
          }
        }
        return !0 === this.tainted_;
      }
      dispatchChangeEvent_() {
        this.dispatchEvent(O);
      }
      handleImageError_() {
        (this.imageState_ = 3), this.dispatchChangeEvent_();
      }
      handleImageLoad_() {
        (this.imageState_ = 2), (this.size_ = [this.image_.width, this.image_.height]), this.dispatchChangeEvent_();
      }
      getImage(t) {
        return (
          this.image_ || this.initializeImage_(), this.replaceColor_(t), this.canvas_[t] ? this.canvas_[t] : this.image_
        );
      }
      getPixelRatio(t) {
        return this.replaceColor_(t), this.canvas_[t] ? t : 1;
      }
      getImageState() {
        return this.imageState_;
      }
      getHitDetectionImage() {
        if ((this.image_ || this.initializeImage_(), !this.hitDetectionImage_))
          if (this.isTainted_()) {
            const t = this.size_[0],
              e = this.size_[1],
              i = os(t, e);
            i.fillRect(0, 0, t, e), (this.hitDetectionImage_ = i.canvas);
          } else this.hitDetectionImage_ = this.image_;
        return this.hitDetectionImage_;
      }
      getSize() {
        return this.size_;
      }
      getSrc() {
        return this.src_;
      }
      load() {
        if (0 === this.imageState_) {
          this.image_ || this.initializeImage_(), (this.imageState_ = 1);
          try {
            void 0 !== this.src_ && (this.image_.src = this.src_);
          } catch (t) {
            this.handleImageError_();
          }
          this.image_ instanceof HTMLImageElement &&
            ((t = this.image_),
            (e = this.src_),
            e && (t.src = e),
            t.src && si
              ? new Promise((e, i) =>
                  t
                    .decode()
                    .then(() => e(t))
                    .catch((n) => (t.complete && t.width ? e(t) : i(n))),
                )
              : (function (t, e) {
                  return new Promise((e, i) => {
                    function n() {
                      r(), e(t);
                    }
                    function s() {
                      r(), i(new Error('Image load error'));
                    }
                    function r() {
                      t.removeEventListener('load', n), t.removeEventListener('error', s);
                    }
                    t.addEventListener('load', n), t.addEventListener('error', s);
                  });
                })(t))
              .then((t) => {
                (this.image_ = t), this.handleImageLoad_();
              })
              .catch(this.handleImageError_.bind(this));
        }
        var t, e;
      }
      replaceColor_(t) {
        if (!this.color_ || this.canvas_[t] || 2 !== this.imageState_) return;
        const e = this.image_,
          i = document.createElement('canvas');
        (i.width = Math.ceil(e.width * t)), (i.height = Math.ceil(e.height * t));
        const n = i.getContext('2d');
        n.scale(t, t),
          n.drawImage(e, 0, 0),
          (n.globalCompositeOperation = 'multiply'),
          (n.fillStyle = Cn(this.color_)),
          n.fillRect(0, 0, i.width / t, i.height / t),
          (n.globalCompositeOperation = 'destination-in'),
          n.drawImage(e, 0, 0),
          (this.canvas_[t] = i);
      }
    }
    function eo(t, e, i, n) {
      return void 0 !== i && void 0 !== n ? [i / t, n / e] : void 0 !== i ? i / t : void 0 !== n ? n / e : 1;
    }
    class io extends Nr {
      constructor(t) {
        const e = void 0 !== (t = t || {}).opacity ? t.opacity : 1,
          i = void 0 !== t.rotation ? t.rotation : 0,
          n = void 0 !== t.scale ? t.scale : 1,
          s = void 0 !== t.rotateWithView && t.rotateWithView;
        super({
          opacity: e,
          rotation: i,
          scale: n,
          displacement: void 0 !== t.displacement ? t.displacement : [0, 0],
          rotateWithView: s,
          declutterMode: t.declutterMode,
        }),
          (this.anchor_ = void 0 !== t.anchor ? t.anchor : [0.5, 0.5]),
          (this.normalizedAnchor_ = null),
          (this.anchorOrigin_ = void 0 !== t.anchorOrigin ? t.anchorOrigin : 'top-left'),
          (this.anchorXUnits_ = void 0 !== t.anchorXUnits ? t.anchorXUnits : 'fraction'),
          (this.anchorYUnits_ = void 0 !== t.anchorYUnits ? t.anchorYUnits : 'fraction'),
          (this.crossOrigin_ = void 0 !== t.crossOrigin ? t.crossOrigin : null);
        const r = void 0 !== t.img ? t.img : null;
        let o,
          a = t.src;
        if (
          (We(!(void 0 !== a && r), '`image` and `src` cannot be provided at the same time'),
          (void 0 !== a && 0 !== a.length) || !r || (a = r.src || U(r)),
          We(void 0 !== a && a.length > 0, 'A defined and non-empty `src` or `image` must be provided'),
          We(
            !((void 0 !== t.width || void 0 !== t.height) && void 0 !== t.scale),
            '`width` or `height` cannot be provided together with `scale`',
          ),
          void 0 !== t.src
            ? (o = 0)
            : void 0 !== r && (o = r instanceof HTMLImageElement ? (r.complete ? (r.src ? 2 : 0) : 1) : 2),
          (this.color_ = void 0 !== t.color ? Mn(t.color) : null),
          (this.iconImage_ = (function (t, e, i, n, s) {
            let r = void 0 === e ? void 0 : kn.get(e, i, s);
            return (
              r || ((r = new to(t, t instanceof HTMLImageElement ? t.src || void 0 : e, i, n, s)), kn.set(e, i, s, r)),
              r
            );
          })(r, a, this.crossOrigin_, o, this.color_)),
          (this.offset_ = void 0 !== t.offset ? t.offset : [0, 0]),
          (this.offsetOrigin_ = void 0 !== t.offsetOrigin ? t.offsetOrigin : 'top-left'),
          (this.origin_ = null),
          (this.size_ = void 0 !== t.size ? t.size : null),
          void 0 !== t.width || void 0 !== t.height)
        ) {
          let e, i;
          if (t.size) [e, i] = t.size;
          else {
            const n = this.getImage(1);
            if (n.width && n.height) (e = n.width), (i = n.height);
            else if (n instanceof HTMLImageElement) {
              this.initialOptions_ = t;
              const e = () => {
                if ((this.unlistenImageChange(e), !this.initialOptions_)) return;
                const i = this.iconImage_.getSize();
                this.setScale(eo(i[0], i[1], t.width, t.height));
              };
              return void this.listenImageChange(e);
            }
          }
          void 0 !== e && this.setScale(eo(e, i, t.width, t.height));
        }
      }
      clone() {
        let t, e, i;
        return (
          this.initialOptions_
            ? ((e = this.initialOptions_.width), (i = this.initialOptions_.height))
            : ((t = this.getScale()), (t = Array.isArray(t) ? t.slice() : t)),
          new io({
            anchor: this.anchor_.slice(),
            anchorOrigin: this.anchorOrigin_,
            anchorXUnits: this.anchorXUnits_,
            anchorYUnits: this.anchorYUnits_,
            color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
            crossOrigin: this.crossOrigin_,
            offset: this.offset_.slice(),
            offsetOrigin: this.offsetOrigin_,
            opacity: this.getOpacity(),
            rotateWithView: this.getRotateWithView(),
            rotation: this.getRotation(),
            scale: t,
            width: e,
            height: i,
            size: null !== this.size_ ? this.size_.slice() : void 0,
            src: this.getSrc(),
            displacement: this.getDisplacement().slice(),
            declutterMode: this.getDeclutterMode(),
          })
        );
      }
      getAnchor() {
        let t = this.normalizedAnchor_;
        if (!t) {
          t = this.anchor_;
          const e = this.getSize();
          if ('fraction' == this.anchorXUnits_ || 'fraction' == this.anchorYUnits_) {
            if (!e) return null;
            (t = this.anchor_.slice()),
              'fraction' == this.anchorXUnits_ && (t[0] *= e[0]),
              'fraction' == this.anchorYUnits_ && (t[1] *= e[1]);
          }
          if ('top-left' != this.anchorOrigin_) {
            if (!e) return null;
            t === this.anchor_ && (t = this.anchor_.slice()),
              ('top-right' != this.anchorOrigin_ && 'bottom-right' != this.anchorOrigin_) || (t[0] = -t[0] + e[0]),
              ('bottom-left' != this.anchorOrigin_ && 'bottom-right' != this.anchorOrigin_) || (t[1] = -t[1] + e[1]);
          }
          this.normalizedAnchor_ = t;
        }
        const e = this.getDisplacement(),
          i = this.getScaleArray();
        return [t[0] - e[0] / i[0], t[1] + e[1] / i[1]];
      }
      setAnchor(t) {
        (this.anchor_ = t), (this.normalizedAnchor_ = null);
      }
      getColor() {
        return this.color_;
      }
      getImage(t) {
        return this.iconImage_.getImage(t);
      }
      getPixelRatio(t) {
        return this.iconImage_.getPixelRatio(t);
      }
      getImageSize() {
        return this.iconImage_.getSize();
      }
      getImageState() {
        return this.iconImage_.getImageState();
      }
      getHitDetectionImage() {
        return this.iconImage_.getHitDetectionImage();
      }
      getOrigin() {
        if (this.origin_) return this.origin_;
        let t = this.offset_;
        if ('top-left' != this.offsetOrigin_) {
          const e = this.getSize(),
            i = this.iconImage_.getSize();
          if (!e || !i) return null;
          (t = t.slice()),
            ('top-right' != this.offsetOrigin_ && 'bottom-right' != this.offsetOrigin_) || (t[0] = i[0] - e[0] - t[0]),
            ('bottom-left' != this.offsetOrigin_ && 'bottom-right' != this.offsetOrigin_) ||
              (t[1] = i[1] - e[1] - t[1]);
        }
        return (this.origin_ = t), this.origin_;
      }
      getSrc() {
        return this.iconImage_.getSrc();
      }
      getSize() {
        return this.size_ ? this.size_ : this.iconImage_.getSize();
      }
      getWidth() {
        const t = this.getScaleArray();
        return this.size_
          ? this.size_[0] * t[0]
          : 2 == this.iconImage_.getImageState()
            ? this.iconImage_.getSize()[0] * t[0]
            : void 0;
      }
      getHeight() {
        const t = this.getScaleArray();
        return this.size_
          ? this.size_[1] * t[1]
          : 2 == this.iconImage_.getImageState()
            ? this.iconImage_.getSize()[1] * t[1]
            : void 0;
      }
      setScale(t) {
        delete this.initialOptions_, super.setScale(t);
      }
      listenImageChange(t) {
        this.iconImage_.addEventListener(O, t);
      }
      load() {
        this.iconImage_.load();
      }
      unlistenImageChange(t) {
        this.iconImage_.removeEventListener(O, t);
      }
    }
    const no = io;
    class so {
      constructor(t) {
        (t = t || {}),
          (this.font_ = t.font),
          (this.rotation_ = t.rotation),
          (this.rotateWithView_ = t.rotateWithView),
          (this.scale_ = t.scale),
          (this.scaleArray_ = Lr(void 0 !== t.scale ? t.scale : 1)),
          (this.text_ = t.text),
          (this.textAlign_ = t.textAlign),
          (this.justify_ = t.justify),
          (this.repeat_ = t.repeat),
          (this.textBaseline_ = t.textBaseline),
          (this.fill_ = void 0 !== t.fill ? t.fill : new Kr({ color: '#333' })),
          (this.maxAngle_ = void 0 !== t.maxAngle ? t.maxAngle : Math.PI / 4),
          (this.placement_ = void 0 !== t.placement ? t.placement : 'point'),
          (this.overflow_ = !!t.overflow),
          (this.stroke_ = void 0 !== t.stroke ? t.stroke : null),
          (this.offsetX_ = void 0 !== t.offsetX ? t.offsetX : 0),
          (this.offsetY_ = void 0 !== t.offsetY ? t.offsetY : 0),
          (this.backgroundFill_ = t.backgroundFill ? t.backgroundFill : null),
          (this.backgroundStroke_ = t.backgroundStroke ? t.backgroundStroke : null),
          (this.padding_ = void 0 === t.padding ? null : t.padding);
      }
      clone() {
        const t = this.getScale();
        return new so({
          font: this.getFont(),
          placement: this.getPlacement(),
          repeat: this.getRepeat(),
          maxAngle: this.getMaxAngle(),
          overflow: this.getOverflow(),
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          scale: Array.isArray(t) ? t.slice() : t,
          text: this.getText(),
          textAlign: this.getTextAlign(),
          justify: this.getJustify(),
          textBaseline: this.getTextBaseline(),
          fill: this.getFill() ? this.getFill().clone() : void 0,
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          offsetX: this.getOffsetX(),
          offsetY: this.getOffsetY(),
          backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
          backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
          padding: this.getPadding() || void 0,
        });
      }
      getOverflow() {
        return this.overflow_;
      }
      getFont() {
        return this.font_;
      }
      getMaxAngle() {
        return this.maxAngle_;
      }
      getPlacement() {
        return this.placement_;
      }
      getRepeat() {
        return this.repeat_;
      }
      getOffsetX() {
        return this.offsetX_;
      }
      getOffsetY() {
        return this.offsetY_;
      }
      getFill() {
        return this.fill_;
      }
      getRotateWithView() {
        return this.rotateWithView_;
      }
      getRotation() {
        return this.rotation_;
      }
      getScale() {
        return this.scale_;
      }
      getScaleArray() {
        return this.scaleArray_;
      }
      getStroke() {
        return this.stroke_;
      }
      getText() {
        return this.text_;
      }
      getTextAlign() {
        return this.textAlign_;
      }
      getJustify() {
        return this.justify_;
      }
      getTextBaseline() {
        return this.textBaseline_;
      }
      getBackgroundFill() {
        return this.backgroundFill_;
      }
      getBackgroundStroke() {
        return this.backgroundStroke_;
      }
      getPadding() {
        return this.padding_;
      }
      setOverflow(t) {
        this.overflow_ = t;
      }
      setFont(t) {
        this.font_ = t;
      }
      setMaxAngle(t) {
        this.maxAngle_ = t;
      }
      setOffsetX(t) {
        this.offsetX_ = t;
      }
      setOffsetY(t) {
        this.offsetY_ = t;
      }
      setPlacement(t) {
        this.placement_ = t;
      }
      setRepeat(t) {
        this.repeat_ = t;
      }
      setRotateWithView(t) {
        this.rotateWithView_ = t;
      }
      setFill(t) {
        this.fill_ = t;
      }
      setRotation(t) {
        this.rotation_ = t;
      }
      setScale(t) {
        (this.scale_ = t), (this.scaleArray_ = Lr(void 0 !== t ? t : 1));
      }
      setStroke(t) {
        this.stroke_ = t;
      }
      setText(t) {
        this.text_ = t;
      }
      setTextAlign(t) {
        this.textAlign_ = t;
      }
      setJustify(t) {
        this.justify_ = t;
      }
      setTextBaseline(t) {
        this.textBaseline_ = t;
      }
      setBackgroundFill(t) {
        this.backgroundFill_ = t;
      }
      setBackgroundStroke(t) {
        this.backgroundStroke_ = t;
      }
      setPadding(t) {
        this.padding_ = t;
      }
    }
    const ro = so;
    let oo = 0;
    const ao = 0,
      ho = 1 << oo++,
      lo = 1 << oo++,
      co = 1 << oo++,
      uo = 1 << oo++,
      go = 1 << oo++,
      fo = Math.pow(2, 5) - 1,
      _o = { [ho]: 'boolean', [lo]: 'number', [co]: 'string', [uo]: 'color', [go]: 'number[]' },
      po = Object.keys(_o).map(Number).sort(S);
    function mo(t) {
      const e = [];
      for (const n of po) (t & (i = n)) === i && e.push(_o[n]);
      var i;
      return 0 === e.length
        ? 'untyped'
        : e.length < 3
          ? e.join(' or ')
          : e.slice(0, -1).join(', ') + ', or ' + e[e.length - 1];
    }
    function yo(t, e) {
      return !!(t & e);
    }
    function vo(t, e) {
      return t === e;
    }
    class xo {
      constructor(t, e) {
        (this.type = t), (this.value = e);
      }
    }
    class wo {
      constructor(t, e, ...i) {
        (this.type = t), (this.operator = e), (this.args = i);
      }
    }
    function Co() {
      return { variables: new Set(), properties: new Set(), featureId: !1, style: {} };
    }
    function So(t, e, i) {
      switch (typeof t) {
        case 'boolean':
          return new xo(ho, t);
        case 'number':
          return new xo(lo, t);
        case 'string': {
          let e = co;
          return (
            (function (t) {
              try {
                return Rn(t), !0;
              } catch (t) {
                return !1;
              }
            })(t) && (e |= uo),
            vo(e & i, ao) || (e &= i),
            new xo(e, t)
          );
        }
      }
      if (!Array.isArray(t)) throw new Error('Expression must be an array or a primitive value');
      if (0 === t.length) throw new Error('Empty expression');
      if ('string' == typeof t[0])
        return (function (t, e, i) {
          const n = t[0],
            s = To[n];
          if (!s) throw new Error(`Unknown operator: ${n}`);
          return s(t, e, i);
        })(t, e, i);
      for (const e of t) if ('number' != typeof e) throw new Error('Expected an array of numbers');
      let n = go;
      return (3 !== t.length && 4 !== t.length) || (n |= uo), i && (n &= i), new xo(n, t);
    }
    const Eo = {
        Get: 'get',
        Var: 'var',
        Concat: 'concat',
        GeometryType: 'geometry-type',
        Any: 'any',
        All: 'all',
        Not: '!',
        Resolution: 'resolution',
        Zoom: 'zoom',
        Time: 'time',
        Equal: '==',
        NotEqual: '!=',
        GreaterThan: '>',
        GreaterThanOrEqualTo: '>=',
        LessThan: '<',
        LessThanOrEqualTo: '<=',
        Multiply: '*',
        Divide: '/',
        Add: '+',
        Subtract: '-',
        Clamp: 'clamp',
        Mod: '%',
        Pow: '^',
        Abs: 'abs',
        Floor: 'floor',
        Ceil: 'ceil',
        Round: 'round',
        Sin: 'sin',
        Cos: 'cos',
        Atan: 'atan',
        Sqrt: 'sqrt',
        Match: 'match',
        Between: 'between',
        Interpolate: 'interpolate',
        Case: 'case',
        In: 'in',
        Number: 'number',
        String: 'string',
        Array: 'array',
        Color: 'color',
        Id: 'id',
        Band: 'band',
        Palette: 'palette',
      },
      To = {
        [Eo.Get]: Lo(
          ([t, e]) =>
            void 0 !== e
              ? (function (t) {
                  switch (t) {
                    case 'string':
                      return co;
                    case 'color':
                      return uo;
                    case 'number':
                      return lo;
                    case 'boolean':
                      return ho;
                    case 'number[]':
                      return go;
                    default:
                      throw new Error(`Unrecognized type hint: ${t}`);
                  }
                })(e.value)
              : fo,
          Io(1, 2),
          function (t, e) {
            const i = So(t[1], e);
            if (!(i instanceof xo)) throw new Error('Expected a literal argument for get operation');
            if ('string' != typeof i.value) throw new Error('Expected a string argument for get operation');
            return e.properties.add(i.value), 3 === t.length ? [i, So(t[2], e)] : [i];
          },
        ),
        [Eo.Var]: Lo(
          ([t]) => t.type,
          Io(1, 1),
          function (t, e, i, n) {
            const s = t[1];
            if ('string' != typeof s) throw new Error('Expected a string argument for var operation');
            if ((e.variables.add(s), !('variables' in e.style) || void 0 === e.style.variables[s]))
              return [new xo(fo, s)];
            const r = So(e.style.variables[s], e);
            if (((r.value = s), n && !yo(n, r.type)))
              throw new Error(`The variable ${s} has type ${mo(r.type)} but the following type was expected: ${mo(n)}`);
            return [r];
          },
        ),
        [Eo.Id]: Lo(lo | co, bo, function (t, e) {
          e.featureId = !0;
        }),
        [Eo.Concat]: Lo(co, Io(2, 1 / 0), Ro(fo)),
        [Eo.GeometryType]: Lo(co, bo),
        [Eo.Resolution]: Lo(lo, bo),
        [Eo.Zoom]: Lo(lo, bo),
        [Eo.Time]: Lo(lo, bo),
        [Eo.Any]: Lo(ho, Io(2, 1 / 0), Ro(ho)),
        [Eo.All]: Lo(ho, Io(2, 1 / 0), Ro(ho)),
        [Eo.Not]: Lo(ho, Io(1, 1), Ro(ho)),
        [Eo.Equal]: Lo(ho, Io(2, 2), Ro(fo), Mo),
        [Eo.NotEqual]: Lo(ho, Io(2, 2), Ro(fo), Mo),
        [Eo.GreaterThan]: Lo(ho, Io(2, 2), Ro(fo), Mo),
        [Eo.GreaterThanOrEqualTo]: Lo(ho, Io(2, 2), Ro(fo), Mo),
        [Eo.LessThan]: Lo(ho, Io(2, 2), Ro(fo), Mo),
        [Eo.LessThanOrEqualTo]: Lo(ho, Io(2, 2), Ro(fo), Mo),
        [Eo.Multiply]: Lo(
          (t) => {
            let e = lo | uo;
            for (let i = 0; i < t.length; i++) e &= t[i].type;
            return e;
          },
          Io(2, 1 / 0),
          Ro(lo | uo),
          Mo,
        ),
        [Eo.Divide]: Lo(lo, Io(2, 2), Ro(lo)),
        [Eo.Add]: Lo(lo, Io(2, 1 / 0), Ro(lo)),
        [Eo.Subtract]: Lo(lo, Io(2, 2), Ro(lo)),
        [Eo.Clamp]: Lo(lo, Io(3, 3), Ro(lo)),
        [Eo.Mod]: Lo(lo, Io(2, 2), Ro(lo)),
        [Eo.Pow]: Lo(lo, Io(2, 2), Ro(lo)),
        [Eo.Abs]: Lo(lo, Io(1, 1), Ro(lo)),
        [Eo.Floor]: Lo(lo, Io(1, 1), Ro(lo)),
        [Eo.Ceil]: Lo(lo, Io(1, 1), Ro(lo)),
        [Eo.Round]: Lo(lo, Io(1, 1), Ro(lo)),
        [Eo.Sin]: Lo(lo, Io(1, 1), Ro(lo)),
        [Eo.Cos]: Lo(lo, Io(1, 1), Ro(lo)),
        [Eo.Atan]: Lo(lo, Io(1, 2), Ro(lo)),
        [Eo.Sqrt]: Lo(lo, Io(1, 1), Ro(lo)),
        [Eo.Match]: Lo(
          (t) => {
            let e = fo;
            for (let i = 2; i < t.length; i += 2) e &= t[i].type;
            return (e &= t[t.length - 1].type), e;
          },
          Io(4, 1 / 0),
          Po,
          function (t, e, i, n) {
            const s = t.length - 1;
            let r = So(t[1], e).type;
            const o = So(t[t.length - 1], e);
            let a = void 0 !== n ? n & o.type : o.type;
            const h = new Array(s - 2);
            for (let i = 0; i < s - 2; i += 2) {
              const n = So(t[i + 2], e),
                s = So(t[i + 3], e);
              (r &= n.type), (a &= s.type), (h[i] = n), (h[i + 1] = s);
            }
            const l = co | lo | ho;
            if (!yo(l, r))
              throw new Error(`Expected an input of type ${mo(l)} for the interpolate operation, got ${mo(r)} instead`);
            if (vo(a, ao))
              throw new Error(
                'Could not find a common output type for the following match operation: ' + JSON.stringify(t),
              );
            for (let i = 0; i < s - 2; i += 2) {
              const n = So(t[i + 2], e, r),
                s = So(t[i + 3], e, a);
              (h[i] = n), (h[i + 1] = s);
            }
            return [So(t[1], e, r), ...h, So(t[t.length - 1], e, a)];
          },
        ),
        [Eo.Between]: Lo(ho, Io(3, 3), Ro(lo)),
        [Eo.Interpolate]: Lo(
          (t) => {
            let e = uo | lo;
            for (let i = 3; i < t.length; i += 2) e &= t[i].type;
            return e;
          },
          Io(6, 1 / 0),
          Po,
          function (t, e, i, n) {
            const s = t[1];
            let r;
            switch (s[0]) {
              case 'linear':
                r = 1;
                break;
              case 'exponential':
                if (((r = s[1]), 'number' != typeof r))
                  throw new Error(
                    `Expected a number base for exponential interpolation, got ${JSON.stringify(r)} instead`,
                  );
                break;
              default:
                r = null;
            }
            if (!r) throw new Error(`Invalid interpolation type: ${JSON.stringify(s)}`);
            r = So(r, e);
            let o = So(t[2], e);
            if (!yo(lo, o.type))
              throw new Error(
                `Expected an input of type number for the interpolate operation, got ${mo(o.type)} instead`,
              );
            o = So(t[2], e, lo);
            const a = new Array(t.length - 3);
            for (let i = 0; i < a.length; i += 2) {
              let n = So(t[i + 3], e);
              if (!yo(lo, n.type))
                throw new Error(
                  `Expected all stop input values in the interpolate operation to be of type number, got ${mo(n.type)} at position ${i + 2} instead`,
                );
              let s = So(t[i + 4], e);
              if (!yo(lo | uo, s.type))
                throw new Error(
                  `Expected all stop output values in the interpolate operation to be a number or color, got ${mo(s.type)} at position ${i + 3} instead`,
                );
              (n = So(t[i + 3], e, lo)), (s = So(t[i + 4], e, lo | uo)), (a[i] = n), (a[i + 1] = s);
            }
            return [r, o, ...a];
          },
        ),
        [Eo.Case]: Lo(
          (t) => {
            let e = fo;
            for (let i = 1; i < t.length; i += 2) e &= t[i].type;
            return (e &= t[t.length - 1].type), e;
          },
          Io(3, 1 / 0),
          function (t, e) {
            const i = t[0],
              n = t.length - 1;
            if (n % 2 == 0)
              throw new Error(
                `An odd amount of arguments was expected for operation ${i}, got ${JSON.stringify(n)} instead`,
              );
          },
          function (t, e, i, n) {
            const s = So(t[t.length - 1], e);
            let r = void 0 !== n ? n & s.type : s.type;
            const o = new Array(t.length - 1);
            for (let i = 0; i < o.length - 1; i += 2) {
              const n = So(t[i + 1], e),
                s = So(t[i + 2], e);
              if (!yo(ho, n.type))
                throw new Error(
                  `Expected all conditions in the case operation to be of type boolean, got ${mo(n.type)} at position ${i} instead`,
                );
              (r &= s.type), (o[i] = n), (o[i + 1] = s);
            }
            if (vo(r, ao))
              throw new Error(
                'Could not find a common output type for the following case operation: ' + JSON.stringify(t),
              );
            for (let i = 0; i < o.length - 1; i += 2) o[i + 1] = So(t[i + 2], e, r);
            return (o[o.length - 1] = So(t[t.length - 1], e, r)), o;
          },
        ),
        [Eo.In]: Lo(ho, Io(2, 2), function (t, e) {
          let i = t[2];
          if (!Array.isArray(i))
            throw new Error(
              'The "in" operator was provided a literal value which was not an array as second argument.',
            );
          if ('string' == typeof i[0]) {
            if ('literal' !== i[0])
              throw new Error(
                'For the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions.',
              );
            if (!Array.isArray(i[1]))
              throw new Error(
                'The "in" operator was provided a literal value which was not an array as second argument.',
              );
            i = i[1];
          }
          let n = co | lo;
          const s = new Array(i.length);
          for (let t = 0; t < s.length; t++) {
            const r = So(i[t], e);
            (n &= r.type), (s[t] = r);
          }
          if (vo(n, ao))
            throw new Error('Could not find a common type for the following in operation: ' + JSON.stringify(t));
          return [So(t[1], e, n), ...s];
        }),
        [Eo.Number]: Lo(lo, Io(1, 1 / 0), Ro(fo)),
        [Eo.String]: Lo(co, Io(1, 1 / 0), Ro(fo)),
        [Eo.Array]: Lo((t) => (3 === t.length || 4 === t.length ? go | uo : go), Io(1, 1 / 0), Ro(lo)),
        [Eo.Color]: Lo(uo, Io(3, 4), Ro(lo)),
        [Eo.Band]: Lo(lo, Io(1, 3), Ro(lo)),
        [Eo.Palette]: Lo(uo, Io(2, 2), function (t, e) {
          const i = So(t[1], e, lo);
          if (i.type !== lo)
            throw new Error(`The first argument of palette must be an number, got ${mo(i.type)} instead`);
          const n = t[2];
          if (!Array.isArray(n)) throw new Error('The second argument of palette must be an array');
          const s = new Array(n.length);
          for (let t = 0; t < s.length; t++) {
            const i = So(n[t], e, uo);
            if (!(i instanceof xo)) throw new Error(`The palette color at index ${t} must be a literal value`);
            if (!yo(i.type, uo))
              throw new Error(`The palette color at index ${t} should be of type color, got ${mo(i.type)} instead`);
            s[t] = i;
          }
          return [i, ...s];
        }),
      };
    function bo(t, e) {
      const i = t[0];
      if (1 !== t.length) throw new Error(`Expected no arguments for ${i} operation`);
      return [];
    }
    function Io(t, e) {
      return function (i, n) {
        const s = i[0],
          r = i.length - 1;
        if (t === e) {
          if (r !== t) throw new Error(`Expected ${t} argument${1 === t ? '' : 's'} for ${s}, got ${r}`);
        } else if (r < t || r > e)
          throw new Error(`Expected ${e === 1 / 0 ? `${t} or more` : `${t} to ${e}`} arguments for ${s}, got ${r}`);
      };
    }
    function Ro(t) {
      return function (e, i) {
        const n = e[0],
          s = e.length - 1,
          r = new Array(s);
        for (let o = 0; o < s; ++o) {
          const s = So(e[o + 1], i);
          if (!yo(t, s.type)) {
            const e = mo(t),
              i = mo(s.type);
            throw new Error(`Unexpected type for argument ${o} of ${n} operation, got ${e} but expected ${i}`);
          }
          (s.type &= t), (r[o] = s);
        }
        return r;
      };
    }
    function Mo(t, e, i) {
      const n = t[0],
        s = t.length - 1;
      let r = fo;
      for (let t = 0; t < i.length; ++t) r &= i[t].type;
      if (r === ao) throw new Error(`No common type could be found for arguments of ${n} operation`);
      const o = new Array(s);
      for (let i = 0; i < s; ++i) o[i] = So(t[i + 1], e, r);
      return o;
    }
    function Po(t, e) {
      const i = t[0],
        n = t.length - 1;
      if (n % 2 == 1)
        throw new Error(
          `An even amount of arguments was expected for operation ${i}, got ${JSON.stringify(n)} instead`,
        );
    }
    function Lo(t, ...e) {
      return function (i, n, s) {
        const r = i[0];
        let o = [];
        for (let t = 0; t < e.length; t++) o = e[t](i, n, o, s) || o;
        let a = 'function' == typeof t ? t(o) : t;
        if (void 0 !== s) {
          if (!yo(a, s))
            throw new Error(
              `The following expression was expected to return ${mo(s)}, but returns ${mo(a)} instead: ${JSON.stringify(i)}`,
            );
          a &= s;
        }
        if (a === ao) throw new Error(`No matching type was found for the following expression: ${JSON.stringify(i)}`);
        return new wo(a, r, ...o);
      };
    }
    function Fo(t, e, i) {
      const n = So(t, i);
      if (!yo(e, n.type)) {
        const t = mo(e),
          i = mo(n.type);
        throw new Error(`Expected expression to be of type ${t}, got ${i}`);
      }
      return ko(n, i);
    }
    function ko(t, e) {
      if (t instanceof xo) {
        if (t.type === uo && 'string' == typeof t.value) {
          const e = Rn(t.value);
          return function () {
            return e;
          };
        }
        return function () {
          return t.value;
        };
      }
      const i = t.operator;
      switch (i) {
        case Eo.Number:
        case Eo.String:
          return (function (t, e) {
            const i = t.operator,
              n = t.args.length,
              s = new Array(n);
            for (let i = 0; i < n; ++i) s[i] = ko(t.args[i], e);
            switch (i) {
              case Eo.Number:
              case Eo.String:
                return (t) => {
                  for (let e = 0; e < n; ++e) {
                    const n = s[e](t);
                    if (typeof n === i) return n;
                  }
                  throw new Error(`Expected one of the values to be a ${i}`);
                };
              default:
                throw new Error(`Unsupported assertion operator ${i}`);
            }
          })(t, e);
        case Eo.Get:
        case Eo.Var:
          return (function (t, e) {
            const i = t.args[0].value;
            switch (t.operator) {
              case Eo.Get:
                return (t) => t.properties[i];
              case Eo.Var:
                return (t) => t.variables[i];
              default:
                throw new Error(`Unsupported accessor operator ${t.operator}`);
            }
          })(t);
        case Eo.Id:
          return (t) => t.featureId;
        case Eo.Concat: {
          const i = t.args.map((t) => ko(t, e));
          return (t) => ''.concat(...i.map((e) => e(t).toString()));
        }
        case Eo.Resolution:
          return (t) => t.resolution;
        case Eo.Any:
        case Eo.All:
        case Eo.Not:
          return (function (t, e) {
            const i = t.operator,
              n = t.args.length,
              s = new Array(n);
            for (let i = 0; i < n; ++i) s[i] = ko(t.args[i], e);
            switch (i) {
              case Eo.Any:
                return (t) => {
                  for (let e = 0; e < n; ++e) if (s[e](t)) return !0;
                  return !1;
                };
              case Eo.All:
                return (t) => {
                  for (let e = 0; e < n; ++e) if (!s[e](t)) return !1;
                  return !0;
                };
              case Eo.Not:
                return (t) => !s[0](t);
              default:
                throw new Error(`Unsupported logical operator ${i}`);
            }
          })(t, e);
        case Eo.Equal:
        case Eo.NotEqual:
        case Eo.LessThan:
        case Eo.LessThanOrEqualTo:
        case Eo.GreaterThan:
        case Eo.GreaterThanOrEqualTo:
          return (function (t, e) {
            const i = t.operator,
              n = ko(t.args[0], e),
              s = ko(t.args[1], e);
            switch (i) {
              case Eo.Equal:
                return (t) => n(t) === s(t);
              case Eo.NotEqual:
                return (t) => n(t) !== s(t);
              case Eo.LessThan:
                return (t) => n(t) < s(t);
              case Eo.LessThanOrEqualTo:
                return (t) => n(t) <= s(t);
              case Eo.GreaterThan:
                return (t) => n(t) > s(t);
              case Eo.GreaterThanOrEqualTo:
                return (t) => n(t) >= s(t);
              default:
                throw new Error(`Unsupported comparison operator ${i}`);
            }
          })(t, e);
        case Eo.Multiply:
        case Eo.Divide:
        case Eo.Add:
        case Eo.Subtract:
        case Eo.Clamp:
        case Eo.Mod:
        case Eo.Pow:
        case Eo.Abs:
        case Eo.Floor:
        case Eo.Ceil:
        case Eo.Round:
        case Eo.Sin:
        case Eo.Cos:
        case Eo.Atan:
        case Eo.Sqrt:
          return (function (t, e) {
            const i = t.operator,
              n = t.args.length,
              s = new Array(n);
            for (let i = 0; i < n; ++i) s[i] = ko(t.args[i], e);
            switch (i) {
              case Eo.Multiply:
                return (t) => {
                  let e = 1;
                  for (let i = 0; i < n; ++i) e *= s[i](t);
                  return e;
                };
              case Eo.Divide:
                return (t) => s[0](t) / s[1](t);
              case Eo.Add:
                return (t) => {
                  let e = 0;
                  for (let i = 0; i < n; ++i) e += s[i](t);
                  return e;
                };
              case Eo.Subtract:
                return (t) => s[0](t) - s[1](t);
              case Eo.Clamp:
                return (t) => {
                  const e = s[0](t),
                    i = s[1](t);
                  if (e < i) return i;
                  const n = s[2](t);
                  return e > n ? n : e;
                };
              case Eo.Mod:
                return (t) => s[0](t) % s[1](t);
              case Eo.Pow:
                return (t) => Math.pow(s[0](t), s[1](t));
              case Eo.Abs:
                return (t) => Math.abs(s[0](t));
              case Eo.Floor:
                return (t) => Math.floor(s[0](t));
              case Eo.Ceil:
                return (t) => Math.ceil(s[0](t));
              case Eo.Round:
                return (t) => Math.round(s[0](t));
              case Eo.Sin:
                return (t) => Math.sin(s[0](t));
              case Eo.Cos:
                return (t) => Math.cos(s[0](t));
              case Eo.Atan:
                return 2 === n ? (t) => Math.atan2(s[0](t), s[1](t)) : (t) => Math.atan(s[0](t));
              case Eo.Sqrt:
                return (t) => Math.sqrt(s[0](t));
              default:
                throw new Error(`Unsupported numeric operator ${i}`);
            }
          })(t, e);
        case Eo.Match:
          return (function (t, e) {
            const i = t.args.length,
              n = new Array(i);
            for (let s = 0; s < i; ++s) n[s] = ko(t.args[s], e);
            return (t) => {
              const e = n[0](t);
              for (let s = 1; s < i; s += 2) if (e === n[s](t)) return n[s + 1](t);
              return n[i - 1](t);
            };
          })(t, e);
        case Eo.Interpolate:
          return (function (t, e) {
            const i = t.args.length,
              n = new Array(i);
            for (let s = 0; s < i; ++s) n[s] = ko(t.args[s], e);
            return (t) => {
              const e = n[0](t),
                s = n[1](t);
              let r, o;
              for (let a = 2; a < i; a += 2) {
                const i = n[a](t);
                let h = n[a + 1](t);
                const l = Array.isArray(h);
                if ((l && (h = bn(h)), i >= s)) return 2 === a ? h : l ? Oo(e, s, r, o, i, h) : Ao(e, s, r, o, i, h);
                (r = i), (o = h);
              }
              return o;
            };
          })(t, e);
        default:
          throw new Error(`Unsupported operator ${i}`);
      }
    }
    function Ao(t, e, i, n, s, r) {
      const o = s - i;
      if (0 === o) return n;
      const a = e - i;
      return n + (1 === t ? a / o : (Math.pow(t, a) - 1) / (Math.pow(t, o) - 1)) * (r - n);
    }
    function Oo(t, e, i, n, s, r) {
      if (0 == s - i) return n;
      const o = In(n),
        a = In(r);
      let h = a[2] - o[2];
      return (
        h > 180 ? (h -= 360) : h < -180 && (h += 360),
        Pn(
          (function (t) {
            const e = fn.rgb(mn.xyz(t));
            return (e[3] = t[3]), e;
          })([
            Ao(t, e, i, o[0], s, a[0]),
            Ao(t, e, i, o[1], s, a[1]),
            o[2] + Ao(t, e, i, 0, s, h),
            Ao(t, e, i, n[3], s, r[3]),
          ]),
        )
      );
    }
    function Do(t) {
      return !0;
    }
    function Go(t) {
      const e = Co(),
        i = t.length,
        n = new Array(i);
      for (let s = 0; s < i; ++s) n[s] = No(t[s], e);
      const s = { variables: {}, properties: {}, resolution: NaN, featureId: null },
        r = new Array(i);
      return function (t, o) {
        if (((s.properties = t.getPropertiesInternal()), (s.resolution = o), e.featureId)) {
          const e = t.getId();
          s.featureId = void 0 !== e ? e : null;
        }
        let a = 0;
        for (let t = 0; t < i; ++t) {
          const e = n[t](s);
          e && ((r[a] = e), (a += 1));
        }
        return (r.length = a), r;
      };
    }
    function No(t, e) {
      const i = zo(t, '', e),
        n = Wo(t, '', e),
        s = (function (t, e) {
          const i = 'text-',
            n = jo(t, i + 'value', e);
          if (!n) return null;
          const s = zo(t, i, e),
            r = zo(t, i + 'background-', e),
            o = Wo(t, i, e),
            a = Wo(t, i + 'background-', e),
            h = jo(t, i + 'font', e),
            l = Xo(t, i + 'max-angle', e),
            c = Xo(t, i + 'offset-x', e),
            u = Xo(t, i + 'offset-y', e),
            d = Yo(t, i + 'overflow', e),
            g = jo(t, i + 'placement', e),
            f = Xo(t, i + 'repeat', e),
            _ = Vo(t, i + 'scale', e),
            p = Yo(t, i + 'rotate-with-view', e),
            m = Xo(t, i + 'rotation', e),
            y = jo(t, i + 'align', e),
            v = jo(t, i + 'justify', e),
            x = jo(t, i + 'baseline', e),
            w = Ko(t, i + 'padding', e),
            C = new ro({});
          return function (t) {
            if (
              (C.setText(n(t)),
              s && C.setFill(s(t)),
              r && C.setBackgroundFill(r(t)),
              o && C.setStroke(o(t)),
              a && C.setBackgroundStroke(a(t)),
              h && C.setFont(h(t)),
              l && C.setMaxAngle(l(t)),
              c && C.setOffsetX(c(t)),
              u && C.setOffsetY(u(t)),
              d && C.setOverflow(d(t)),
              g)
            ) {
              const e = g(t);
              if ('point' !== e && 'line' !== e) throw new Error('Expected point or line for text-placement');
              C.setPlacement(e);
            }
            if (
              (f && C.setRepeat(f(t)),
              _ && C.setScale(_(t)),
              p && C.setRotateWithView(p(t)),
              m && C.setRotation(m(t)),
              y)
            ) {
              const e = y(t);
              if ('left' !== e && 'center' !== e && 'right' !== e && 'end' !== e && 'start' !== e)
                throw new Error('Expected left, right, center, start, or end for text-align');
              C.setTextAlign(e);
            }
            if (v) {
              const e = v(t);
              if ('left' !== e && 'right' !== e && 'center' !== e)
                throw new Error('Expected left, right, or center for text-justify');
              C.setJustify(e);
            }
            if (x) {
              const e = x(t);
              if ('bottom' !== e && 'top' !== e && 'middle' !== e && 'alphabetic' !== e && 'hanging' !== e)
                throw new Error('Expected bottom, top, middle, alphabetic, or hanging for text-baseline');
              C.setTextBaseline(e);
            }
            return w && C.setPadding(w(t)), C;
          };
        })(t, e),
        r = (function (t, e) {
          return 'icon-src' in t
            ? (function (t, e) {
                const i = 'icon-',
                  n = i + 'src',
                  s = Qo(t[n], n),
                  r = Zo(t, i + 'anchor', e),
                  o = Vo(t, i + 'scale', e),
                  a = Xo(t, i + 'opacity', e),
                  h = Zo(t, i + 'displacement', e),
                  l = Xo(t, i + 'rotation', e),
                  c = Yo(t, i + 'rotate-with-view', e),
                  u = Uo(t, i + 'anchor-origin'),
                  d = Ho(t, i + 'anchor-x-units'),
                  g = Ho(t, i + 'anchor-y-units'),
                  f = (function (t, e) {
                    const i = t[e];
                    if (void 0 !== i) return ea(i, e);
                  })(t, i + 'color'),
                  _ = (function (t, e) {
                    const i = t[e];
                    if (void 0 !== i) {
                      if ('string' != typeof i) throw new Error(`Expected a string for ${e}`);
                      return i;
                    }
                  })(t, i + 'cross-origin'),
                  p = (function (t, e) {
                    const i = t[e];
                    if (void 0 !== i) return Jo(i, e);
                  })(t, i + 'offset'),
                  m = Uo(t, i + 'offset-origin'),
                  y = qo(t, i + 'width'),
                  v = qo(t, i + 'height'),
                  x = (function (t, e) {
                    const i = t[e];
                    if (void 0 !== i) {
                      if ('number' == typeof i) return Lr(i);
                      if (!Array.isArray(i)) throw new Error(`Expected a number or size array for ${e}`);
                      if (2 !== i.length || 'number' != typeof i[0] || 'number' != typeof i[1])
                        throw new Error(`Expected a number or size array for ${e}`);
                      return i;
                    }
                  })(t, i + 'size'),
                  w = $o(t, i + 'declutter'),
                  C = new no({
                    src: s,
                    anchorOrigin: u,
                    anchorXUnits: d,
                    anchorYUnits: g,
                    color: f,
                    crossOrigin: _,
                    offset: p,
                    offsetOrigin: m,
                    height: v,
                    width: y,
                    size: x,
                    declutterMode: w,
                  });
                return function (t) {
                  return (
                    a && C.setOpacity(a(t)),
                    h && C.setDisplacement(h(t)),
                    l && C.setRotation(l(t)),
                    c && C.setRotateWithView(c(t)),
                    o && C.setScale(o(t)),
                    r && C.setAnchor(r(t)),
                    C
                  );
                };
              })(t, e)
            : 'shape-points' in t
              ? (function (t, e) {
                  const i = 'shape-',
                    n = i + 'points',
                    s = ta(t[n], n),
                    r = zo(t, i, e),
                    o = Wo(t, i, e),
                    a = Vo(t, i + 'scale', e),
                    h = Zo(t, i + 'displacement', e),
                    l = Xo(t, i + 'rotation', e),
                    c = Yo(t, i + 'rotate-with-view', e),
                    u = qo(t, i + 'radius'),
                    d = qo(t, i + 'radius1'),
                    g = qo(t, i + 'radius2'),
                    f = qo(t, i + 'angle'),
                    _ = $o(t, i + 'declutter-mode'),
                    p = new Xr({ points: s, radius: u, radius1: d, radius2: g, angle: f, declutterMode: _ });
                  return function (t) {
                    return (
                      r && p.setFill(r(t)),
                      o && p.setStroke(o(t)),
                      h && p.setDisplacement(h(t)),
                      l && p.setRotation(l(t)),
                      c && p.setRotateWithView(c(t)),
                      a && p.setScale(a(t)),
                      p
                    );
                  };
                })(t, e)
              : 'circle-radius' in t
                ? (function (t, e) {
                    const i = 'circle-',
                      n = zo(t, i, e),
                      s = Wo(t, i, e),
                      r = Xo(t, i + 'radius', e),
                      o = Vo(t, i + 'scale', e),
                      a = Zo(t, i + 'displacement', e),
                      h = Xo(t, i + 'rotation', e),
                      l = Yo(t, i + 'rotate-with-view', e),
                      c = $o(t, i + 'declutter-mode'),
                      u = new Yr({ radius: 5, declutterMode: c });
                    return function (t) {
                      return (
                        r && u.setRadius(r(t)),
                        n && u.setFill(n(t)),
                        s && u.setStroke(s(t)),
                        a && u.setDisplacement(a(t)),
                        h && u.setRotation(h(t)),
                        l && u.setRotateWithView(l(t)),
                        o && u.setScale(o(t)),
                        u
                      );
                    };
                  })(t, e)
                : null;
        })(t, e),
        o = Xo(t, 'z-index', e);
      if (!(i || n || s || r || k(t)))
        throw new Error('No fill, stroke, point, or text symbolizer properties in style: ' + JSON.stringify(t));
      const a = new Jr();
      return function (t) {
        let e = !0;
        if (i) {
          const n = i(t);
          n && (e = !1), a.setFill(n);
        }
        if (n) {
          const i = n(t);
          i && (e = !1), a.setStroke(i);
        }
        if (s) {
          const i = s(t);
          i && (e = !1), a.setText(i);
        }
        if (r) {
          const i = r(t);
          i && (e = !1), a.setImage(i);
        }
        return o && a.setZIndex(o(t)), e ? null : a;
      };
    }
    function zo(t, e, i) {
      const n = Bo(t, e + 'fill-color', i);
      if (!n) return null;
      const s = new Kr();
      return function (t) {
        const e = n(t);
        return 'none' === e ? null : (s.setColor(e), s);
      };
    }
    function Wo(t, e, i) {
      const n = Xo(t, e + 'stroke-width', i),
        s = Bo(t, e + 'stroke-color', i);
      if (!n && !s) return null;
      const r = jo(t, e + 'stroke-line-cap', i),
        o = jo(t, e + 'stroke-line-join', i),
        a = Ko(t, e + 'stroke-line-dash', i),
        h = Xo(t, e + 'stroke-line-dash-offset', i),
        l = Xo(t, e + 'stroke-miter-limit', i),
        c = new Vr();
      return function (t) {
        if (s) {
          const e = s(t);
          if ('none' === e) return null;
          c.setColor(e);
        }
        if ((n && c.setWidth(n(t)), r)) {
          const e = r(t);
          if ('butt' !== e && 'round' !== e && 'square' !== e)
            throw new Error('Expected butt, round, or square line cap');
          c.setLineCap(e);
        }
        if (o) {
          const e = o(t);
          if ('bevel' !== e && 'round' !== e && 'miter' !== e)
            throw new Error('Expected bevel, round, or miter line join');
          c.setLineJoin(e);
        }
        return a && c.setLineDash(a(t)), h && c.setLineDashOffset(h(t)), l && c.setMiterLimit(l(t)), c;
      };
    }
    function Xo(t, e, i) {
      if (!(e in t)) return;
      const n = Fo(t[e], lo, i);
      return function (t) {
        return ta(n(t), e);
      };
    }
    function jo(t, e, i) {
      if (!(e in t)) return null;
      const n = Fo(t[e], co, i);
      return function (t) {
        return Qo(n(t), e);
      };
    }
    function Yo(t, e, i) {
      if (!(e in t)) return null;
      const n = Fo(t[e], ho, i);
      return function (t) {
        const i = n(t);
        if ('boolean' != typeof i) throw new Error(`Expected a boolean for ${e}`);
        return i;
      };
    }
    function Bo(t, e, i) {
      if (!(e in t)) return null;
      const n = Fo(t[e], uo | co, i);
      return function (t) {
        return ea(n(t), e);
      };
    }
    function Ko(t, e, i) {
      if (!(e in t)) return null;
      const n = Fo(t[e], go, i);
      return function (t) {
        return Jo(n(t), e);
      };
    }
    function Zo(t, e, i) {
      if (!(e in t)) return null;
      const n = Fo(t[e], go, i);
      return function (t) {
        const i = Jo(n(t), e);
        if (2 !== i.length) throw new Error(`Expected two numbers for ${e}`);
        return i;
      };
    }
    function Vo(t, e, i) {
      if (!(e in t)) return null;
      const n = Fo(t[e], go | lo, i);
      return function (t) {
        return (function (t, e) {
          if ('number' == typeof t) return t;
          const i = Jo(t, e);
          if (2 !== i.length) throw new Error(`Expected an array of two numbers for ${e}`);
          return i;
        })(n(t), e);
      };
    }
    function qo(t, e) {
      const i = t[e];
      if (void 0 !== i) {
        if ('number' != typeof i) throw new Error(`Expected a number for ${e}`);
        return i;
      }
    }
    function Uo(t, e) {
      const i = t[e];
      if (void 0 !== i) {
        if ('bottom-left' !== i && 'bottom-right' !== i && 'top-left' !== i && 'top-right' !== i)
          throw new Error(`Expected bottom-left, bottom-right, top-left, or top-right for ${e}`);
        return i;
      }
    }
    function Ho(t, e) {
      const i = t[e];
      if (void 0 !== i) {
        if ('pixels' !== i && 'fraction' !== i) throw new Error(`Expected pixels or fraction for ${e}`);
        return i;
      }
    }
    function $o(t, e) {
      const i = t[e];
      if (void 0 !== i) {
        if ('string' != typeof i) throw new Error(`Expected a string for ${e}`);
        if ('declutter' !== i && 'obstacle' !== i && 'none' !== i)
          throw new Error(`Expected declutter, obstacle, or none for ${e}`);
        return i;
      }
    }
    function Jo(t, e) {
      if (!Array.isArray(t)) throw new Error(`Expected an array for ${e}`);
      const i = t.length;
      for (let n = 0; n < i; ++n) if ('number' != typeof t[n]) throw new Error(`Expected an array of numbers for ${e}`);
      return t;
    }
    function Qo(t, e) {
      if ('string' != typeof t) throw new Error(`Expected a string for ${e}`);
      return t;
    }
    function ta(t, e) {
      if ('number' != typeof t) throw new Error(`Expected a number for ${e}`);
      return t;
    }
    function ea(t, e) {
      if ('string' == typeof t) return t;
      const i = Jo(t, e),
        n = i.length;
      if (n < 3 || n > 4) throw new Error(`Expected a color with 3 or 4 values for ${e}`);
      return i;
    }
    const ia = 'renderOrder',
      na = class extends Un {
        constructor(t) {
          t = t || {};
          const e = Object.assign({}, t);
          delete e.style,
            delete e.renderBuffer,
            delete e.updateWhileAnimating,
            delete e.updateWhileInteracting,
            super(e),
            (this.declutter_ = void 0 !== t.declutter && t.declutter),
            (this.renderBuffer_ = void 0 !== t.renderBuffer ? t.renderBuffer : 100),
            (this.style_ = null),
            (this.styleFunction_ = void 0),
            this.setStyle(t.style),
            (this.updateWhileAnimating_ = void 0 !== t.updateWhileAnimating && t.updateWhileAnimating),
            (this.updateWhileInteracting_ = void 0 !== t.updateWhileInteracting && t.updateWhileInteracting);
        }
        getDeclutter() {
          return this.declutter_;
        }
        getFeatures(t) {
          return super.getFeatures(t);
        }
        getRenderBuffer() {
          return this.renderBuffer_;
        }
        getRenderOrder() {
          return this.get(ia);
        }
        getStyle() {
          return this.style_;
        }
        getStyleFunction() {
          return this.styleFunction_;
        }
        getUpdateWhileAnimating() {
          return this.updateWhileAnimating_;
        }
        getUpdateWhileInteracting() {
          return this.updateWhileInteracting_;
        }
        renderDeclutter(t) {
          t.declutterTree || (t.declutterTree = new Dr(9)), this.getRenderer().renderDeclutter(t);
        }
        setRenderOrder(t) {
          this.set(ia, t);
        }
        setStyle(t) {
          (this.style_ = (function (t) {
            if (void 0 === t) return Hr;
            if (!t) return null;
            if ('function' == typeof t) return t;
            if (t instanceof Jr) return t;
            if (!Array.isArray(t)) return Go([t]);
            if (0 === t.length) return [];
            const e = t.length,
              i = t[0];
            if (i instanceof Jr) {
              const i = new Array(e);
              for (let n = 0; n < e; ++n) {
                const e = t[n];
                if (!(e instanceof Jr)) throw new Error('Expected a list of style instances');
                i[n] = e;
              }
              return i;
            }
            if ('style' in i) {
              const i = new Array(e);
              for (let n = 0; n < e; ++n) {
                const e = t[n];
                if (!('style' in e)) throw new Error('Expected a list of rules with a style property');
                i[n] = e;
              }
              return (function (t) {
                const e = Co(),
                  i = (function (t, e) {
                    const i = t.length,
                      n = new Array(i);
                    for (let s = 0; s < i; ++s) {
                      const i = t[s],
                        r = 'filter' in i ? Fo(i.filter, ho, e) : Do;
                      let o;
                      if (Array.isArray(i.style)) {
                        const t = i.style.length;
                        o = new Array(t);
                        for (let n = 0; n < t; ++n) o[n] = No(i.style[n], e);
                      } else o = [No(i.style, e)];
                      n[s] = { filter: r, styles: o };
                    }
                    return function (e) {
                      const s = [];
                      let r = !1;
                      for (let o = 0; o < i; ++o)
                        if ((0, n[o].filter)(e) && (!t[o].else || !r)) {
                          r = !0;
                          for (const t of n[o].styles) {
                            const i = t(e);
                            i && s.push(i);
                          }
                        }
                      return s;
                    };
                  })(t, e),
                  n = { variables: {}, properties: {}, resolution: NaN, featureId: null };
                return function (t, s) {
                  if (((n.properties = t.getPropertiesInternal()), (n.resolution = s), e.featureId)) {
                    const e = t.getId();
                    n.featureId = void 0 !== e ? e : null;
                  }
                  return i(n);
                };
              })(i);
            }
            return Go(t);
          })(t)),
            (this.styleFunction_ =
              null === t
                ? void 0
                : (function (t) {
                    let e;
                    if ('function' == typeof t) e = t;
                    else {
                      let i;
                      Array.isArray(t)
                        ? (i = t)
                        : (We('function' == typeof t.getZIndex, 'Expected an `Style` or an array of `Style`'),
                          (i = [t])),
                        (e = function () {
                          return i;
                        });
                    }
                    return e;
                  })(this.style_)),
            this.changed();
        }
      },
      sa = {
        BEGIN_GEOMETRY: 0,
        BEGIN_PATH: 1,
        CIRCLE: 2,
        CLOSE_PATH: 3,
        CUSTOM: 4,
        DRAW_CHARS: 5,
        DRAW_IMAGE: 6,
        END_GEOMETRY: 7,
        FILL: 8,
        MOVE_TO_LINE_TO: 9,
        SET_FILL_STYLE: 10,
        SET_STROKE_STYLE: 11,
        STROKE: 12,
      },
      ra = [sa.FILL],
      oa = [sa.STROKE],
      aa = [sa.BEGIN_PATH],
      ha = [sa.CLOSE_PATH],
      la = sa,
      ca = class {
        drawCustom(t, e, i, n) {}
        drawGeometry(t) {}
        setStyle(t) {}
        drawCircle(t, e) {}
        drawFeature(t, e) {}
        drawGeometryCollection(t, e) {}
        drawLineString(t, e) {}
        drawMultiLineString(t, e) {}
        drawMultiPoint(t, e) {}
        drawMultiPolygon(t, e) {}
        drawPoint(t, e) {}
        drawPolygon(t, e) {}
        drawText(t, e) {}
        setFillStrokeStyle(t, e) {}
        setImageStyle(t, e) {}
        setTextStyle(t, e) {}
      },
      ua = class extends ca {
        constructor(t, e, i, n) {
          super(),
            (this.tolerance = t),
            (this.maxExtent = e),
            (this.pixelRatio = n),
            (this.maxLineWidth = 0),
            (this.resolution = i),
            (this.beginGeometryInstruction1_ = null),
            (this.beginGeometryInstruction2_ = null),
            (this.bufferedMaxExtent_ = null),
            (this.instructions = []),
            (this.coordinates = []),
            (this.tmpCoordinate_ = []),
            (this.hitDetectionInstructions = []),
            (this.state = {});
        }
        applyPixelRatio(t) {
          const e = this.pixelRatio;
          return 1 == e
            ? t
            : t.map(function (t) {
                return t * e;
              });
        }
        appendFlatPointCoordinates(t, e) {
          const i = this.getBufferedMaxExtent(),
            n = this.tmpCoordinate_,
            s = this.coordinates;
          let r = s.length;
          for (let o = 0, a = t.length; o < a; o += e)
            (n[0] = t[o]), (n[1] = t[o + 1]), Ct(i, n) && ((s[r++] = n[0]), (s[r++] = n[1]));
          return r;
        }
        appendFlatLineCoordinates(t, e, i, n, s, r) {
          const o = this.coordinates;
          let a = o.length;
          const h = this.getBufferedMaxExtent();
          r && (e += n);
          let l = t[e],
            c = t[e + 1];
          const u = this.tmpCoordinate_;
          let d,
            g,
            f,
            _ = !0;
          for (d = e + n; d < i; d += n)
            (u[0] = t[d]),
              (u[1] = t[d + 1]),
              (f = Tt(h, u)),
              f !== g
                ? (_ && ((o[a++] = l), (o[a++] = c), (_ = !1)), (o[a++] = u[0]), (o[a++] = u[1]))
                : f === mt.INTERSECTING
                  ? ((o[a++] = u[0]), (o[a++] = u[1]), (_ = !1))
                  : (_ = !0),
              (l = u[0]),
              (c = u[1]),
              (g = f);
          return ((s && _) || d === e + n) && ((o[a++] = l), (o[a++] = c)), a;
        }
        drawCustomCoordinates_(t, e, i, n, s) {
          for (let r = 0, o = i.length; r < o; ++r) {
            const o = i[r],
              a = this.appendFlatLineCoordinates(t, e, o, n, !1, !1);
            s.push(a), (e = o);
          }
          return e;
        }
        drawCustom(t, e, i, n) {
          this.beginGeometry(t, e);
          const s = t.getType(),
            r = t.getStride(),
            o = this.coordinates.length;
          let a, h, l, c, u;
          switch (s) {
            case 'MultiPolygon':
              (a = t.getOrientedFlatCoordinates()), (c = []);
              const e = t.getEndss();
              u = 0;
              for (let t = 0, i = e.length; t < i; ++t) {
                const i = [];
                (u = this.drawCustomCoordinates_(a, u, e[t], r, i)), c.push(i);
              }
              this.instructions.push([la.CUSTOM, o, c, t, i, Fi]),
                this.hitDetectionInstructions.push([la.CUSTOM, o, c, t, n || i, Fi]);
              break;
            case 'Polygon':
            case 'MultiLineString':
              (l = []),
                (a = 'Polygon' == s ? t.getOrientedFlatCoordinates() : t.getFlatCoordinates()),
                (u = this.drawCustomCoordinates_(a, 0, t.getEnds(), r, l)),
                this.instructions.push([la.CUSTOM, o, l, t, i, Li]),
                this.hitDetectionInstructions.push([la.CUSTOM, o, l, t, n || i, Li]);
              break;
            case 'LineString':
            case 'Circle':
              (a = t.getFlatCoordinates()),
                (h = this.appendFlatLineCoordinates(a, 0, a.length, r, !1, !1)),
                this.instructions.push([la.CUSTOM, o, h, t, i, Pi]),
                this.hitDetectionInstructions.push([la.CUSTOM, o, h, t, n || i, Pi]);
              break;
            case 'MultiPoint':
              (a = t.getFlatCoordinates()),
                (h = this.appendFlatPointCoordinates(a, r)),
                h > o &&
                  (this.instructions.push([la.CUSTOM, o, h, t, i, Pi]),
                  this.hitDetectionInstructions.push([la.CUSTOM, o, h, t, n || i, Pi]));
              break;
            case 'Point':
              (a = t.getFlatCoordinates()),
                this.coordinates.push(a[0], a[1]),
                (h = this.coordinates.length),
                this.instructions.push([la.CUSTOM, o, h, t, i]),
                this.hitDetectionInstructions.push([la.CUSTOM, o, h, t, n || i]);
          }
          this.endGeometry(e);
        }
        beginGeometry(t, e) {
          (this.beginGeometryInstruction1_ = [la.BEGIN_GEOMETRY, e, 0, t]),
            this.instructions.push(this.beginGeometryInstruction1_),
            (this.beginGeometryInstruction2_ = [la.BEGIN_GEOMETRY, e, 0, t]),
            this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
        }
        finish() {
          return {
            instructions: this.instructions,
            hitDetectionInstructions: this.hitDetectionInstructions,
            coordinates: this.coordinates,
          };
        }
        reverseHitDetectionInstructions() {
          const t = this.hitDetectionInstructions;
          let e;
          t.reverse();
          const i = t.length;
          let n,
            s,
            r = -1;
          for (e = 0; e < i; ++e)
            (n = t[e]),
              (s = n[0]),
              s == la.END_GEOMETRY
                ? (r = e)
                : s == la.BEGIN_GEOMETRY && ((n[2] = e), T(this.hitDetectionInstructions, r, e), (r = -1));
        }
        setFillStrokeStyle(t, e) {
          const i = this.state;
          if (t) {
            const e = t.getColor();
            i.fillStyle = zr(e || us);
          } else i.fillStyle = void 0;
          if (e) {
            const t = e.getColor();
            i.strokeStyle = zr(t || _s);
            const n = e.getLineCap();
            i.lineCap = void 0 !== n ? n : ds;
            const s = e.getLineDash();
            i.lineDash = s ? s.slice() : gs;
            const r = e.getLineDashOffset();
            i.lineDashOffset = r || 0;
            const o = e.getLineJoin();
            i.lineJoin = void 0 !== o ? o : fs;
            const a = e.getWidth();
            i.lineWidth = void 0 !== a ? a : 1;
            const h = e.getMiterLimit();
            (i.miterLimit = void 0 !== h ? h : 10),
              i.lineWidth > this.maxLineWidth && ((this.maxLineWidth = i.lineWidth), (this.bufferedMaxExtent_ = null));
          } else
            (i.strokeStyle = void 0),
              (i.lineCap = void 0),
              (i.lineDash = null),
              (i.lineDashOffset = void 0),
              (i.lineJoin = void 0),
              (i.lineWidth = void 0),
              (i.miterLimit = void 0);
        }
        createFill(t) {
          const e = t.fillStyle,
            i = [la.SET_FILL_STYLE, e];
          return 'string' != typeof e && i.push(!0), i;
        }
        applyStroke(t) {
          this.instructions.push(this.createStroke(t));
        }
        createStroke(t) {
          return [
            la.SET_STROKE_STYLE,
            t.strokeStyle,
            t.lineWidth * this.pixelRatio,
            t.lineCap,
            t.lineJoin,
            t.miterLimit,
            this.applyPixelRatio(t.lineDash),
            t.lineDashOffset * this.pixelRatio,
          ];
        }
        updateFillStyle(t, e) {
          const i = t.fillStyle;
          ('string' == typeof i && t.currentFillStyle == i) ||
            (void 0 !== i && this.instructions.push(e.call(this, t)), (t.currentFillStyle = i));
        }
        updateStrokeStyle(t, e) {
          const i = t.strokeStyle,
            n = t.lineCap,
            s = t.lineDash,
            r = t.lineDashOffset,
            o = t.lineJoin,
            a = t.lineWidth,
            h = t.miterLimit;
          (t.currentStrokeStyle != i ||
            t.currentLineCap != n ||
            (s != t.currentLineDash && !I(t.currentLineDash, s)) ||
            t.currentLineDashOffset != r ||
            t.currentLineJoin != o ||
            t.currentLineWidth != a ||
            t.currentMiterLimit != h) &&
            (void 0 !== i && e.call(this, t),
            (t.currentStrokeStyle = i),
            (t.currentLineCap = n),
            (t.currentLineDash = s),
            (t.currentLineDashOffset = r),
            (t.currentLineJoin = o),
            (t.currentLineWidth = a),
            (t.currentMiterLimit = h));
        }
        endGeometry(t) {
          (this.beginGeometryInstruction1_[2] = this.instructions.length),
            (this.beginGeometryInstruction1_ = null),
            (this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length),
            (this.beginGeometryInstruction2_ = null);
          const e = [la.END_GEOMETRY, t];
          this.instructions.push(e), this.hitDetectionInstructions.push(e);
        }
        getBufferedMaxExtent() {
          if (!this.bufferedMaxExtent_ && ((this.bufferedMaxExtent_ = xt(this.maxExtent)), this.maxLineWidth > 0)) {
            const t = (this.resolution * (this.maxLineWidth + 1)) / 2;
            vt(this.bufferedMaxExtent_, t, this.bufferedMaxExtent_);
          }
          return this.bufferedMaxExtent_;
        }
      },
      da = class extends ua {
        constructor(t, e, i, n) {
          super(t, e, i, n);
        }
        drawFlatCoordinatess_(t, e, i, n) {
          const s = this.state,
            r = void 0 !== s.fillStyle,
            o = void 0 !== s.strokeStyle,
            a = i.length;
          this.instructions.push(aa), this.hitDetectionInstructions.push(aa);
          for (let s = 0; s < a; ++s) {
            const r = i[s],
              a = this.coordinates.length,
              h = this.appendFlatLineCoordinates(t, e, r, n, !0, !o),
              l = [la.MOVE_TO_LINE_TO, a, h];
            this.instructions.push(l),
              this.hitDetectionInstructions.push(l),
              o && (this.instructions.push(ha), this.hitDetectionInstructions.push(ha)),
              (e = r);
          }
          return (
            r && (this.instructions.push(ra), this.hitDetectionInstructions.push(ra)),
            o && (this.instructions.push(oa), this.hitDetectionInstructions.push(oa)),
            e
          );
        }
        drawCircle(t, e) {
          const i = this.state,
            n = i.fillStyle,
            s = i.strokeStyle;
          if (void 0 === n && void 0 === s) return;
          this.setFillStrokeStyles_(),
            this.beginGeometry(t, e),
            void 0 !== i.fillStyle && this.hitDetectionInstructions.push([la.SET_FILL_STYLE, us]),
            void 0 !== i.strokeStyle &&
              this.hitDetectionInstructions.push([
                la.SET_STROKE_STYLE,
                i.strokeStyle,
                i.lineWidth,
                i.lineCap,
                i.lineJoin,
                i.miterLimit,
                gs,
                0,
              ]);
          const r = t.getFlatCoordinates(),
            o = t.getStride(),
            a = this.coordinates.length;
          this.appendFlatLineCoordinates(r, 0, r.length, o, !1, !1);
          const h = [la.CIRCLE, a];
          this.instructions.push(aa, h),
            this.hitDetectionInstructions.push(aa, h),
            void 0 !== i.fillStyle && (this.instructions.push(ra), this.hitDetectionInstructions.push(ra)),
            void 0 !== i.strokeStyle && (this.instructions.push(oa), this.hitDetectionInstructions.push(oa)),
            this.endGeometry(e);
        }
        drawPolygon(t, e) {
          const i = this.state,
            n = i.fillStyle,
            s = i.strokeStyle;
          if (void 0 === n && void 0 === s) return;
          this.setFillStrokeStyles_(),
            this.beginGeometry(t, e),
            void 0 !== i.fillStyle && this.hitDetectionInstructions.push([la.SET_FILL_STYLE, us]),
            void 0 !== i.strokeStyle &&
              this.hitDetectionInstructions.push([
                la.SET_STROKE_STYLE,
                i.strokeStyle,
                i.lineWidth,
                i.lineCap,
                i.lineJoin,
                i.miterLimit,
                gs,
                0,
              ]);
          const r = t.getEnds(),
            o = t.getOrientedFlatCoordinates(),
            a = t.getStride();
          this.drawFlatCoordinatess_(o, 0, r, a), this.endGeometry(e);
        }
        drawMultiPolygon(t, e) {
          const i = this.state,
            n = i.fillStyle,
            s = i.strokeStyle;
          if (void 0 === n && void 0 === s) return;
          this.setFillStrokeStyles_(),
            this.beginGeometry(t, e),
            void 0 !== i.fillStyle && this.hitDetectionInstructions.push([la.SET_FILL_STYLE, us]),
            void 0 !== i.strokeStyle &&
              this.hitDetectionInstructions.push([
                la.SET_STROKE_STYLE,
                i.strokeStyle,
                i.lineWidth,
                i.lineCap,
                i.lineJoin,
                i.miterLimit,
                gs,
                0,
              ]);
          const r = t.getEndss(),
            o = t.getOrientedFlatCoordinates(),
            a = t.getStride();
          let h = 0;
          for (let t = 0, e = r.length; t < e; ++t) h = this.drawFlatCoordinatess_(o, h, r[t], a);
          this.endGeometry(e);
        }
        finish() {
          this.reverseHitDetectionInstructions(), (this.state = null);
          const t = this.tolerance;
          if (0 !== t) {
            const e = this.coordinates;
            for (let i = 0, n = e.length; i < n; ++i) e[i] = Ii(e[i], t);
          }
          return super.finish();
        }
        setFillStrokeStyles_() {
          const t = this.state;
          void 0 !== t.fillStyle && this.updateFillStyle(t, this.createFill),
            void 0 !== t.strokeStyle && this.updateStrokeStyle(t, this.applyStroke);
        }
      };
    function ga(t, e, i, n, s) {
      const r = [];
      let o = i,
        a = 0,
        h = e.slice(i, 2);
      for (; a < t && o + s < n; ) {
        const [i, n] = h.slice(-2),
          l = e[o + s],
          c = e[o + s + 1],
          u = Math.sqrt((l - i) * (l - i) + (c - n) * (c - n));
        if (((a += u), a >= t)) {
          const e = (t - a + u) / u,
            d = ae(i, l, e),
            g = ae(n, c, e);
          h.push(d, g), r.push(h), (h = [d, g]), a == t && (o += s), (a = 0);
        } else if (a < t) h.push(e[o + s], e[o + s + 1]), (o += s);
        else {
          const t = u - a,
            e = ae(i, l, t / u),
            d = ae(n, c, t / u);
          h.push(e, d), r.push(h), (h = [e, d]), (a = 0), (o += s);
        }
      }
      return a > 0 && r.push(h), r;
    }
    function fa(t, e, i, n, s) {
      let r,
        o,
        a,
        h,
        l,
        c,
        u,
        d,
        g,
        f,
        _ = i,
        p = i,
        m = 0,
        y = 0,
        v = i;
      for (o = i; o < n; o += s) {
        const i = e[o],
          n = e[o + 1];
        void 0 !== l &&
          ((g = i - l),
          (f = n - c),
          (h = Math.sqrt(g * g + f * f)),
          void 0 !== u &&
            ((y += a),
            (r = Math.acos((u * g + d * f) / (a * h))),
            r > t && (y > m && ((m = y), (_ = v), (p = o)), (y = 0), (v = o - s))),
          (a = h),
          (u = g),
          (d = f)),
          (l = i),
          (c = n);
      }
      return (y += h), y > m ? [v, o] : [_, p];
    }
    const _a = {
        left: 0,
        center: 0.5,
        right: 1,
        top: 0,
        middle: 0.5,
        hanging: 0.2,
        alphabetic: 0.8,
        ideographic: 0.8,
        bottom: 1,
      },
      pa = {
        Circle: da,
        Default: ua,
        Image: class extends ua {
          constructor(t, e, i, n) {
            super(t, e, i, n),
              (this.hitDetectionImage_ = null),
              (this.image_ = null),
              (this.imagePixelRatio_ = void 0),
              (this.anchorX_ = void 0),
              (this.anchorY_ = void 0),
              (this.height_ = void 0),
              (this.opacity_ = void 0),
              (this.originX_ = void 0),
              (this.originY_ = void 0),
              (this.rotateWithView_ = void 0),
              (this.rotation_ = void 0),
              (this.scale_ = void 0),
              (this.width_ = void 0),
              (this.declutterMode_ = void 0),
              (this.declutterImageWithText_ = void 0);
          }
          drawPoint(t, e) {
            if (!this.image_) return;
            this.beginGeometry(t, e);
            const i = t.getFlatCoordinates(),
              n = t.getStride(),
              s = this.coordinates.length,
              r = this.appendFlatPointCoordinates(i, n);
            this.instructions.push([
              la.DRAW_IMAGE,
              s,
              r,
              this.image_,
              this.anchorX_ * this.imagePixelRatio_,
              this.anchorY_ * this.imagePixelRatio_,
              Math.ceil(this.height_ * this.imagePixelRatio_),
              this.opacity_,
              this.originX_ * this.imagePixelRatio_,
              this.originY_ * this.imagePixelRatio_,
              this.rotateWithView_,
              this.rotation_,
              [
                (this.scale_[0] * this.pixelRatio) / this.imagePixelRatio_,
                (this.scale_[1] * this.pixelRatio) / this.imagePixelRatio_,
              ],
              Math.ceil(this.width_ * this.imagePixelRatio_),
              this.declutterMode_,
              this.declutterImageWithText_,
            ]),
              this.hitDetectionInstructions.push([
                la.DRAW_IMAGE,
                s,
                r,
                this.hitDetectionImage_,
                this.anchorX_,
                this.anchorY_,
                this.height_,
                1,
                this.originX_,
                this.originY_,
                this.rotateWithView_,
                this.rotation_,
                this.scale_,
                this.width_,
                this.declutterMode_,
                this.declutterImageWithText_,
              ]),
              this.endGeometry(e);
          }
          drawMultiPoint(t, e) {
            if (!this.image_) return;
            this.beginGeometry(t, e);
            const i = t.getFlatCoordinates(),
              n = t.getStride(),
              s = this.coordinates.length,
              r = this.appendFlatPointCoordinates(i, n);
            this.instructions.push([
              la.DRAW_IMAGE,
              s,
              r,
              this.image_,
              this.anchorX_ * this.imagePixelRatio_,
              this.anchorY_ * this.imagePixelRatio_,
              Math.ceil(this.height_ * this.imagePixelRatio_),
              this.opacity_,
              this.originX_ * this.imagePixelRatio_,
              this.originY_ * this.imagePixelRatio_,
              this.rotateWithView_,
              this.rotation_,
              [
                (this.scale_[0] * this.pixelRatio) / this.imagePixelRatio_,
                (this.scale_[1] * this.pixelRatio) / this.imagePixelRatio_,
              ],
              Math.ceil(this.width_ * this.imagePixelRatio_),
              this.declutterMode_,
              this.declutterImageWithText_,
            ]),
              this.hitDetectionInstructions.push([
                la.DRAW_IMAGE,
                s,
                r,
                this.hitDetectionImage_,
                this.anchorX_,
                this.anchorY_,
                this.height_,
                1,
                this.originX_,
                this.originY_,
                this.rotateWithView_,
                this.rotation_,
                this.scale_,
                this.width_,
                this.declutterMode_,
                this.declutterImageWithText_,
              ]),
              this.endGeometry(e);
          }
          finish() {
            return (
              this.reverseHitDetectionInstructions(),
              (this.anchorX_ = void 0),
              (this.anchorY_ = void 0),
              (this.hitDetectionImage_ = null),
              (this.image_ = null),
              (this.imagePixelRatio_ = void 0),
              (this.height_ = void 0),
              (this.scale_ = void 0),
              (this.opacity_ = void 0),
              (this.originX_ = void 0),
              (this.originY_ = void 0),
              (this.rotateWithView_ = void 0),
              (this.rotation_ = void 0),
              (this.width_ = void 0),
              super.finish()
            );
          }
          setImageStyle(t, e) {
            const i = t.getAnchor(),
              n = t.getSize(),
              s = t.getOrigin();
            (this.imagePixelRatio_ = t.getPixelRatio(this.pixelRatio)),
              (this.anchorX_ = i[0]),
              (this.anchorY_ = i[1]),
              (this.hitDetectionImage_ = t.getHitDetectionImage()),
              (this.image_ = t.getImage(this.pixelRatio)),
              (this.height_ = n[1]),
              (this.opacity_ = t.getOpacity()),
              (this.originX_ = s[0]),
              (this.originY_ = s[1]),
              (this.rotateWithView_ = t.getRotateWithView()),
              (this.rotation_ = t.getRotation()),
              (this.scale_ = t.getScaleArray()),
              (this.width_ = n[0]),
              (this.declutterMode_ = t.getDeclutterMode()),
              (this.declutterImageWithText_ = e);
          }
        },
        LineString: class extends ua {
          constructor(t, e, i, n) {
            super(t, e, i, n);
          }
          drawFlatCoordinates_(t, e, i, n) {
            const s = this.coordinates.length,
              r = this.appendFlatLineCoordinates(t, e, i, n, !1, !1),
              o = [la.MOVE_TO_LINE_TO, s, r];
            return this.instructions.push(o), this.hitDetectionInstructions.push(o), i;
          }
          drawLineString(t, e) {
            const i = this.state,
              n = i.strokeStyle,
              s = i.lineWidth;
            if (void 0 === n || void 0 === s) return;
            this.updateStrokeStyle(i, this.applyStroke),
              this.beginGeometry(t, e),
              this.hitDetectionInstructions.push(
                [la.SET_STROKE_STYLE, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, gs, 0],
                aa,
              );
            const r = t.getFlatCoordinates(),
              o = t.getStride();
            this.drawFlatCoordinates_(r, 0, r.length, o), this.hitDetectionInstructions.push(oa), this.endGeometry(e);
          }
          drawMultiLineString(t, e) {
            const i = this.state,
              n = i.strokeStyle,
              s = i.lineWidth;
            if (void 0 === n || void 0 === s) return;
            this.updateStrokeStyle(i, this.applyStroke),
              this.beginGeometry(t, e),
              this.hitDetectionInstructions.push(
                [la.SET_STROKE_STYLE, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, gs, 0],
                aa,
              );
            const r = t.getEnds(),
              o = t.getFlatCoordinates(),
              a = t.getStride();
            let h = 0;
            for (let t = 0, e = r.length; t < e; ++t) h = this.drawFlatCoordinates_(o, h, r[t], a);
            this.hitDetectionInstructions.push(oa), this.endGeometry(e);
          }
          finish() {
            const t = this.state;
            return (
              null != t.lastStroke && t.lastStroke != this.coordinates.length && this.instructions.push(oa),
              this.reverseHitDetectionInstructions(),
              (this.state = null),
              super.finish()
            );
          }
          applyStroke(t) {
            null != t.lastStroke &&
              t.lastStroke != this.coordinates.length &&
              (this.instructions.push(oa), (t.lastStroke = this.coordinates.length)),
              (t.lastStroke = 0),
              super.applyStroke(t),
              this.instructions.push(aa);
          }
        },
        Polygon: da,
        Text: class extends ua {
          constructor(t, e, i, n) {
            super(t, e, i, n),
              (this.labels_ = null),
              (this.text_ = ''),
              (this.textOffsetX_ = 0),
              (this.textOffsetY_ = 0),
              (this.textRotateWithView_ = void 0),
              (this.textRotation_ = 0),
              (this.textFillState_ = null),
              (this.fillStates = {}),
              (this.fillStates[us] = { fillStyle: us }),
              (this.textStrokeState_ = null),
              (this.strokeStates = {}),
              (this.textState_ = {}),
              (this.textStates = {}),
              (this.textKey_ = ''),
              (this.fillKey_ = ''),
              (this.strokeKey_ = ''),
              (this.declutterImageWithText_ = void 0);
          }
          finish() {
            const t = super.finish();
            return (
              (t.textStates = this.textStates),
              (t.fillStates = this.fillStates),
              (t.strokeStates = this.strokeStates),
              t
            );
          }
          drawText(t, e) {
            const i = this.textFillState_,
              n = this.textStrokeState_,
              s = this.textState_;
            if ('' === this.text_ || !s || (!i && !n)) return;
            const r = this.coordinates;
            let o = r.length;
            const a = t.getType();
            let h = null,
              l = t.getStride();
            if (
              'line' !== s.placement ||
              ('LineString' != a && 'MultiLineString' != a && 'Polygon' != a && 'MultiPolygon' != a)
            ) {
              let i = s.overflow ? null : [];
              switch (a) {
                case 'Point':
                case 'MultiPoint':
                  h = t.getFlatCoordinates();
                  break;
                case 'LineString':
                  h = t.getFlatMidpoint();
                  break;
                case 'Circle':
                  h = t.getCenter();
                  break;
                case 'MultiLineString':
                  (h = t.getFlatMidpoints()), (l = 2);
                  break;
                case 'Polygon':
                  (h = t.getFlatInteriorPoint()), s.overflow || i.push(h[2] / this.resolution), (l = 3);
                  break;
                case 'MultiPolygon':
                  const e = t.getFlatInteriorPoints();
                  h = [];
                  for (let t = 0, n = e.length; t < n; t += 3)
                    s.overflow || i.push(e[t + 2] / this.resolution), h.push(e[t], e[t + 1]);
                  if (0 === h.length) return;
                  l = 2;
              }
              const n = this.appendFlatPointCoordinates(h, l);
              if (n === o) return;
              if (i && (n - o) / 2 != h.length / l) {
                let t = o / 2;
                i = i.filter((e, i) => {
                  const n = r[2 * (t + i)] === h[i * l] && r[2 * (t + i) + 1] === h[i * l + 1];
                  return n || --t, n;
                });
              }
              this.saveTextStates_(),
                (s.backgroundFill || s.backgroundStroke) &&
                  (this.setFillStrokeStyle(s.backgroundFill, s.backgroundStroke),
                  s.backgroundFill && this.updateFillStyle(this.state, this.createFill),
                  s.backgroundStroke &&
                    (this.updateStrokeStyle(this.state, this.applyStroke),
                    this.hitDetectionInstructions.push(this.createStroke(this.state)))),
                this.beginGeometry(t, e);
              let c = s.padding;
              if (c != ys && (s.scale[0] < 0 || s.scale[1] < 0)) {
                let t = s.padding[0],
                  e = s.padding[1],
                  i = s.padding[2],
                  n = s.padding[3];
                s.scale[0] < 0 && ((e = -e), (n = -n)), s.scale[1] < 0 && ((t = -t), (i = -i)), (c = [t, e, i, n]);
              }
              const u = this.pixelRatio;
              this.instructions.push([
                la.DRAW_IMAGE,
                o,
                n,
                null,
                NaN,
                NaN,
                NaN,
                1,
                0,
                0,
                this.textRotateWithView_,
                this.textRotation_,
                [1, 1],
                NaN,
                void 0,
                this.declutterImageWithText_,
                c == ys
                  ? ys
                  : c.map(function (t) {
                      return t * u;
                    }),
                !!s.backgroundFill,
                !!s.backgroundStroke,
                this.text_,
                this.textKey_,
                this.strokeKey_,
                this.fillKey_,
                this.textOffsetX_,
                this.textOffsetY_,
                i,
              ]);
              const d = 1 / u,
                g = this.state.fillStyle;
              s.backgroundFill &&
                ((this.state.fillStyle = us), this.hitDetectionInstructions.push(this.createFill(this.state))),
                this.hitDetectionInstructions.push([
                  la.DRAW_IMAGE,
                  o,
                  n,
                  null,
                  NaN,
                  NaN,
                  NaN,
                  1,
                  0,
                  0,
                  this.textRotateWithView_,
                  this.textRotation_,
                  [d, d],
                  NaN,
                  void 0,
                  this.declutterImageWithText_,
                  c,
                  !!s.backgroundFill,
                  !!s.backgroundStroke,
                  this.text_,
                  this.textKey_,
                  this.strokeKey_,
                  this.fillKey_ ? us : this.fillKey_,
                  this.textOffsetX_,
                  this.textOffsetY_,
                  i,
                ]),
                s.backgroundFill &&
                  ((this.state.fillStyle = g), this.hitDetectionInstructions.push(this.createFill(this.state))),
                this.endGeometry(e);
            } else {
              if (!qt(this.getBufferedMaxExtent(), t.getExtent())) return;
              let i;
              if (((h = t.getFlatCoordinates()), 'LineString' == a)) i = [h.length];
              else if ('MultiLineString' == a) i = t.getEnds();
              else if ('Polygon' == a) i = t.getEnds().slice(0, 1);
              else if ('MultiPolygon' == a) {
                const e = t.getEndss();
                i = [];
                for (let t = 0, n = e.length; t < n; ++t) i.push(e[t][0]);
              }
              this.beginGeometry(t, e);
              const n = s.repeat,
                c = n ? void 0 : s.textAlign;
              let u = 0;
              for (let t = 0, e = i.length; t < e; ++t) {
                let e;
                e = n ? ga(n * this.resolution, h, u, i[t], l) : [h.slice(u, i[t])];
                for (let n = 0, a = e.length; n < a; ++n) {
                  const a = e[n];
                  let h = 0,
                    d = a.length;
                  if (null == c) {
                    const t = fa(s.maxAngle, a, 0, a.length, 2);
                    (h = t[0]), (d = t[1]);
                  }
                  for (let t = h; t < d; t += l) r.push(a[t], a[t + 1]);
                  const g = r.length;
                  (u = i[t]), this.drawChars_(o, g), (o = g);
                }
              }
              this.endGeometry(e);
            }
          }
          saveTextStates_() {
            const t = this.textStrokeState_,
              e = this.textState_,
              i = this.textFillState_,
              n = this.strokeKey_;
            t &&
              (n in this.strokeStates ||
                (this.strokeStates[n] = {
                  strokeStyle: t.strokeStyle,
                  lineCap: t.lineCap,
                  lineDashOffset: t.lineDashOffset,
                  lineWidth: t.lineWidth,
                  lineJoin: t.lineJoin,
                  miterLimit: t.miterLimit,
                  lineDash: t.lineDash,
                }));
            const s = this.textKey_;
            s in this.textStates ||
              (this.textStates[s] = {
                font: e.font,
                textAlign: e.textAlign || ps,
                justify: e.justify,
                textBaseline: e.textBaseline || ms,
                scale: e.scale,
              });
            const r = this.fillKey_;
            i && (r in this.fillStates || (this.fillStates[r] = { fillStyle: i.fillStyle }));
          }
          drawChars_(t, e) {
            const i = this.textStrokeState_,
              n = this.textState_,
              s = this.strokeKey_,
              r = this.textKey_,
              o = this.fillKey_;
            this.saveTextStates_();
            const a = this.pixelRatio,
              h = _a[n.textBaseline],
              l = this.textOffsetY_ * a,
              c = this.text_,
              u = i ? (i.lineWidth * Math.abs(n.scale[0])) / 2 : 0;
            this.instructions.push([la.DRAW_CHARS, t, e, h, n.overflow, o, n.maxAngle, a, l, s, u * a, c, r, 1]),
              this.hitDetectionInstructions.push([
                la.DRAW_CHARS,
                t,
                e,
                h,
                n.overflow,
                o ? us : o,
                n.maxAngle,
                a,
                l,
                s,
                u * a,
                c,
                r,
                1 / a,
              ]);
          }
          setTextStyle(t, e) {
            let i, n, s;
            if (t) {
              const e = t.getFill();
              e
                ? ((n = this.textFillState_),
                  n || ((n = {}), (this.textFillState_ = n)),
                  (n.fillStyle = zr(e.getColor() || us)))
                : ((n = null), (this.textFillState_ = n));
              const r = t.getStroke();
              if (r) {
                (s = this.textStrokeState_), s || ((s = {}), (this.textStrokeState_ = s));
                const t = r.getLineDash(),
                  e = r.getLineDashOffset(),
                  i = r.getWidth(),
                  n = r.getMiterLimit();
                (s.lineCap = r.getLineCap() || ds),
                  (s.lineDash = t ? t.slice() : gs),
                  (s.lineDashOffset = void 0 === e ? 0 : e),
                  (s.lineJoin = r.getLineJoin() || fs),
                  (s.lineWidth = void 0 === i ? 1 : i),
                  (s.miterLimit = void 0 === n ? 10 : n),
                  (s.strokeStyle = zr(r.getColor() || _s));
              } else (s = null), (this.textStrokeState_ = s);
              i = this.textState_;
              const o = t.getFont() || cs;
              Ss(o);
              const a = t.getScaleArray();
              (i.overflow = t.getOverflow()),
                (i.font = o),
                (i.maxAngle = t.getMaxAngle()),
                (i.placement = t.getPlacement()),
                (i.textAlign = t.getTextAlign()),
                (i.repeat = t.getRepeat()),
                (i.justify = t.getJustify()),
                (i.textBaseline = t.getTextBaseline() || ms),
                (i.backgroundFill = t.getBackgroundFill()),
                (i.backgroundStroke = t.getBackgroundStroke()),
                (i.padding = t.getPadding() || ys),
                (i.scale = void 0 === a ? [1, 1] : a);
              const h = t.getOffsetX(),
                l = t.getOffsetY(),
                c = t.getRotateWithView(),
                u = t.getRotation();
              (this.text_ = t.getText() || ''),
                (this.textOffsetX_ = void 0 === h ? 0 : h),
                (this.textOffsetY_ = void 0 === l ? 0 : l),
                (this.textRotateWithView_ = void 0 !== c && c),
                (this.textRotation_ = void 0 === u ? 0 : u),
                (this.strokeKey_ = s
                  ? ('string' == typeof s.strokeStyle ? s.strokeStyle : U(s.strokeStyle)) +
                    s.lineCap +
                    s.lineDashOffset +
                    '|' +
                    s.lineWidth +
                    s.lineJoin +
                    s.miterLimit +
                    '[' +
                    s.lineDash.join() +
                    ']'
                  : ''),
                (this.textKey_ =
                  i.font +
                  i.scale +
                  (i.textAlign || '?') +
                  (i.repeat || '?') +
                  (i.justify || '?') +
                  (i.textBaseline || '?')),
                (this.fillKey_ = n ? ('string' == typeof n.fillStyle ? n.fillStyle : '|' + U(n.fillStyle)) : '');
            } else this.text_ = '';
            this.declutterImageWithText_ = e;
          }
        },
      },
      ma = class {
        constructor(t, e, i, n) {
          (this.tolerance_ = t),
            (this.maxExtent_ = e),
            (this.pixelRatio_ = n),
            (this.resolution_ = i),
            (this.buildersByZIndex_ = {});
        }
        finish() {
          const t = {};
          for (const e in this.buildersByZIndex_) {
            t[e] = t[e] || {};
            const i = this.buildersByZIndex_[e];
            for (const n in i) {
              const s = i[n].finish();
              t[e][n] = s;
            }
          }
          return t;
        }
        getBuilder(t, e) {
          const i = void 0 !== t ? t.toString() : '0';
          let n = this.buildersByZIndex_[i];
          void 0 === n && ((n = {}), (this.buildersByZIndex_[i] = n));
          let s = n[e];
          return (
            void 0 === s &&
              ((s = new (0, pa[e])(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_)), (n[e] = s)),
            s
          );
        }
      },
      ya = class extends Z {
        constructor(t) {
          super(),
            (this.ready = !0),
            (this.boundHandleImageChange_ = this.handleImageChange_.bind(this)),
            (this.layer_ = t),
            (this.declutterExecutorGroup = null);
        }
        getFeatures(t) {
          return V();
        }
        getData(t) {
          return null;
        }
        prepareFrame(t) {
          return V();
        }
        renderFrame(t, e) {
          return V();
        }
        loadedTileCallback(t, e, i) {
          t[e] || (t[e] = {}), (t[e][i.tileCoord.toString()] = i);
        }
        createLoadedTileFinder(t, e, i) {
          return (n, s) => {
            const r = this.loadedTileCallback.bind(this, i, n);
            return t.forEachLoadedTile(e, n, s, r);
          };
        }
        forEachFeatureAtCoordinate(t, e, i, n, s) {}
        getLayer() {
          return this.layer_;
        }
        handleFontsChanged() {}
        handleImageChange_(t) {
          const e = t.target;
          (2 !== e.getState() && 3 !== e.getState()) || this.renderIfReadyAndVisible();
        }
        loadImage(t) {
          let e = t.getState();
          return (
            2 != e && 3 != e && t.addEventListener(O, this.boundHandleImageChange_),
            0 == e && (t.load(), (e = t.getState())),
            2 == e
          );
        }
        renderIfReadyAndVisible() {
          const t = this.getLayer();
          t && t.getVisible() && 'ready' === t.getSourceState() && t.changed();
        }
        disposeInternal() {
          delete this.layer_, super.disposeInternal();
        }
      },
      va = [];
    let xa = null;
    const wa = class extends ya {
      constructor(t) {
        super(t),
          (this.container = null),
          this.renderedResolution,
          (this.tempTransform = [1, 0, 0, 1, 0, 0]),
          (this.pixelTransform = [1, 0, 0, 1, 0, 0]),
          (this.inversePixelTransform = [1, 0, 0, 1, 0, 0]),
          (this.context = null),
          (this.containerReused = !1),
          (this.pixelContext_ = null),
          (this.frameState = null);
      }
      getImageData(t, e, i) {
        let n;
        xa || (xa = os(1, 1, void 0, { willReadFrequently: !0 })), xa.clearRect(0, 0, 1, 1);
        try {
          xa.drawImage(t, e, i, 1, 1, 0, 0, 1, 1), (n = xa.getImageData(0, 0, 1, 1).data);
        } catch (t) {
          return (xa = null), null;
        }
        return n;
      }
      getBackground(t) {
        let e = this.getLayer().getBackground();
        return 'function' == typeof e && (e = e(t.viewState.resolution)), e || void 0;
      }
      useContainer(t, e, i) {
        const n = this.getLayer().getClassName();
        let s, r;
        if (t && t.className === n && (!i || (t && t.style.backgroundColor && I(Mn(t.style.backgroundColor), Mn(i))))) {
          const e = t.firstElementChild;
          e instanceof HTMLCanvasElement && (r = e.getContext('2d'));
        }
        if (
          (r && r.canvas.style.transform === e
            ? ((this.container = t), (this.context = r), (this.containerReused = !0))
            : this.containerReused
              ? ((this.container = null), (this.context = null), (this.containerReused = !1))
              : this.container && (this.container.style.backgroundColor = null),
          !this.container)
        ) {
          (s = document.createElement('div')), (s.className = n);
          let t = s.style;
          (t.position = 'absolute'), (t.width = '100%'), (t.height = '100%'), (r = os());
          const e = r.canvas;
          s.appendChild(e),
            (t = e.style),
            (t.position = 'absolute'),
            (t.left = '0'),
            (t.transformOrigin = 'top left'),
            (this.container = s),
            (this.context = r);
        }
        this.containerReused ||
          !i ||
          this.container.style.backgroundColor ||
          (this.container.style.backgroundColor = i);
      }
      clipUnrotated(t, e, i) {
        const n = Kt(i),
          s = Zt(i),
          r = Nt(i),
          o = Gt(i);
        oi(e.coordinateToPixelTransform, n),
          oi(e.coordinateToPixelTransform, s),
          oi(e.coordinateToPixelTransform, r),
          oi(e.coordinateToPixelTransform, o);
        const a = this.inversePixelTransform;
        oi(a, n),
          oi(a, s),
          oi(a, r),
          oi(a, o),
          t.save(),
          t.beginPath(),
          t.moveTo(Math.round(n[0]), Math.round(n[1])),
          t.lineTo(Math.round(s[0]), Math.round(s[1])),
          t.lineTo(Math.round(r[0]), Math.round(r[1])),
          t.lineTo(Math.round(o[0]), Math.round(o[1])),
          t.clip();
      }
      dispatchRenderEvent_(t, e, i) {
        const n = this.getLayer();
        if (n.hasListener(t)) {
          const s = new Jn(t, this.inversePixelTransform, i, e);
          n.dispatchEvent(s);
        }
      }
      preRender(t, e) {
        (this.frameState = e), this.dispatchRenderEvent_(Bn, t, e);
      }
      postRender(t, e) {
        this.dispatchRenderEvent_(Kn, t, e);
      }
      getRenderTransform(t, e, i, n, s, r, o) {
        const a = s / 2,
          h = r / 2,
          l = n / e,
          c = -l,
          u = -t[0] + o,
          d = -t[1];
        return ai(this.tempTransform, a, h, l, c, -i, u, d);
      }
      disposeInternal() {
        delete this.frameState, super.disposeInternal();
      }
    };
    function Ca(t, e, i, n, s, r, o, a, h, l, c, u) {
      let d = t[e],
        g = t[e + 1],
        f = 0,
        _ = 0,
        p = 0,
        m = 0;
      function y() {
        (f = d),
          (_ = g),
          (d = t[(e += n)]),
          (g = t[e + 1]),
          (m += p),
          (p = Math.sqrt((d - f) * (d - f) + (g - _) * (g - _)));
      }
      do {
        y();
      } while (e < i - n && m + p < r);
      let v = 0 === p ? 0 : (r - m) / p;
      const x = ae(f, d, v),
        w = ae(_, g, v),
        C = e - n,
        S = m,
        E = r + a * h(l, s, c);
      for (; e < i - n && m + p < E; ) y();
      v = 0 === p ? 0 : (E - m) / p;
      const T = ae(f, d, v),
        b = ae(_, g, v);
      let I;
      if (u) {
        const t = [x, w, T, b];
        di(t, 0, 4, 2, u, t, t), (I = t[0] > t[2]);
      } else I = x > T;
      const R = Math.PI,
        M = [],
        P = C + n === e;
      let L;
      if (((p = 0), (m = S), (d = t[(e = C)]), (g = t[e + 1]), P)) {
        y(), (L = Math.atan2(g - _, d - f)), I && (L += L > 0 ? -R : R);
        const t = (T + x) / 2,
          e = (b + w) / 2;
        return (M[0] = [t, e, (E - r) / 2, L, s]), M;
      }
      for (let t = 0, u = (s = s.replace(/\n/g, ' ')).length; t < u; ) {
        y();
        let x = Math.atan2(g - _, d - f);
        if ((I && (x += x > 0 ? -R : R), void 0 !== L)) {
          let t = x - L;
          if (((t += t > R ? -2 * R : t < -R ? 2 * R : 0), Math.abs(t) > o)) return null;
        }
        L = x;
        const w = t;
        let C = 0;
        for (; t < u; ++t) {
          const o = a * h(l, s[I ? u - t - 1 : t], c);
          if (e + n < i && m + p < r + C + o / 2) break;
          C += o;
        }
        if (t === w) continue;
        const S = I ? s.substring(u - w, u - t) : s.substring(w, t);
        v = 0 === p ? 0 : (r + C / 2 - m) / p;
        const E = ae(f, d, v),
          T = ae(_, g, v);
        M.push([E, T, C / 2, x, S]), (r += C);
      }
      return M;
    }
    function Sa(t, e, i, n) {
      let s = t[e],
        r = t[e + 1],
        o = 0;
      for (let a = e + n; a < i; a += n) {
        const e = t[a],
          i = t[a + 1];
        (o += Math.sqrt((e - s) * (e - s) + (i - r) * (i - r))), (s = e), (r = i);
      }
      return o;
    }
    const Ea = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
      Ta = [],
      ba = [],
      Ia = [],
      Ra = [];
    function Ma(t) {
      return t[3].declutterBox;
    }
    const Pa = new RegExp(
      '[' +
        String.fromCharCode(1425) +
        '-' +
        String.fromCharCode(2303) +
        String.fromCharCode(64285) +
        '-' +
        String.fromCharCode(65023) +
        String.fromCharCode(65136) +
        '-' +
        String.fromCharCode(65276) +
        String.fromCharCode(67584) +
        '-' +
        String.fromCharCode(69631) +
        String.fromCharCode(124928) +
        '-' +
        String.fromCharCode(126975) +
        ']',
    );
    function La(t, e) {
      return (
        'start' === e ? (e = Pa.test(t) ? 'right' : 'left') : 'end' === e && (e = Pa.test(t) ? 'left' : 'right'), _a[e]
      );
    }
    function Fa(t, e, i) {
      return i > 0 && t.push('\n', ''), t.push(e, ''), t;
    }
    const ka = class {
        constructor(t, e, i, n) {
          (this.overlaps = i),
            (this.pixelRatio = e),
            (this.resolution = t),
            this.alignFill_,
            (this.instructions = n.instructions),
            (this.coordinates = n.coordinates),
            (this.coordinateCache_ = {}),
            (this.renderedTransform_ = [1, 0, 0, 1, 0, 0]),
            (this.hitDetectionInstructions = n.hitDetectionInstructions),
            (this.pixelCoordinates_ = null),
            (this.viewRotation_ = 0),
            (this.fillStates = n.fillStates || {}),
            (this.strokeStates = n.strokeStates || {}),
            (this.textStates = n.textStates || {}),
            (this.widths_ = {}),
            (this.labels_ = {});
        }
        createLabel(t, e, i, n) {
          const s = t + e + i + n;
          if (this.labels_[s]) return this.labels_[s];
          const r = n ? this.strokeStates[n] : null,
            o = i ? this.fillStates[i] : null,
            a = this.textStates[e],
            h = this.pixelRatio,
            l = [a.scale[0] * h, a.scale[1] * h],
            c = Array.isArray(t),
            u = a.justify ? _a[a.justify] : La(Array.isArray(t) ? t[0] : t, a.textAlign || ps),
            d = n && r.lineWidth ? r.lineWidth : 0,
            g = c ? t : t.split('\n').reduce(Fa, []),
            {
              width: f,
              height: _,
              widths: p,
              heights: m,
              lineWidths: y,
            } = (function (t, e) {
              const i = [],
                n = [],
                s = [];
              let r = 0,
                o = 0,
                a = 0,
                h = 0;
              for (let l = 0, c = e.length; l <= c; l += 2) {
                const u = e[l];
                if ('\n' === u || l === c) {
                  (r = Math.max(r, o)), s.push(o), (o = 0), (a += h);
                  continue;
                }
                const d = e[l + 1] || t.font,
                  g = bs(d, u);
                i.push(g), (o += g);
                const f = Es(d);
                n.push(f), (h = Math.max(h, f));
              }
              return { width: r, height: a, widths: i, heights: n, lineWidths: s };
            })(a, g),
            v = f + d,
            x = [],
            w = (v + 2) * l[0],
            C = (_ + d) * l[1],
            S = {
              width: w < 0 ? Math.floor(w) : Math.ceil(w),
              height: C < 0 ? Math.floor(C) : Math.ceil(C),
              contextInstructions: x,
            };
          (1 == l[0] && 1 == l[1]) || x.push('scale', l),
            n &&
              (x.push('strokeStyle', r.strokeStyle),
              x.push('lineWidth', d),
              x.push('lineCap', r.lineCap),
              x.push('lineJoin', r.lineJoin),
              x.push('miterLimit', r.miterLimit),
              x.push('setLineDash', [r.lineDash]),
              x.push('lineDashOffset', r.lineDashOffset)),
            i && x.push('fillStyle', o.fillStyle),
            x.push('textBaseline', 'middle'),
            x.push('textAlign', 'center');
          const E = 0.5 - u;
          let T = u * v + E * d;
          const b = [],
            I = [];
          let R,
            M = 0,
            P = 0,
            L = 0,
            F = 0;
          for (let t = 0, e = g.length; t < e; t += 2) {
            const e = g[t];
            if ('\n' === e) {
              (P += M), (M = 0), (T = u * v + E * d), ++F;
              continue;
            }
            const s = g[t + 1] || a.font;
            s !== R && (n && b.push('font', s), i && I.push('font', s), (R = s)), (M = Math.max(M, m[L]));
            const r = [e, T + E * p[L] + u * (p[L] - y[F]), 0.5 * (d + M) + P];
            (T += p[L]), n && b.push('strokeText', r), i && I.push('fillText', r), ++L;
          }
          return Array.prototype.push.apply(x, b), Array.prototype.push.apply(x, I), (this.labels_[s] = S), S;
        }
        replayTextBackground_(t, e, i, n, s, r, o) {
          t.beginPath(),
            t.moveTo.apply(t, e),
            t.lineTo.apply(t, i),
            t.lineTo.apply(t, n),
            t.lineTo.apply(t, s),
            t.lineTo.apply(t, e),
            r && ((this.alignFill_ = r[2]), this.fill_(t)),
            o && (this.setStrokeStyle_(t, o), t.stroke());
        }
        calculateImageOrLabelDimensions_(t, e, i, n, s, r, o, a, h, l, c, u, d, g, f, _) {
          let p = i - (o *= u[0]),
            m = n - (a *= u[1]);
          const y = s + h > t ? t - h : s,
            v = r + l > e ? e - l : r,
            x = g[3] + y * u[0] + g[1],
            w = g[0] + v * u[1] + g[2],
            C = p - g[3],
            S = m - g[0];
          let E;
          return (
            (f || 0 !== c) &&
              ((Ta[0] = C),
              (Ra[0] = C),
              (Ta[1] = S),
              (ba[1] = S),
              (ba[0] = C + x),
              (Ia[0] = ba[0]),
              (Ia[1] = S + w),
              (Ra[1] = Ia[1])),
            0 !== c
              ? ((E = ai([1, 0, 0, 1, 0, 0], i, n, 1, 1, c, -i, -n)),
                oi(E, Ta),
                oi(E, ba),
                oi(E, Ia),
                oi(E, Ra),
                bt(
                  Math.min(Ta[0], ba[0], Ia[0], Ra[0]),
                  Math.min(Ta[1], ba[1], Ia[1], Ra[1]),
                  Math.max(Ta[0], ba[0], Ia[0], Ra[0]),
                  Math.max(Ta[1], ba[1], Ia[1], Ra[1]),
                  Ea,
                ))
              : bt(Math.min(C, C + x), Math.min(S, S + w), Math.max(C, C + x), Math.max(S, S + w), Ea),
            d && ((p = Math.round(p)), (m = Math.round(m))),
            {
              drawImageX: p,
              drawImageY: m,
              drawImageW: y,
              drawImageH: v,
              originX: h,
              originY: l,
              declutterBox: { minX: Ea[0], minY: Ea[1], maxX: Ea[2], maxY: Ea[3], value: _ },
              canvasTransform: E,
              scale: u,
            }
          );
        }
        replayImageOrLabel_(t, e, i, n, s, r, o) {
          const a = !(!r && !o),
            h = n.declutterBox,
            l = t.canvas,
            c = o ? (o[2] * n.scale[0]) / 2 : 0;
          return (
            h.minX - c <= l.width / e &&
              h.maxX + c >= 0 &&
              h.minY - c <= l.height / e &&
              h.maxY + c >= 0 &&
              (a && this.replayTextBackground_(t, Ta, ba, Ia, Ra, r, o),
              (function (t, e, i, n, s, r, o, a, h, l, c) {
                t.save(),
                  1 !== i && (t.globalAlpha *= i),
                  e && t.transform.apply(t, e),
                  n.contextInstructions
                    ? (t.translate(h, l),
                      t.scale(c[0], c[1]),
                      (function (t, e) {
                        const i = t.contextInstructions;
                        for (let t = 0, n = i.length; t < n; t += 2)
                          Array.isArray(i[t + 1]) ? e[i[t]].apply(e, i[t + 1]) : (e[i[t]] = i[t + 1]);
                      })(n, t))
                    : c[0] < 0 || c[1] < 0
                      ? (t.translate(h, l), t.scale(c[0], c[1]), t.drawImage(n, s, r, o, a, 0, 0, o, a))
                      : t.drawImage(n, s, r, o, a, h, l, o * c[0], a * c[1]),
                  t.restore();
              })(
                t,
                n.canvasTransform,
                s,
                i,
                n.originX,
                n.originY,
                n.drawImageW,
                n.drawImageH,
                n.drawImageX,
                n.drawImageY,
                n.scale,
              )),
            !0
          );
        }
        fill_(t) {
          if (this.alignFill_) {
            const e = oi(this.renderedTransform_, [0, 0]),
              i = 512 * this.pixelRatio;
            t.save(), t.translate(e[0] % i, e[1] % i), t.rotate(this.viewRotation_);
          }
          t.fill(), this.alignFill_ && t.restore();
        }
        setStrokeStyle_(t, e) {
          (t.strokeStyle = e[1]),
            (t.lineWidth = e[2]),
            (t.lineCap = e[3]),
            (t.lineJoin = e[4]),
            (t.miterLimit = e[5]),
            (t.lineDashOffset = e[7]),
            t.setLineDash(e[6]);
        }
        drawLabelWithPointPlacement_(t, e, i, n) {
          const s = this.textStates[e],
            r = this.createLabel(t, e, n, i),
            o = this.strokeStates[i],
            a = this.pixelRatio,
            h = La(Array.isArray(t) ? t[0] : t, s.textAlign || ps),
            l = _a[s.textBaseline || ms],
            c = o && o.lineWidth ? o.lineWidth : 0;
          return {
            label: r,
            anchorX: h * (r.width / a - 2 * s.scale[0]) + 2 * (0.5 - h) * c,
            anchorY: (l * r.height) / a + 2 * (0.5 - l) * c,
          };
        }
        execute_(t, e, i, n, s, r, o, a) {
          let h;
          var l, c;
          this.pixelCoordinates_ && I(i, this.renderedTransform_)
            ? (h = this.pixelCoordinates_)
            : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []),
              (h = ui(this.coordinates, 0, this.coordinates.length, 2, i, this.pixelCoordinates_)),
              (c = i),
              ((l = this.renderedTransform_)[0] = c[0]),
              (l[1] = c[1]),
              (l[2] = c[2]),
              (l[3] = c[3]),
              (l[4] = c[4]),
              (l[5] = c[5]));
          let u = 0;
          const d = n.length;
          let g,
            f,
            _,
            p,
            m,
            y,
            v,
            x,
            w,
            C,
            S,
            E,
            T = 0,
            b = 0,
            R = 0,
            M = null,
            P = null;
          const L = this.coordinateCache_,
            F = this.viewRotation_,
            k = Math.round(1e12 * Math.atan2(-i[1], i[0])) / 1e12,
            A = { context: t, pixelRatio: this.pixelRatio, resolution: this.resolution, rotation: F },
            O = this.instructions != n || this.overlaps ? 0 : 200;
          let D, G, N, z;
          for (; u < d; ) {
            const i = n[u];
            switch (i[0]) {
              case la.BEGIN_GEOMETRY:
                (D = i[1]),
                  (z = i[3]),
                  D.getGeometry() ? (void 0 === o || qt(o, z.getExtent()) ? ++u : (u = i[2] + 1)) : (u = i[2]);
                break;
              case la.BEGIN_PATH:
                b > O && (this.fill_(t), (b = 0)),
                  R > O && (t.stroke(), (R = 0)),
                  b || R || (t.beginPath(), (p = NaN), (m = NaN)),
                  ++u;
                break;
              case la.CIRCLE:
                T = i[1];
                const n = h[T],
                  l = h[T + 1],
                  c = h[T + 2] - n,
                  d = h[T + 3] - l,
                  I = Math.sqrt(c * c + d * d);
                t.moveTo(n + I, l), t.arc(n, l, I, 0, 2 * Math.PI, !0), ++u;
                break;
              case la.CLOSE_PATH:
                t.closePath(), ++u;
                break;
              case la.CUSTOM:
                (T = i[1]), (g = i[2]);
                const W = i[3],
                  X = i[4],
                  j = 6 == i.length ? i[5] : void 0;
                (A.geometry = W), (A.feature = D), u in L || (L[u] = []);
                const Y = L[u];
                j ? j(h, T, g, 2, Y) : ((Y[0] = h[T]), (Y[1] = h[T + 1]), (Y.length = 2)), X(Y, A), ++u;
                break;
              case la.DRAW_IMAGE:
                (T = i[1]), (g = i[2]), (x = i[3]), (f = i[4]), (_ = i[5]);
                let B = i[6];
                const K = i[7],
                  Z = i[8],
                  V = i[9],
                  q = i[10];
                let U = i[11];
                const H = i[12];
                let $ = i[13];
                const J = i[14],
                  Q = i[15];
                if (!x && i.length >= 20) {
                  (w = i[19]), (C = i[20]), (S = i[21]), (E = i[22]);
                  const t = this.drawLabelWithPointPlacement_(w, C, S, E);
                  (x = t.label), (i[3] = x);
                  const e = i[23];
                  (f = (t.anchorX - e) * this.pixelRatio), (i[4] = f);
                  const n = i[24];
                  (_ = (t.anchorY - n) * this.pixelRatio),
                    (i[5] = _),
                    (B = x.height),
                    (i[6] = B),
                    ($ = x.width),
                    (i[13] = $);
                }
                let tt, et, it, nt;
                i.length > 25 && (tt = i[25]),
                  i.length > 17 ? ((et = i[16]), (it = i[17]), (nt = i[18])) : ((et = ys), (it = !1), (nt = !1)),
                  q && k ? (U += F) : q || k || (U -= F);
                let st = 0;
                for (; T < g; T += 2) {
                  if (tt && tt[st++] < $ / this.pixelRatio) continue;
                  const i = this.calculateImageOrLabelDimensions_(
                      x.width,
                      x.height,
                      h[T],
                      h[T + 1],
                      $,
                      B,
                      f,
                      _,
                      Z,
                      V,
                      U,
                      H,
                      s,
                      et,
                      it || nt,
                      D,
                    ),
                    n = [t, e, x, i, K, it ? M : null, nt ? P : null];
                  if (a) {
                    if ('none' === J) continue;
                    if ('obstacle' === J) {
                      a.insert(i.declutterBox);
                      continue;
                    }
                    {
                      let t, e;
                      if (Q) {
                        const i = g - T;
                        if (!Q[i]) {
                          Q[i] = n;
                          continue;
                        }
                        if (((t = Q[i]), delete Q[i], (e = Ma(t)), a.collides(e))) continue;
                      }
                      if (a.collides(i.declutterBox)) continue;
                      t && (a.insert(e), this.replayImageOrLabel_.apply(this, t)), a.insert(i.declutterBox);
                    }
                  }
                  this.replayImageOrLabel_.apply(this, n);
                }
                ++u;
                break;
              case la.DRAW_CHARS:
                const rt = i[1],
                  ot = i[2],
                  at = i[3],
                  ht = i[4];
                E = i[5];
                const lt = i[6],
                  ct = i[7],
                  ut = i[8];
                S = i[9];
                const dt = i[10];
                (w = i[11]), (C = i[12]);
                const gt = [i[13], i[13]],
                  ft = this.textStates[C],
                  _t = ft.font,
                  pt = [ft.scale[0] * ct, ft.scale[1] * ct];
                let mt;
                _t in this.widths_ ? (mt = this.widths_[_t]) : ((mt = {}), (this.widths_[_t] = mt));
                const yt = Sa(h, rt, ot, 2),
                  vt = Math.abs(pt[0]) * Is(_t, w, mt);
                if (ht || vt <= yt) {
                  const i = Ca(
                    h,
                    rt,
                    ot,
                    2,
                    w,
                    (yt - vt) * La(w, this.textStates[C].textAlign),
                    lt,
                    Math.abs(pt[0]),
                    Is,
                    _t,
                    mt,
                    k ? 0 : this.viewRotation_,
                  );
                  t: if (i) {
                    const n = [];
                    let s, r, o, h, l;
                    if (S)
                      for (s = 0, r = i.length; s < r; ++s) {
                        (l = i[s]),
                          (o = l[4]),
                          (h = this.createLabel(o, C, '', S)),
                          (f = l[2] + (pt[0] < 0 ? -dt : dt)),
                          (_ = at * h.height + (2 * (0.5 - at) * dt * pt[1]) / pt[0] - ut);
                        const r = this.calculateImageOrLabelDimensions_(
                          h.width,
                          h.height,
                          l[0],
                          l[1],
                          h.width,
                          h.height,
                          f,
                          _,
                          0,
                          0,
                          l[3],
                          gt,
                          !1,
                          ys,
                          !1,
                          D,
                        );
                        if (a && a.collides(r.declutterBox)) break t;
                        n.push([t, e, h, r, 1, null, null]);
                      }
                    if (E)
                      for (s = 0, r = i.length; s < r; ++s) {
                        (l = i[s]),
                          (o = l[4]),
                          (h = this.createLabel(o, C, E, '')),
                          (f = l[2]),
                          (_ = at * h.height - ut);
                        const r = this.calculateImageOrLabelDimensions_(
                          h.width,
                          h.height,
                          l[0],
                          l[1],
                          h.width,
                          h.height,
                          f,
                          _,
                          0,
                          0,
                          l[3],
                          gt,
                          !1,
                          ys,
                          !1,
                          D,
                        );
                        if (a && a.collides(r.declutterBox)) break t;
                        n.push([t, e, h, r, 1, null, null]);
                      }
                    a && a.load(n.map(Ma));
                    for (let t = 0, e = n.length; t < e; ++t) this.replayImageOrLabel_.apply(this, n[t]);
                  }
                }
                ++u;
                break;
              case la.END_GEOMETRY:
                if (void 0 !== r) {
                  D = i[1];
                  const t = r(D, z);
                  if (t) return t;
                }
                ++u;
                break;
              case la.FILL:
                O ? b++ : this.fill_(t), ++u;
                break;
              case la.MOVE_TO_LINE_TO:
                for (
                  T = i[1],
                    g = i[2],
                    G = h[T],
                    N = h[T + 1],
                    y = (G + 0.5) | 0,
                    v = (N + 0.5) | 0,
                    (y === p && v === m) || (t.moveTo(G, N), (p = y), (m = v)),
                    T += 2;
                  T < g;
                  T += 2
                )
                  (G = h[T]),
                    (N = h[T + 1]),
                    (y = (G + 0.5) | 0),
                    (v = (N + 0.5) | 0),
                    (T != g - 2 && y === p && v === m) || (t.lineTo(G, N), (p = y), (m = v));
                ++u;
                break;
              case la.SET_FILL_STYLE:
                (M = i),
                  (this.alignFill_ = i[2]),
                  b && (this.fill_(t), (b = 0), R && (t.stroke(), (R = 0))),
                  (t.fillStyle = i[1]),
                  ++u;
                break;
              case la.SET_STROKE_STYLE:
                (P = i), R && (t.stroke(), (R = 0)), this.setStrokeStyle_(t, i), ++u;
                break;
              case la.STROKE:
                O ? R++ : t.stroke(), ++u;
                break;
              default:
                ++u;
            }
          }
          b && this.fill_(t), R && t.stroke();
        }
        execute(t, e, i, n, s, r) {
          (this.viewRotation_ = n), this.execute_(t, e, i, this.instructions, s, void 0, void 0, r);
        }
        executeHitDetection(t, e, i, n, s) {
          return (this.viewRotation_ = i), this.execute_(t, 1, e, this.hitDetectionInstructions, !0, n, s);
        }
      },
      Aa = ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'],
      Oa = {},
      Da = class {
        constructor(t, e, i, n, s, r) {
          (this.maxExtent_ = t),
            (this.overlaps_ = n),
            (this.pixelRatio_ = i),
            (this.resolution_ = e),
            (this.renderBuffer_ = r),
            (this.executorsByZIndex_ = {}),
            (this.hitDetectionContext_ = null),
            (this.hitDetectionTransform_ = [1, 0, 0, 1, 0, 0]),
            this.createExecutors_(s);
        }
        clip(t, e) {
          const i = this.getClipCoords(e);
          t.beginPath(),
            t.moveTo(i[0], i[1]),
            t.lineTo(i[2], i[3]),
            t.lineTo(i[4], i[5]),
            t.lineTo(i[6], i[7]),
            t.clip();
        }
        createExecutors_(t) {
          for (const e in t) {
            let i = this.executorsByZIndex_[e];
            void 0 === i && ((i = {}), (this.executorsByZIndex_[e] = i));
            const n = t[e];
            for (const t in n) {
              const e = n[t];
              i[t] = new ka(this.resolution_, this.pixelRatio_, this.overlaps_, e);
            }
          }
        }
        hasExecutors(t) {
          for (const e in this.executorsByZIndex_) {
            const i = this.executorsByZIndex_[e];
            for (let e = 0, n = t.length; e < n; ++e) if (t[e] in i) return !0;
          }
          return !1;
        }
        forEachFeatureAtCoordinate(t, e, i, n, s, r) {
          const o = 2 * (n = Math.round(n)) + 1,
            a = ai(this.hitDetectionTransform_, n + 0.5, n + 0.5, 1 / e, -1 / e, -i, -t[0], -t[1]),
            h = !this.hitDetectionContext_;
          h && (this.hitDetectionContext_ = os(o, o, void 0, { willReadFrequently: !0 }));
          const l = this.hitDetectionContext_;
          let c;
          l.canvas.width !== o || l.canvas.height !== o
            ? ((l.canvas.width = o), (l.canvas.height = o))
            : h || l.clearRect(0, 0, o, o),
            void 0 !== this.renderBuffer_ &&
              ((c = [1 / 0, 1 / 0, -1 / 0, -1 / 0]), Ft(c, t), vt(c, e * (this.renderBuffer_ + n), c));
          const u = (function (t) {
            if (void 0 !== Oa[t]) return Oa[t];
            const e = 2 * t + 1,
              i = t * t,
              n = new Array(i + 1);
            for (let s = 0; s <= t; ++s)
              for (let r = 0; r <= t; ++r) {
                const o = s * s + r * r;
                if (o > i) break;
                let a = n[o];
                a || ((a = []), (n[o] = a)),
                  a.push(4 * ((t + s) * e + (t + r)) + 3),
                  s > 0 && a.push(4 * ((t - s) * e + (t + r)) + 3),
                  r > 0 && (a.push(4 * ((t + s) * e + (t - r)) + 3), s > 0 && a.push(4 * ((t - s) * e + (t - r)) + 3));
              }
            const s = [];
            for (let t = 0, e = n.length; t < e; ++t) n[t] && s.push(...n[t]);
            return (Oa[t] = s), s;
          })(n);
          let d;
          function g(t, e) {
            const i = l.getImageData(0, 0, o, o).data;
            for (let a = 0, h = u.length; a < h; a++)
              if (i[u[a]] > 0) {
                if (!r || ('Image' !== d && 'Text' !== d) || r.includes(t)) {
                  const i = (u[a] - 3) / 4,
                    r = n - (i % o),
                    h = n - ((i / o) | 0),
                    l = s(t, e, r * r + h * h);
                  if (l) return l;
                }
                l.clearRect(0, 0, o, o);
                break;
              }
          }
          const f = Object.keys(this.executorsByZIndex_).map(Number);
          let _, p, m, y, v;
          for (f.sort(S), _ = f.length - 1; _ >= 0; --_) {
            const t = f[_].toString();
            for (m = this.executorsByZIndex_[t], p = Aa.length - 1; p >= 0; --p)
              if (((d = Aa[p]), (y = m[d]), void 0 !== y && ((v = y.executeHitDetection(l, a, i, g, c)), v))) return v;
          }
        }
        getClipCoords(t) {
          const e = this.maxExtent_;
          if (!e) return null;
          const i = e[0],
            n = e[1],
            s = e[2],
            r = e[3],
            o = [i, n, i, r, s, r, s, n];
          return ui(o, 0, 8, 2, t, o), o;
        }
        isEmpty() {
          return k(this.executorsByZIndex_);
        }
        execute(t, e, i, n, s, r, o) {
          const a = Object.keys(this.executorsByZIndex_).map(Number);
          let h, l, c, u, d, g;
          for (
            a.sort(S),
              this.maxExtent_ && (t.save(), this.clip(t, i)),
              r = r || Aa,
              o && a.reverse(),
              h = 0,
              l = a.length;
            h < l;
            ++h
          ) {
            const l = a[h].toString();
            for (d = this.executorsByZIndex_[l], c = 0, u = r.length; c < u; ++c)
              (g = d[r[c]]), void 0 !== g && g.execute(t, e, i, n, s, o);
          }
          this.maxExtent_ && t.restore();
        }
      },
      Ga = class extends ca {
        constructor(t, e, i, n, s, r, o) {
          super(),
            (this.context_ = t),
            (this.pixelRatio_ = e),
            (this.extent_ = i),
            (this.transform_ = n),
            (this.transformRotation_ = n ? he(Math.atan2(n[1], n[0]), 10) : 0),
            (this.viewRotation_ = s),
            (this.squaredTolerance_ = r),
            (this.userTransform_ = o),
            (this.contextFillState_ = null),
            (this.contextStrokeState_ = null),
            (this.contextTextState_ = null),
            (this.fillState_ = null),
            (this.strokeState_ = null),
            (this.image_ = null),
            (this.imageAnchorX_ = 0),
            (this.imageAnchorY_ = 0),
            (this.imageHeight_ = 0),
            (this.imageOpacity_ = 0),
            (this.imageOriginX_ = 0),
            (this.imageOriginY_ = 0),
            (this.imageRotateWithView_ = !1),
            (this.imageRotation_ = 0),
            (this.imageScale_ = [0, 0]),
            (this.imageWidth_ = 0),
            (this.text_ = ''),
            (this.textOffsetX_ = 0),
            (this.textOffsetY_ = 0),
            (this.textRotateWithView_ = !1),
            (this.textRotation_ = 0),
            (this.textScale_ = [0, 0]),
            (this.textFillState_ = null),
            (this.textStrokeState_ = null),
            (this.textState_ = null),
            (this.pixelCoordinates_ = []),
            (this.tmpLocalTransform_ = [1, 0, 0, 1, 0, 0]);
        }
        drawImages_(t, e, i, n) {
          if (!this.image_) return;
          const s = ui(t, e, i, n, this.transform_, this.pixelCoordinates_),
            r = this.context_,
            o = this.tmpLocalTransform_,
            a = r.globalAlpha;
          1 != this.imageOpacity_ && (r.globalAlpha = a * this.imageOpacity_);
          let h = this.imageRotation_;
          0 === this.transformRotation_ && (h -= this.viewRotation_),
            this.imageRotateWithView_ && (h += this.viewRotation_);
          for (let t = 0, e = s.length; t < e; t += 2) {
            const e = s[t] - this.imageAnchorX_,
              i = s[t + 1] - this.imageAnchorY_;
            if (0 !== h || 1 != this.imageScale_[0] || 1 != this.imageScale_[1]) {
              const t = e + this.imageAnchorX_,
                n = i + this.imageAnchorY_;
              ai(o, t, n, 1, 1, h, -t, -n),
                r.save(),
                r.transform.apply(r, o),
                r.translate(t, n),
                r.scale(this.imageScale_[0], this.imageScale_[1]),
                r.drawImage(
                  this.image_,
                  this.imageOriginX_,
                  this.imageOriginY_,
                  this.imageWidth_,
                  this.imageHeight_,
                  -this.imageAnchorX_,
                  -this.imageAnchorY_,
                  this.imageWidth_,
                  this.imageHeight_,
                ),
                r.restore();
            } else
              r.drawImage(
                this.image_,
                this.imageOriginX_,
                this.imageOriginY_,
                this.imageWidth_,
                this.imageHeight_,
                e,
                i,
                this.imageWidth_,
                this.imageHeight_,
              );
          }
          1 != this.imageOpacity_ && (r.globalAlpha = a);
        }
        drawText_(t, e, i, n) {
          if (!this.textState_ || '' === this.text_) return;
          this.textFillState_ && this.setContextFillState_(this.textFillState_),
            this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_),
            this.setContextTextState_(this.textState_);
          const s = ui(t, e, i, n, this.transform_, this.pixelCoordinates_),
            r = this.context_;
          let o = this.textRotation_;
          for (
            0 === this.transformRotation_ && (o -= this.viewRotation_),
              this.textRotateWithView_ && (o += this.viewRotation_);
            e < i;
            e += n
          ) {
            const t = s[e] + this.textOffsetX_,
              i = s[e + 1] + this.textOffsetY_;
            0 !== o || 1 != this.textScale_[0] || 1 != this.textScale_[1]
              ? (r.save(),
                r.translate(t - this.textOffsetX_, i - this.textOffsetY_),
                r.rotate(o),
                r.translate(this.textOffsetX_, this.textOffsetY_),
                r.scale(this.textScale_[0], this.textScale_[1]),
                this.textStrokeState_ && r.strokeText(this.text_, 0, 0),
                this.textFillState_ && r.fillText(this.text_, 0, 0),
                r.restore())
              : (this.textStrokeState_ && r.strokeText(this.text_, t, i),
                this.textFillState_ && r.fillText(this.text_, t, i));
          }
        }
        moveToLineTo_(t, e, i, n, s) {
          const r = this.context_,
            o = ui(t, e, i, n, this.transform_, this.pixelCoordinates_);
          r.moveTo(o[0], o[1]);
          let a = o.length;
          s && (a -= 2);
          for (let t = 2; t < a; t += 2) r.lineTo(o[t], o[t + 1]);
          return s && r.closePath(), i;
        }
        drawRings_(t, e, i, n) {
          for (let s = 0, r = i.length; s < r; ++s) e = this.moveToLineTo_(t, e, i[s], n, !0);
          return e;
        }
        drawCircle(t) {
          if (
            (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)),
            qt(this.extent_, t.getExtent()))
          ) {
            if (this.fillState_ || this.strokeState_) {
              this.fillState_ && this.setContextFillState_(this.fillState_),
                this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
              const e = (function (t, e, i) {
                  const n = t.getFlatCoordinates();
                  if (!n) return null;
                  const s = t.getStride();
                  return ui(n, 0, n.length, s, e, i);
                })(t, this.transform_, this.pixelCoordinates_),
                i = e[2] - e[0],
                n = e[3] - e[1],
                s = Math.sqrt(i * i + n * n),
                r = this.context_;
              r.beginPath(),
                r.arc(e[0], e[1], s, 0, 2 * Math.PI),
                this.fillState_ && r.fill(),
                this.strokeState_ && r.stroke();
            }
            '' !== this.text_ && this.drawText_(t.getCenter(), 0, 2, 2);
          }
        }
        setStyle(t) {
          this.setFillStrokeStyle(t.getFill(), t.getStroke()),
            this.setImageStyle(t.getImage()),
            this.setTextStyle(t.getText());
        }
        setTransform(t) {
          this.transform_ = t;
        }
        drawGeometry(t) {
          switch (t.getType()) {
            case 'Point':
              this.drawPoint(t);
              break;
            case 'LineString':
              this.drawLineString(t);
              break;
            case 'Polygon':
              this.drawPolygon(t);
              break;
            case 'MultiPoint':
              this.drawMultiPoint(t);
              break;
            case 'MultiLineString':
              this.drawMultiLineString(t);
              break;
            case 'MultiPolygon':
              this.drawMultiPolygon(t);
              break;
            case 'GeometryCollection':
              this.drawGeometryCollection(t);
              break;
            case 'Circle':
              this.drawCircle(t);
          }
        }
        drawFeature(t, e) {
          const i = e.getGeometryFunction()(t);
          i && (this.setStyle(e), this.drawGeometry(i));
        }
        drawGeometryCollection(t) {
          const e = t.getGeometriesArray();
          for (let t = 0, i = e.length; t < i; ++t) this.drawGeometry(e[t]);
        }
        drawPoint(t) {
          this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          const e = t.getFlatCoordinates(),
            i = t.getStride();
          this.image_ && this.drawImages_(e, 0, e.length, i), '' !== this.text_ && this.drawText_(e, 0, e.length, i);
        }
        drawMultiPoint(t) {
          this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          const e = t.getFlatCoordinates(),
            i = t.getStride();
          this.image_ && this.drawImages_(e, 0, e.length, i), '' !== this.text_ && this.drawText_(e, 0, e.length, i);
        }
        drawLineString(t) {
          if (
            (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)),
            qt(this.extent_, t.getExtent()))
          ) {
            if (this.strokeState_) {
              this.setContextStrokeState_(this.strokeState_);
              const e = this.context_,
                i = t.getFlatCoordinates();
              e.beginPath(), this.moveToLineTo_(i, 0, i.length, t.getStride(), !1), e.stroke();
            }
            if ('' !== this.text_) {
              const e = t.getFlatMidpoint();
              this.drawText_(e, 0, 2, 2);
            }
          }
        }
        drawMultiLineString(t) {
          this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          const e = t.getExtent();
          if (qt(this.extent_, e)) {
            if (this.strokeState_) {
              this.setContextStrokeState_(this.strokeState_);
              const e = this.context_,
                i = t.getFlatCoordinates();
              let n = 0;
              const s = t.getEnds(),
                r = t.getStride();
              e.beginPath();
              for (let t = 0, e = s.length; t < e; ++t) n = this.moveToLineTo_(i, n, s[t], r, !1);
              e.stroke();
            }
            if ('' !== this.text_) {
              const e = t.getFlatMidpoints();
              this.drawText_(e, 0, e.length, 2);
            }
          }
        }
        drawPolygon(t) {
          if (
            (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)),
            qt(this.extent_, t.getExtent()))
          ) {
            if (this.strokeState_ || this.fillState_) {
              this.fillState_ && this.setContextFillState_(this.fillState_),
                this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
              const e = this.context_;
              e.beginPath(),
                this.drawRings_(t.getOrientedFlatCoordinates(), 0, t.getEnds(), t.getStride()),
                this.fillState_ && e.fill(),
                this.strokeState_ && e.stroke();
            }
            if ('' !== this.text_) {
              const e = t.getFlatInteriorPoint();
              this.drawText_(e, 0, 2, 2);
            }
          }
        }
        drawMultiPolygon(t) {
          if (
            (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)),
            qt(this.extent_, t.getExtent()))
          ) {
            if (this.strokeState_ || this.fillState_) {
              this.fillState_ && this.setContextFillState_(this.fillState_),
                this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
              const e = this.context_,
                i = t.getOrientedFlatCoordinates();
              let n = 0;
              const s = t.getEndss(),
                r = t.getStride();
              e.beginPath();
              for (let t = 0, e = s.length; t < e; ++t) {
                const e = s[t];
                n = this.drawRings_(i, n, e, r);
              }
              this.fillState_ && e.fill(), this.strokeState_ && e.stroke();
            }
            if ('' !== this.text_) {
              const e = t.getFlatInteriorPoints();
              this.drawText_(e, 0, e.length, 2);
            }
          }
        }
        setContextFillState_(t) {
          const e = this.context_,
            i = this.contextFillState_;
          i
            ? i.fillStyle != t.fillStyle && ((i.fillStyle = t.fillStyle), (e.fillStyle = t.fillStyle))
            : ((e.fillStyle = t.fillStyle), (this.contextFillState_ = { fillStyle: t.fillStyle }));
        }
        setContextStrokeState_(t) {
          const e = this.context_,
            i = this.contextStrokeState_;
          i
            ? (i.lineCap != t.lineCap && ((i.lineCap = t.lineCap), (e.lineCap = t.lineCap)),
              I(i.lineDash, t.lineDash) || e.setLineDash((i.lineDash = t.lineDash)),
              i.lineDashOffset != t.lineDashOffset &&
                ((i.lineDashOffset = t.lineDashOffset), (e.lineDashOffset = t.lineDashOffset)),
              i.lineJoin != t.lineJoin && ((i.lineJoin = t.lineJoin), (e.lineJoin = t.lineJoin)),
              i.lineWidth != t.lineWidth && ((i.lineWidth = t.lineWidth), (e.lineWidth = t.lineWidth)),
              i.miterLimit != t.miterLimit && ((i.miterLimit = t.miterLimit), (e.miterLimit = t.miterLimit)),
              i.strokeStyle != t.strokeStyle && ((i.strokeStyle = t.strokeStyle), (e.strokeStyle = t.strokeStyle)))
            : ((e.lineCap = t.lineCap),
              e.setLineDash(t.lineDash),
              (e.lineDashOffset = t.lineDashOffset),
              (e.lineJoin = t.lineJoin),
              (e.lineWidth = t.lineWidth),
              (e.miterLimit = t.miterLimit),
              (e.strokeStyle = t.strokeStyle),
              (this.contextStrokeState_ = {
                lineCap: t.lineCap,
                lineDash: t.lineDash,
                lineDashOffset: t.lineDashOffset,
                lineJoin: t.lineJoin,
                lineWidth: t.lineWidth,
                miterLimit: t.miterLimit,
                strokeStyle: t.strokeStyle,
              }));
        }
        setContextTextState_(t) {
          const e = this.context_,
            i = this.contextTextState_,
            n = t.textAlign ? t.textAlign : ps;
          i
            ? (i.font != t.font && ((i.font = t.font), (e.font = t.font)),
              i.textAlign != n && ((i.textAlign = n), (e.textAlign = n)),
              i.textBaseline != t.textBaseline &&
                ((i.textBaseline = t.textBaseline), (e.textBaseline = t.textBaseline)))
            : ((e.font = t.font),
              (e.textAlign = n),
              (e.textBaseline = t.textBaseline),
              (this.contextTextState_ = { font: t.font, textAlign: n, textBaseline: t.textBaseline }));
        }
        setFillStrokeStyle(t, e) {
          if (t) {
            const e = t.getColor();
            this.fillState_ = { fillStyle: zr(e || us) };
          } else this.fillState_ = null;
          if (e) {
            const t = e.getColor(),
              i = e.getLineCap(),
              n = e.getLineDash(),
              s = e.getLineDashOffset(),
              r = e.getLineJoin(),
              o = e.getWidth(),
              a = e.getMiterLimit(),
              h = n || gs;
            this.strokeState_ = {
              lineCap: void 0 !== i ? i : ds,
              lineDash: 1 === this.pixelRatio_ ? h : h.map((t) => t * this.pixelRatio_),
              lineDashOffset: (s || 0) * this.pixelRatio_,
              lineJoin: void 0 !== r ? r : fs,
              lineWidth: (void 0 !== o ? o : 1) * this.pixelRatio_,
              miterLimit: void 0 !== a ? a : 10,
              strokeStyle: zr(t || _s),
            };
          } else this.strokeState_ = null;
        }
        setImageStyle(t) {
          let e;
          if (!t || !(e = t.getSize())) return void (this.image_ = null);
          const i = t.getPixelRatio(this.pixelRatio_),
            n = t.getAnchor(),
            s = t.getOrigin();
          (this.image_ = t.getImage(this.pixelRatio_)),
            (this.imageAnchorX_ = n[0] * i),
            (this.imageAnchorY_ = n[1] * i),
            (this.imageHeight_ = e[1] * i),
            (this.imageOpacity_ = t.getOpacity()),
            (this.imageOriginX_ = s[0]),
            (this.imageOriginY_ = s[1]),
            (this.imageRotateWithView_ = t.getRotateWithView()),
            (this.imageRotation_ = t.getRotation());
          const r = t.getScaleArray();
          (this.imageScale_ = [(r[0] * this.pixelRatio_) / i, (r[1] * this.pixelRatio_) / i]),
            (this.imageWidth_ = e[0] * i);
        }
        setTextStyle(t) {
          if (t) {
            const e = t.getFill();
            if (e) {
              const t = e.getColor();
              this.textFillState_ = { fillStyle: zr(t || us) };
            } else this.textFillState_ = null;
            const i = t.getStroke();
            if (i) {
              const t = i.getColor(),
                e = i.getLineCap(),
                n = i.getLineDash(),
                s = i.getLineDashOffset(),
                r = i.getLineJoin(),
                o = i.getWidth(),
                a = i.getMiterLimit();
              this.textStrokeState_ = {
                lineCap: void 0 !== e ? e : ds,
                lineDash: n || gs,
                lineDashOffset: s || 0,
                lineJoin: void 0 !== r ? r : fs,
                lineWidth: void 0 !== o ? o : 1,
                miterLimit: void 0 !== a ? a : 10,
                strokeStyle: zr(t || _s),
              };
            } else this.textStrokeState_ = null;
            const n = t.getFont(),
              s = t.getOffsetX(),
              r = t.getOffsetY(),
              o = t.getRotateWithView(),
              a = t.getRotation(),
              h = t.getScaleArray(),
              l = t.getText(),
              c = t.getTextAlign(),
              u = t.getTextBaseline();
            (this.textState_ = {
              font: void 0 !== n ? n : cs,
              textAlign: void 0 !== c ? c : ps,
              textBaseline: void 0 !== u ? u : ms,
            }),
              (this.text_ =
                void 0 !== l ? (Array.isArray(l) ? l.reduce((t, e, i) => t + (i % 2 ? ' ' : e), '') : l) : ''),
              (this.textOffsetX_ = void 0 !== s ? this.pixelRatio_ * s : 0),
              (this.textOffsetY_ = void 0 !== r ? this.pixelRatio_ * r : 0),
              (this.textRotateWithView_ = void 0 !== o && o),
              (this.textRotation_ = void 0 !== a ? a : 0),
              (this.textScale_ = [this.pixelRatio_ * h[0], this.pixelRatio_ * h[1]]);
          } else this.text_ = '';
        }
      },
      Na = 0.5,
      za = {
        Point: function (t, e, i, n, s) {
          const r = i.getImage(),
            o = i.getText();
          let a;
          if (r) {
            if (2 != r.getImageState()) return;
            let h = t;
            if (s) {
              const l = r.getDeclutterMode();
              if ('none' !== l)
                if (((h = s), 'obstacle' === l)) {
                  const s = t.getBuilder(i.getZIndex(), 'Image');
                  s.setImageStyle(r, a), s.drawPoint(e, n);
                } else o && o.getText() && (a = {});
            }
            const l = h.getBuilder(i.getZIndex(), 'Image');
            l.setImageStyle(r, a), l.drawPoint(e, n);
          }
          if (o && o.getText()) {
            let r = t;
            s && (r = s);
            const h = r.getBuilder(i.getZIndex(), 'Text');
            h.setTextStyle(o, a), h.drawText(e, n);
          }
        },
        LineString: function (t, e, i, n, s) {
          const r = i.getStroke();
          if (r) {
            const s = t.getBuilder(i.getZIndex(), 'LineString');
            s.setFillStrokeStyle(null, r), s.drawLineString(e, n);
          }
          const o = i.getText();
          if (o && o.getText()) {
            const r = (s || t).getBuilder(i.getZIndex(), 'Text');
            r.setTextStyle(o), r.drawText(e, n);
          }
        },
        Polygon: function (t, e, i, n, s) {
          const r = i.getFill(),
            o = i.getStroke();
          if (r || o) {
            const s = t.getBuilder(i.getZIndex(), 'Polygon');
            s.setFillStrokeStyle(r, o), s.drawPolygon(e, n);
          }
          const a = i.getText();
          if (a && a.getText()) {
            const r = (s || t).getBuilder(i.getZIndex(), 'Text');
            r.setTextStyle(a), r.drawText(e, n);
          }
        },
        MultiPoint: function (t, e, i, n, s) {
          const r = i.getImage(),
            o = i.getText();
          let a;
          if (r) {
            if (2 != r.getImageState()) return;
            let h = t;
            if (s) {
              const l = r.getDeclutterMode();
              if ('none' !== l)
                if (((h = s), 'obstacle' === l)) {
                  const s = t.getBuilder(i.getZIndex(), 'Image');
                  s.setImageStyle(r, a), s.drawMultiPoint(e, n);
                } else o && o.getText() && (a = {});
            }
            const l = h.getBuilder(i.getZIndex(), 'Image');
            l.setImageStyle(r, a), l.drawMultiPoint(e, n);
          }
          if (o && o.getText()) {
            let r = t;
            s && (r = s);
            const h = r.getBuilder(i.getZIndex(), 'Text');
            h.setTextStyle(o, a), h.drawText(e, n);
          }
        },
        MultiLineString: function (t, e, i, n, s) {
          const r = i.getStroke();
          if (r) {
            const s = t.getBuilder(i.getZIndex(), 'LineString');
            s.setFillStrokeStyle(null, r), s.drawMultiLineString(e, n);
          }
          const o = i.getText();
          if (o && o.getText()) {
            const r = (s || t).getBuilder(i.getZIndex(), 'Text');
            r.setTextStyle(o), r.drawText(e, n);
          }
        },
        MultiPolygon: function (t, e, i, n, s) {
          const r = i.getFill(),
            o = i.getStroke();
          if (o || r) {
            const s = t.getBuilder(i.getZIndex(), 'Polygon');
            s.setFillStrokeStyle(r, o), s.drawMultiPolygon(e, n);
          }
          const a = i.getText();
          if (a && a.getText()) {
            const r = (s || t).getBuilder(i.getZIndex(), 'Text');
            r.setTextStyle(a), r.drawText(e, n);
          }
        },
        GeometryCollection: function (t, e, i, n, s) {
          const r = e.getGeometriesArray();
          let o, a;
          for (o = 0, a = r.length; o < a; ++o) (0, za[r[o].getType()])(t, r[o], i, n, s);
        },
        Circle: function (t, e, i, n, s) {
          const r = i.getFill(),
            o = i.getStroke();
          if (r || o) {
            const s = t.getBuilder(i.getZIndex(), 'Circle');
            s.setFillStrokeStyle(r, o), s.drawCircle(e, n);
          }
          const a = i.getText();
          if (a && a.getText()) {
            const r = (s || t).getBuilder(i.getZIndex(), 'Text');
            r.setTextStyle(a), r.drawText(e, n);
          }
        },
      };
    function Wa(t, e) {
      return parseInt(U(t), 10) - parseInt(U(e), 10);
    }
    function Xa(t, e) {
      return (0.5 * t) / e;
    }
    function ja(t, e, i, n, s, r, o) {
      let a = !1;
      const h = i.getImage();
      if (h) {
        const t = h.getImageState();
        2 == t || 3 == t ? h.unlistenImageChange(s) : (0 == t && h.load(), h.listenImageChange(s), (a = !0));
      }
      return (
        (function (t, e, i, n, s, r) {
          const o = i.getGeometryFunction()(e);
          if (!o) return;
          const a = o.simplifyTransformed(n, s);
          i.getRenderer() ? Ya(t, a, i, e) : (0, za[a.getType()])(t, a, i, e, r);
        })(t, e, i, n, r, o),
        a
      );
    }
    function Ya(t, e, i, n) {
      if ('GeometryCollection' != e.getType())
        t.getBuilder(i.getZIndex(), 'Default').drawCustom(e, n, i.getRenderer(), i.getHitDetectionRenderer());
      else {
        const s = e.getGeometries();
        for (let e = 0, r = s.length; e < r; ++e) Ya(t, s[e], i, n);
      }
    }
    const Ba = class extends wa {
        constructor(t) {
          super(t),
            (this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this)),
            this.animatingOrInteracting_,
            (this.hitDetectionImageData_ = null),
            (this.renderedFeatures_ = null),
            (this.renderedRevision_ = -1),
            (this.renderedResolution_ = NaN),
            (this.renderedExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
            (this.wrappedRenderedExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
            this.renderedRotation_,
            (this.renderedCenter_ = null),
            (this.renderedProjection_ = null),
            (this.renderedRenderOrder_ = null),
            (this.replayGroup_ = null),
            (this.replayGroupChanged = !0),
            (this.declutterExecutorGroup = null),
            (this.clipping = !0),
            (this.compositionContext_ = null),
            (this.opacity_ = 1);
        }
        renderWorlds(t, e, i) {
          const n = e.extent,
            s = e.viewState,
            r = s.center,
            o = s.resolution,
            a = s.projection,
            h = s.rotation,
            l = a.getExtent(),
            c = this.getLayer().getSource(),
            u = e.pixelRatio,
            d = e.viewHints,
            g = !(d[0] || d[1]),
            f = this.compositionContext_,
            _ = Math.round(e.size[0] * u),
            p = Math.round(e.size[1] * u),
            m = c.getWrapX() && a.canWrapX(),
            y = m ? Vt(l) : null,
            v = m ? Math.ceil((n[2] - l[2]) / y) + 1 : 1;
          let x = m ? Math.floor((n[0] - l[0]) / y) : 0;
          do {
            const e = this.getRenderTransform(r, o, h, u, _, p, x * y);
            t.execute(f, 1, e, h, g, void 0, i);
          } while (++x < v);
        }
        setupCompositionContext_() {
          if (1 !== this.opacity_) {
            const t = os(this.context.canvas.width, this.context.canvas.height, va);
            this.compositionContext_ = t;
          } else this.compositionContext_ = this.context;
        }
        releaseCompositionContext_() {
          if (1 !== this.opacity_) {
            const t = this.context.globalAlpha;
            (this.context.globalAlpha = this.opacity_),
              this.context.drawImage(this.compositionContext_.canvas, 0, 0),
              (this.context.globalAlpha = t),
              as(this.compositionContext_),
              va.push(this.compositionContext_.canvas),
              (this.compositionContext_ = null);
          }
        }
        renderDeclutter(t) {
          this.declutterExecutorGroup &&
            (this.setupCompositionContext_(),
            this.renderWorlds(this.declutterExecutorGroup, t, t.declutterTree),
            this.releaseCompositionContext_());
        }
        renderFrame(t, e) {
          const i = t.pixelRatio,
            n = t.layerStatesArray[t.layerIndex];
          !(function (t, e, i) {
            !(function (t, e, i, n, s, r, o) {
              (t[0] = e), (t[1] = i), (t[2] = n), (t[3] = s), (t[4] = r), (t[5] = o);
            })(t, e, 0, 0, i, 0, 0);
          })(this.pixelTransform, 1 / i, 1 / i),
            hi(this.inversePixelTransform, this.pixelTransform);
          const s = ci(this.pixelTransform);
          this.useContainer(e, s, this.getBackground(t));
          const r = this.context,
            o = r.canvas,
            a = this.replayGroup_,
            h = this.declutterExecutorGroup;
          let l = (a && !a.isEmpty()) || (h && !h.isEmpty());
          if (!l && !this.getLayer().hasListener(Bn) && !this.getLayer().hasListener(Kn)) return null;
          const c = Math.round(t.size[0] * i),
            u = Math.round(t.size[1] * i);
          o.width != c || o.height != u
            ? ((o.width = c), (o.height = u), o.style.transform !== s && (o.style.transform = s))
            : this.containerReused || r.clearRect(0, 0, c, u),
            this.preRender(r, t);
          const d = t.viewState;
          d.projection;
          (this.opacity_ = n.opacity), this.setupCompositionContext_();
          let g = !1;
          if (l && n.extent && this.clipping) {
            const e = Oe(n.extent);
            (l = qt(e, t.extent)), (g = l && !St(e, t.extent)), g && this.clipUnrotated(this.compositionContext_, t, e);
          }
          return (
            l && this.renderWorlds(a, t),
            g && this.compositionContext_.restore(),
            this.releaseCompositionContext_(),
            this.postRender(r, t),
            this.renderedRotation_ !== d.rotation &&
              ((this.renderedRotation_ = d.rotation), (this.hitDetectionImageData_ = null)),
            this.container
          );
        }
        getFeatures(t) {
          return new Promise((e) => {
            if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
              const t = [this.context.canvas.width, this.context.canvas.height];
              oi(this.pixelTransform, t);
              const e = this.renderedCenter_,
                i = this.renderedResolution_,
                n = this.renderedRotation_,
                s = this.renderedProjection_,
                r = this.wrappedRenderedExtent_,
                o = this.getLayer(),
                a = [],
                h = t[0] * Na,
                l = t[1] * Na;
              a.push(this.getRenderTransform(e, i, n, Na, h, l, 0).slice());
              const c = o.getSource(),
                u = s.getExtent();
              if (c.getWrapX() && s.canWrapX() && !St(u, r)) {
                let t = r[0];
                const s = Vt(u);
                let o,
                  c = 0;
                for (; t < u[0]; )
                  --c, (o = s * c), a.push(this.getRenderTransform(e, i, n, Na, h, l, o).slice()), (t += s);
                for (c = 0, t = r[2]; t > u[2]; )
                  ++c, (o = s * c), a.push(this.getRenderTransform(e, i, n, Na, h, l, o).slice()), (t -= s);
              }
              this.hitDetectionImageData_ = (function (t, e, i, n, s, r, o) {
                const a = os(t[0] * Na, t[1] * Na);
                a.imageSmoothingEnabled = !1;
                const h = a.canvas,
                  l = new Ga(a, Na, s, null, o),
                  c = i.length,
                  u = Math.floor(16777215 / c),
                  d = {};
                for (let t = 1; t <= c; ++t) {
                  const e = i[t - 1],
                    o = e.getStyleFunction() || n;
                  if (!o) continue;
                  let a = o(e, r);
                  if (!a) continue;
                  Array.isArray(a) || (a = [a]);
                  const h = (t * u).toString(16).padStart(7, '#00000');
                  for (let t = 0, i = a.length; t < i; ++t) {
                    const i = a[t],
                      n = i.getGeometryFunction()(e);
                    if (!n || !qt(s, n.getExtent())) continue;
                    const r = i.clone(),
                      o = r.getFill();
                    o && o.setColor(h);
                    const l = r.getStroke();
                    l && (l.setColor(h), l.setLineDash(null)), r.setText(void 0);
                    const c = i.getImage();
                    if (c) {
                      const t = c.getImageSize();
                      if (!t) continue;
                      const e = os(t[0], t[1], void 0, { alpha: !1 }),
                        i = e.canvas;
                      (e.fillStyle = h),
                        e.fillRect(0, 0, i.width, i.height),
                        r.setImage(
                          new no({
                            img: i,
                            anchor: c.getAnchor(),
                            anchorXUnits: 'pixels',
                            anchorYUnits: 'pixels',
                            offset: c.getOrigin(),
                            opacity: 1,
                            size: c.getSize(),
                            scale: c.getScale(),
                            rotation: c.getRotation(),
                            rotateWithView: c.getRotateWithView(),
                          }),
                        );
                    }
                    const u = r.getZIndex() || 0;
                    let g = d[u];
                    g || ((g = {}), (d[u] = g), (g.Polygon = []), (g.Circle = []), (g.LineString = []), (g.Point = []));
                    const f = n.getType();
                    if ('GeometryCollection' === f) {
                      const t = n.getGeometriesArrayRecursive();
                      for (let e = 0, i = t.length; e < i; ++e) {
                        const i = t[e];
                        g[i.getType().replace('Multi', '')].push(i, r);
                      }
                    } else g[f.replace('Multi', '')].push(n, r);
                  }
                }
                const g = Object.keys(d).map(Number).sort(S);
                for (let t = 0, i = g.length; t < i; ++t) {
                  const i = d[g[t]];
                  for (const t in i) {
                    const n = i[t];
                    for (let t = 0, i = n.length; t < i; t += 2) {
                      l.setStyle(n[t + 1]);
                      for (let i = 0, s = e.length; i < s; ++i) l.setTransform(e[i]), l.drawGeometry(n[t]);
                    }
                  }
                }
                return a.getImageData(0, 0, h.width, h.height);
              })(t, a, this.renderedFeatures_, o.getStyleFunction(), r, i, n);
            }
            e(
              (function (t, e, i) {
                const n = [];
                if (i) {
                  const s = Math.floor(Math.round(t[0]) * Na),
                    r = Math.floor(Math.round(t[1]) * Na),
                    o = 4 * (ie(s, 0, i.width - 1) + ie(r, 0, i.height - 1) * i.width),
                    a = i.data[o],
                    h = i.data[o + 1],
                    l = i.data[o + 2] + 256 * (h + 256 * a),
                    c = Math.floor(16777215 / e.length);
                  l && l % c == 0 && n.push(e[l / c - 1]);
                }
                return n;
              })(t, this.renderedFeatures_, this.hitDetectionImageData_),
            );
          });
        }
        forEachFeatureAtCoordinate(t, e, i, n, s) {
          if (!this.replayGroup_) return;
          const r = e.viewState.resolution,
            o = e.viewState.rotation,
            a = this.getLayer(),
            h = {},
            l = function (t, e, i) {
              const r = U(t),
                o = h[r];
              if (o) {
                if (!0 !== o && i < o.distanceSq) {
                  if (0 === i) return (h[r] = !0), s.splice(s.lastIndexOf(o), 1), n(t, a, e);
                  (o.geometry = e), (o.distanceSq = i);
                }
              } else {
                if (0 === i) return (h[r] = !0), n(t, a, e);
                s.push((h[r] = { feature: t, layer: a, geometry: e, distanceSq: i, callback: n }));
              }
            };
          let c;
          const u = [this.replayGroup_];
          return (
            this.declutterExecutorGroup && u.push(this.declutterExecutorGroup),
            u.some(
              (n) =>
                (c = n.forEachFeatureAtCoordinate(
                  t,
                  r,
                  o,
                  i,
                  l,
                  n === this.declutterExecutorGroup && e.declutterTree
                    ? e.declutterTree.all().map((t) => t.value)
                    : null,
                )),
            ),
            c
          );
        }
        handleFontsChanged() {
          const t = this.getLayer();
          t.getVisible() && this.replayGroup_ && t.changed();
        }
        handleStyleImageChange_(t) {
          this.renderIfReadyAndVisible();
        }
        prepareFrame(t) {
          const e = this.getLayer(),
            i = e.getSource();
          if (!i) return !1;
          const n = t.viewHints[0],
            s = t.viewHints[1],
            r = e.getUpdateWhileAnimating(),
            o = e.getUpdateWhileInteracting();
          if ((this.ready && !r && n) || (!o && s)) return (this.animatingOrInteracting_ = !0), !0;
          this.animatingOrInteracting_ = !1;
          const a = t.extent,
            h = t.viewState,
            l = h.projection,
            c = h.resolution,
            u = t.pixelRatio,
            d = e.getRevision(),
            g = e.getRenderBuffer();
          let f = e.getRenderOrder();
          void 0 === f && (f = Wa);
          const _ = h.center.slice(),
            p = vt(a, g * c),
            m = p.slice(),
            y = [p.slice()],
            v = l.getExtent();
          if (i.getWrapX() && l.canWrapX() && !St(v, t.extent)) {
            const t = Vt(v),
              e = Math.max(Vt(p) / 2, t);
            (p[0] = v[0] - e), (p[2] = v[2] + e), ee(_, l);
            const i = Ht(y[0], l);
            i[0] < v[0] && i[2] < v[2]
              ? y.push([i[0] + t, i[1], i[2] + t, i[3]])
              : i[0] > v[0] && i[2] > v[2] && y.push([i[0] - t, i[1], i[2] - t, i[3]]);
          }
          if (
            this.ready &&
            this.renderedResolution_ == c &&
            this.renderedRevision_ == d &&
            this.renderedRenderOrder_ == f &&
            St(this.wrappedRenderedExtent_, p)
          )
            return (
              I(this.renderedExtent_, m) || ((this.hitDetectionImageData_ = null), (this.renderedExtent_ = m)),
              (this.renderedCenter_ = _),
              (this.replayGroupChanged = !1),
              !0
            );
          this.replayGroup_ = null;
          const x = new ma(Xa(c, u), p, c, u);
          let w;
          this.getLayer().getDeclutter() && (w = new ma(Xa(c, u), p, c, u));
          const C = Le();
          let S;
          if (C) {
            for (let t = 0, e = y.length; t < e; ++t) {
              const e = Ae(y[t]);
              i.loadFeatures(e, De(c), C);
            }
            S = Ie(C, l);
          } else for (let t = 0, e = y.length; t < e; ++t) i.loadFeatures(y[t], c, l);
          const E = (function (t, e) {
            const i = Xa(t, e);
            return i * i;
          })(c, u);
          let T = !0;
          const b = (t) => {
              let i;
              const n = t.getStyleFunction() || e.getStyleFunction();
              if ((n && (i = n(t, c)), i)) {
                const e = this.renderFeature(t, E, i, x, S, w);
                T = T && !e;
              }
            },
            R = Ae(p),
            M = i.getFeaturesInExtent(R);
          f && M.sort(f);
          for (let t = 0, e = M.length; t < e; ++t) b(M[t]);
          (this.renderedFeatures_ = M), (this.ready = T);
          const P = x.finish(),
            L = new Da(p, c, u, i.getOverlaps(), P, e.getRenderBuffer());
          return (
            w && (this.declutterExecutorGroup = new Da(p, c, u, i.getOverlaps(), w.finish(), e.getRenderBuffer())),
            (this.renderedResolution_ = c),
            (this.renderedRevision_ = d),
            (this.renderedRenderOrder_ = f),
            (this.renderedExtent_ = m),
            (this.wrappedRenderedExtent_ = p),
            (this.renderedCenter_ = _),
            (this.renderedProjection_ = l),
            (this.replayGroup_ = L),
            (this.hitDetectionImageData_ = null),
            (this.replayGroupChanged = !0),
            !0
          );
        }
        renderFeature(t, e, i, n, s, r) {
          if (!i) return !1;
          let o = !1;
          if (Array.isArray(i))
            for (let a = 0, h = i.length; a < h; ++a)
              o = ja(n, t, i[a], e, this.boundHandleStyleImageChange_, s, r) || o;
          else o = ja(n, t, i, e, this.boundHandleStyleImageChange_, s, r);
          return o;
        }
      },
      Ka = class extends na {
        constructor(t) {
          super(t);
        }
        createRenderer() {
          return new Ba(this);
        }
      },
      Za = 'preload',
      Va = 'useInterimTilesOnError',
      qa = class extends Un {
        constructor(t) {
          t = t || {};
          const e = Object.assign({}, t);
          delete e.preload,
            delete e.useInterimTilesOnError,
            super(e),
            this.on,
            this.once,
            this.un,
            this.setPreload(void 0 !== t.preload ? t.preload : 0),
            this.setUseInterimTilesOnError(void 0 === t.useInterimTilesOnError || t.useInterimTilesOnError);
        }
        getPreload() {
          return this.get(Za);
        }
        setPreload(t) {
          this.set(Za, t);
        }
        getUseInterimTilesOnError() {
          return this.get(Va);
        }
        setUseInterimTilesOnError(t) {
          this.set(Va, t);
        }
        getData(t) {
          return super.getData(t);
        }
      },
      Ua = class extends A {
        constructor(t, e, i) {
          super(),
            (i = i || {}),
            (this.tileCoord = t),
            (this.state = e),
            (this.interimTile = null),
            (this.key = ''),
            (this.transition_ = void 0 === i.transition ? 250 : i.transition),
            (this.transitionStarts_ = {}),
            (this.interpolate = !!i.interpolate);
        }
        changed() {
          this.dispatchEvent(O);
        }
        release() {
          3 === this.state && this.setState(4);
        }
        getKey() {
          return this.key + '/' + this.tileCoord;
        }
        getInterimTile() {
          let t = this.interimTile;
          if (!t) return this;
          do {
            if (2 == t.getState()) return (this.transition_ = 0), t;
            t = t.interimTile;
          } while (t);
          return this;
        }
        refreshInterimChain() {
          let t = this.interimTile;
          if (!t) return;
          let e = this;
          do {
            if (2 == t.getState()) {
              t.interimTile = null;
              break;
            }
            1 == t.getState() ? (e = t) : 0 == t.getState() ? (e.interimTile = t.interimTile) : (e = t),
              (t = e.interimTile);
          } while (t);
        }
        getTileCoord() {
          return this.tileCoord;
        }
        getState() {
          return this.state;
        }
        setState(t) {
          if (3 !== this.state && this.state > t) throw new Error('Tile load sequence violation');
          (this.state = t), this.changed();
        }
        load() {
          V();
        }
        getAlpha(t, e) {
          if (!this.transition_) return 1;
          let i = this.transitionStarts_[t];
          if (i) {
            if (-1 === i) return 1;
          } else (i = e), (this.transitionStarts_[t] = i);
          const n = e - i + 1e3 / 60;
          return n >= this.transition_ ? 1 : qe(n / this.transition_);
        }
        inTransition(t) {
          return !!this.transition_ && -1 !== this.transitionStarts_[t];
        }
        endTransition(t) {
          this.transition_ && (this.transitionStarts_[t] = -1);
        }
      },
      Ha = class extends Ua {
        constructor(t, e, i, n, s, r) {
          super(t, e, r),
            (this.crossOrigin_ = n),
            (this.src_ = i),
            (this.key = i),
            (this.image_ = new Image()),
            null !== n && (this.image_.crossOrigin = n),
            (this.unlisten_ = null),
            (this.tileLoadFunction_ = s);
        }
        getImage() {
          return this.image_;
        }
        setImage(t) {
          (this.image_ = t), (this.state = 2), this.unlistenImage_(), this.changed();
        }
        handleImageError_() {
          (this.state = 3),
            this.unlistenImage_(),
            (this.image_ = (function () {
              const t = os(1, 1);
              return (t.fillStyle = 'rgba(0,0,0,0)'), t.fillRect(0, 0, 1, 1), t.canvas;
            })()),
            this.changed();
        }
        handleImageLoad_() {
          const t = this.image_;
          t.naturalWidth && t.naturalHeight ? (this.state = 2) : (this.state = 4),
            this.unlistenImage_(),
            this.changed();
        }
        load() {
          3 == this.state &&
            ((this.state = 0),
            (this.image_ = new Image()),
            null !== this.crossOrigin_ && (this.image_.crossOrigin = this.crossOrigin_)),
            0 == this.state &&
              ((this.state = 1),
              this.changed(),
              this.tileLoadFunction_(this, this.src_),
              (this.unlisten_ = (function (t, e, i) {
                const n = t;
                let s = !0,
                  r = !1,
                  o = !1;
                const a = [
                  Y(n, 'load', function () {
                    (o = !0), r || e();
                  }),
                ];
                return (
                  n.src && si
                    ? ((r = !0),
                      n
                        .decode()
                        .then(function () {
                          s && e();
                        })
                        .catch(function (t) {
                          s && (o ? e() : i());
                        }))
                    : a.push(Y(n, 'error', i)),
                  function () {
                    (s = !1), a.forEach(B);
                  }
                );
              })(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this))));
        }
        unlistenImage_() {
          this.unlisten_ && (this.unlisten_(), (this.unlisten_ = null));
        }
      },
      $a = class {
        constructor(t, e, i, n, s, r) {
          (this.sourceProj_ = t), (this.targetProj_ = e);
          let o = {};
          const a = Re(this.targetProj_, this.sourceProj_);
          (this.transformInv_ = function (t) {
            const e = t[0] + '/' + t[1];
            return o[e] || (o[e] = a(t)), o[e];
          }),
            (this.maxSourceExtent_ = n),
            (this.errorThresholdSquared_ = s * s),
            (this.triangles_ = []),
            (this.wrapsXInSource_ = !1),
            (this.canWrapXInSource_ =
              this.sourceProj_.canWrapX() &&
              !!n &&
              !!this.sourceProj_.getExtent() &&
              Vt(n) >= Vt(this.sourceProj_.getExtent())),
            (this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? Vt(this.sourceProj_.getExtent()) : null),
            (this.targetWorldWidth_ = this.targetProj_.getExtent() ? Vt(this.targetProj_.getExtent()) : null);
          const h = Kt(i),
            l = Zt(i),
            c = Nt(i),
            u = Gt(i),
            d = this.transformInv_(h),
            g = this.transformInv_(l),
            f = this.transformInv_(c),
            _ = this.transformInv_(u),
            p = 10 + (r ? Math.max(0, Math.ceil(Math.log2(Dt(i) / (r * r * 256 * 256)))) : 0);
          if ((this.addQuad_(h, l, c, u, d, g, f, _, p), this.wrapsXInSource_)) {
            let t = 1 / 0;
            this.triangles_.forEach(function (e, i, n) {
              t = Math.min(t, e.source[0][0], e.source[1][0], e.source[2][0]);
            }),
              this.triangles_.forEach((e) => {
                if (Math.max(e.source[0][0], e.source[1][0], e.source[2][0]) - t > this.sourceWorldWidth_ / 2) {
                  const i = [
                    [e.source[0][0], e.source[0][1]],
                    [e.source[1][0], e.source[1][1]],
                    [e.source[2][0], e.source[2][1]],
                  ];
                  i[0][0] - t > this.sourceWorldWidth_ / 2 && (i[0][0] -= this.sourceWorldWidth_),
                    i[1][0] - t > this.sourceWorldWidth_ / 2 && (i[1][0] -= this.sourceWorldWidth_),
                    i[2][0] - t > this.sourceWorldWidth_ / 2 && (i[2][0] -= this.sourceWorldWidth_);
                  const n = Math.min(i[0][0], i[1][0], i[2][0]);
                  Math.max(i[0][0], i[1][0], i[2][0]) - n < this.sourceWorldWidth_ / 2 && (e.source = i);
                }
              });
          }
          o = {};
        }
        addTriangle_(t, e, i, n, s, r) {
          this.triangles_.push({ source: [n, s, r], target: [t, e, i] });
        }
        addQuad_(t, e, i, n, s, r, o, a, h) {
          const l = yt([s, r, o, a]),
            c = this.sourceWorldWidth_ ? Vt(l) / this.sourceWorldWidth_ : null,
            u = this.sourceWorldWidth_,
            d = this.sourceProj_.canWrapX() && c > 0.5 && c < 1;
          let g = !1;
          if (
            (h > 0 &&
              (this.targetProj_.isGlobal() &&
                this.targetWorldWidth_ &&
                (g = Vt(yt([t, e, i, n])) / this.targetWorldWidth_ > 0.25 || g),
              !d && this.sourceProj_.isGlobal() && c && (g = c > 0.25 || g)),
            !g &&
              this.maxSourceExtent_ &&
              isFinite(l[0]) &&
              isFinite(l[1]) &&
              isFinite(l[2]) &&
              isFinite(l[3]) &&
              !qt(l, this.maxSourceExtent_))
          )
            return;
          let f = 0;
          if (
            !(
              g ||
              (isFinite(s[0]) &&
                isFinite(s[1]) &&
                isFinite(r[0]) &&
                isFinite(r[1]) &&
                isFinite(o[0]) &&
                isFinite(o[1]) &&
                isFinite(a[0]) &&
                isFinite(a[1]))
            )
          )
            if (h > 0) g = !0;
            else if (
              ((f =
                (isFinite(s[0]) && isFinite(s[1]) ? 0 : 8) +
                (isFinite(r[0]) && isFinite(r[1]) ? 0 : 4) +
                (isFinite(o[0]) && isFinite(o[1]) ? 0 : 2) +
                (isFinite(a[0]) && isFinite(a[1]) ? 0 : 1)),
              1 != f && 2 != f && 4 != f && 8 != f)
            )
              return;
          if (h > 0) {
            if (!g) {
              const e = [(t[0] + i[0]) / 2, (t[1] + i[1]) / 2],
                n = this.transformInv_(e);
              let r;
              r = d ? (oe(s[0], u) + oe(o[0], u)) / 2 - oe(n[0], u) : (s[0] + o[0]) / 2 - n[0];
              const a = (s[1] + o[1]) / 2 - n[1];
              g = r * r + a * a > this.errorThresholdSquared_;
            }
            if (g) {
              if (Math.abs(t[0] - i[0]) <= Math.abs(t[1] - i[1])) {
                const l = [(e[0] + i[0]) / 2, (e[1] + i[1]) / 2],
                  c = this.transformInv_(l),
                  u = [(n[0] + t[0]) / 2, (n[1] + t[1]) / 2],
                  d = this.transformInv_(u);
                this.addQuad_(t, e, l, u, s, r, c, d, h - 1), this.addQuad_(u, l, i, n, d, c, o, a, h - 1);
              } else {
                const l = [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2],
                  c = this.transformInv_(l),
                  u = [(i[0] + n[0]) / 2, (i[1] + n[1]) / 2],
                  d = this.transformInv_(u);
                this.addQuad_(t, l, u, n, s, c, d, a, h - 1), this.addQuad_(l, e, i, u, c, r, o, d, h - 1);
              }
              return;
            }
          }
          if (d) {
            if (!this.canWrapXInSource_) return;
            this.wrapsXInSource_ = !0;
          }
          0 == (11 & f) && this.addTriangle_(t, i, n, s, o, a),
            0 == (14 & f) && this.addTriangle_(t, i, e, s, o, r),
            f &&
              (0 == (13 & f) && this.addTriangle_(e, n, t, r, a, s),
              0 == (7 & f) && this.addTriangle_(e, n, i, r, a, o));
        }
        calculateSourceExtent() {
          const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          return (
            this.triangles_.forEach(function (e, i, n) {
              const s = e.source;
              Ft(t, s[0]), Ft(t, s[1]), Ft(t, s[2]);
            }),
            t
          );
        }
        getTriangles() {
          return this.triangles_;
        }
      };
    let Ja;
    const Qa = [];
    function th(t, e, i, n, s) {
      t.beginPath(),
        t.moveTo(0, 0),
        t.lineTo(e, i),
        t.lineTo(n, s),
        t.closePath(),
        t.save(),
        t.clip(),
        t.fillRect(0, 0, Math.max(e, n) + 1, Math.max(i, s)),
        t.restore();
    }
    function eh(t, e) {
      return Math.abs(t[4 * e] - 210) > 2 || Math.abs(t[4 * e + 3] - 191.25) > 2;
    }
    function ih(t, e, i, n) {
      const s = Me(i, e, t);
      let r = Ce(e, n, i);
      const o = e.getMetersPerUnit();
      void 0 !== o && (r *= o);
      const a = t.getMetersPerUnit();
      void 0 !== a && (r /= a);
      const h = t.getExtent();
      if (!h || Ct(h, s)) {
        const e = Ce(t, r, s) / r;
        isFinite(e) && e > 0 && (r /= e);
      }
      return r;
    }
    const nh = class extends Ua {
      constructor(t, e, i, n, s, r, o, a, h, l, c, u) {
        super(s, 0, u),
          (this.renderEdges_ = void 0 !== c && c),
          (this.pixelRatio_ = o),
          (this.gutter_ = a),
          (this.canvas_ = null),
          (this.sourceTileGrid_ = e),
          (this.targetTileGrid_ = n),
          (this.wrappedTileCoord_ = r || s),
          (this.sourceTiles_ = []),
          (this.sourcesListenerKeys_ = null),
          (this.sourceZ_ = 0);
        const d = n.getTileCoordExtent(this.wrappedTileCoord_),
          g = this.targetTileGrid_.getExtent();
        let f = this.sourceTileGrid_.getExtent();
        const _ = g ? Bt(d, g) : d;
        if (0 === Dt(_)) return void (this.state = 4);
        const p = t.getExtent();
        p && (f = f ? Bt(f, p) : p);
        const m = n.getResolution(this.wrappedTileCoord_[0]),
          y = (function (t, e, i, n) {
            const s = zt(i);
            let r = ih(t, e, s, n);
            return (
              (!isFinite(r) || r <= 0) &&
                Ot(i, function (i) {
                  return (r = ih(t, e, i, n)), isFinite(r) && r > 0;
                }),
              r
            );
          })(t, i, _, m);
        if (!isFinite(y) || y <= 0) return void (this.state = 4);
        const v = void 0 !== l ? l : 0.5;
        if (((this.triangulation_ = new $a(t, i, _, f, y * v, m)), 0 === this.triangulation_.getTriangles().length))
          return void (this.state = 4);
        this.sourceZ_ = e.getZForResolution(y);
        let x = this.triangulation_.calculateSourceExtent();
        if (
          (f && (t.canWrapX() ? ((x[1] = ie(x[1], f[1], f[3])), (x[3] = ie(x[3], f[1], f[3]))) : (x = Bt(x, f))), Dt(x))
        ) {
          const t = e.getTileRangeForExtentAndZ(x, this.sourceZ_);
          for (let e = t.minX; e <= t.maxX; e++)
            for (let i = t.minY; i <= t.maxY; i++) {
              const t = h(this.sourceZ_, e, i, o);
              t && this.sourceTiles_.push(t);
            }
          0 === this.sourceTiles_.length && (this.state = 4);
        } else this.state = 4;
      }
      getImage() {
        return this.canvas_;
      }
      reproject_() {
        const t = [];
        if (
          (this.sourceTiles_.forEach((e) => {
            e &&
              2 == e.getState() &&
              t.push({ extent: this.sourceTileGrid_.getTileCoordExtent(e.tileCoord), image: e.getImage() });
          }),
          (this.sourceTiles_.length = 0),
          0 === t.length)
        )
          this.state = 3;
        else {
          const e = this.wrappedTileCoord_[0],
            i = this.targetTileGrid_.getTileSize(e),
            n = 'number' == typeof i ? i : i[0],
            s = 'number' == typeof i ? i : i[1],
            r = this.targetTileGrid_.getResolution(e),
            o = this.sourceTileGrid_.getResolution(this.sourceZ_),
            a = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
          (this.canvas_ = (function (t, e, i, n, s, r, o, a, h, l, c, u, d) {
            const g = os(Math.round(i * t), Math.round(i * e), Qa);
            if ((u || (g.imageSmoothingEnabled = !1), 0 === h.length)) return g.canvas;
            function f(t) {
              return Math.round(t * i) / i;
            }
            g.scale(i, i), (g.globalCompositeOperation = 'lighter');
            const _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            let p;
            if (
              (h.forEach(function (t, e, i) {
                Lt(_, t.extent);
              }),
              !d || 1 !== h.length || 0 !== l)
            ) {
              const t = Vt(_),
                e = Yt(_);
              (p = os(Math.round((i * t) / n), Math.round((i * e) / n), Qa)), u || (p.imageSmoothingEnabled = !1);
              const s = i / n;
              h.forEach(function (t, e, i) {
                const n = t.extent[0] - _[0],
                  r = -(t.extent[3] - _[3]),
                  o = Vt(t.extent),
                  a = Yt(t.extent);
                t.image.width > 0 &&
                  t.image.height > 0 &&
                  p.drawImage(t.image, l, l, t.image.width - 2 * l, t.image.height - 2 * l, n * s, r * s, o * s, a * s);
              });
            }
            const m = Kt(o);
            return (
              a.getTriangles().forEach(function (t, e, s) {
                const o = t.source,
                  a = t.target;
                let l = o[0][0],
                  c = o[0][1],
                  d = o[1][0],
                  y = o[1][1],
                  v = o[2][0],
                  x = o[2][1];
                const w = f((a[0][0] - m[0]) / r),
                  C = f(-(a[0][1] - m[1]) / r),
                  S = f((a[1][0] - m[0]) / r),
                  E = f(-(a[1][1] - m[1]) / r),
                  T = f((a[2][0] - m[0]) / r),
                  b = f(-(a[2][1] - m[1]) / r),
                  I = l,
                  R = c;
                (l = 0), (c = 0), (d -= I), (y -= R), (v -= I), (x -= R);
                const M = (function (t) {
                  const e = t.length;
                  for (let i = 0; i < e; i++) {
                    let n = i,
                      s = Math.abs(t[i][i]);
                    for (let r = i + 1; r < e; r++) {
                      const e = Math.abs(t[r][i]);
                      e > s && ((s = e), (n = r));
                    }
                    if (0 === s) return null;
                    const r = t[n];
                    (t[n] = t[i]), (t[i] = r);
                    for (let n = i + 1; n < e; n++) {
                      const s = -t[n][i] / t[i][i];
                      for (let r = i; r < e + 1; r++) i == r ? (t[n][r] = 0) : (t[n][r] += s * t[i][r]);
                    }
                  }
                  const i = new Array(e);
                  for (let n = e - 1; n >= 0; n--) {
                    i[n] = t[n][e] / t[n][n];
                    for (let s = n - 1; s >= 0; s--) t[s][e] -= t[s][n] * i[n];
                  }
                  return i;
                })([
                  [d, y, 0, 0, S - w],
                  [v, x, 0, 0, T - w],
                  [0, 0, d, y, E - C],
                  [0, 0, v, x, b - C],
                ]);
                if (!M) return;
                if (
                  (g.save(),
                  g.beginPath(),
                  (function () {
                    if (void 0 === Ja) {
                      const t = os(6, 6, Qa);
                      (t.globalCompositeOperation = 'lighter'),
                        (t.fillStyle = 'rgba(210, 0, 0, 0.75)'),
                        th(t, 4, 5, 4, 0),
                        th(t, 4, 5, 0, 5);
                      const e = t.getImageData(0, 0, 3, 3).data;
                      (Ja = eh(e, 0) || eh(e, 4) || eh(e, 8)), as(t), Qa.push(t.canvas);
                    }
                    return Ja;
                  })() || !u)
                ) {
                  g.moveTo(S, E);
                  const t = 4,
                    e = w - S,
                    i = C - E;
                  for (let n = 0; n < t; n++)
                    g.lineTo(S + f(((n + 1) * e) / t), E + f((n * i) / (t - 1))),
                      n != t - 1 && g.lineTo(S + f(((n + 1) * e) / t), E + f(((n + 1) * i) / (t - 1)));
                  g.lineTo(T, b);
                } else g.moveTo(S, E), g.lineTo(w, C), g.lineTo(T, b);
                let P;
                if ((g.clip(), g.transform(M[0], M[2], M[1], M[3], w, C), g.translate(_[0] - I, _[3] - R), p))
                  (P = p.canvas), g.scale(n / i, -n / i);
                else {
                  const t = h[0],
                    e = t.extent;
                  (P = t.image), g.scale(Vt(e) / P.width, -Yt(e) / P.height);
                }
                g.drawImage(P, 0, 0), g.restore();
              }),
              p && (as(p), Qa.push(p.canvas)),
              c &&
                (g.save(),
                (g.globalCompositeOperation = 'source-over'),
                (g.strokeStyle = 'black'),
                (g.lineWidth = 1),
                a.getTriangles().forEach(function (t, e, i) {
                  const n = t.target,
                    s = (n[0][0] - m[0]) / r,
                    o = -(n[0][1] - m[1]) / r,
                    a = (n[1][0] - m[0]) / r,
                    h = -(n[1][1] - m[1]) / r,
                    l = (n[2][0] - m[0]) / r,
                    c = -(n[2][1] - m[1]) / r;
                  g.beginPath(), g.moveTo(a, h), g.lineTo(s, o), g.lineTo(l, c), g.closePath(), g.stroke();
                }),
                g.restore()),
              g.canvas
            );
          })(
            n,
            s,
            this.pixelRatio_,
            o,
            this.sourceTileGrid_.getExtent(),
            r,
            a,
            this.triangulation_,
            t,
            this.gutter_,
            this.renderEdges_,
            this.interpolate,
          )),
            (this.state = 2);
        }
        this.changed();
      }
      load() {
        if (0 == this.state) {
          (this.state = 1), this.changed();
          let t = 0;
          (this.sourcesListenerKeys_ = []),
            this.sourceTiles_.forEach((e) => {
              const i = e.getState();
              if (0 == i || 1 == i) {
                t++;
                const i = j(
                  e,
                  O,
                  function (n) {
                    const s = e.getState();
                    (2 != s && 3 != s && 4 != s) ||
                      (B(i), t--, 0 === t && (this.unlistenSources_(), this.reproject_()));
                  },
                  this,
                );
                this.sourcesListenerKeys_.push(i);
              }
            }),
            0 === t
              ? setTimeout(this.reproject_.bind(this), 0)
              : this.sourceTiles_.forEach(function (t, e, i) {
                  0 == t.getState() && t.load();
                });
        }
      }
      unlistenSources_() {
        this.sourcesListenerKeys_.forEach(B), (this.sourcesListenerKeys_ = null);
      }
      release() {
        this.canvas_ && (as(this.canvas_.getContext('2d')), Qa.push(this.canvas_), (this.canvas_ = null)),
          super.release();
      }
    };
    class sh {
      constructor(t, e, i, n) {
        (this.minX = t), (this.maxX = e), (this.minY = i), (this.maxY = n);
      }
      contains(t) {
        return this.containsXY(t[1], t[2]);
      }
      containsTileRange(t) {
        return this.minX <= t.minX && t.maxX <= this.maxX && this.minY <= t.minY && t.maxY <= this.maxY;
      }
      containsXY(t, e) {
        return this.minX <= t && t <= this.maxX && this.minY <= e && e <= this.maxY;
      }
      equals(t) {
        return this.minX == t.minX && this.minY == t.minY && this.maxX == t.maxX && this.maxY == t.maxY;
      }
      extend(t) {
        t.minX < this.minX && (this.minX = t.minX),
          t.maxX > this.maxX && (this.maxX = t.maxX),
          t.minY < this.minY && (this.minY = t.minY),
          t.maxY > this.maxY && (this.maxY = t.maxY);
      }
      getHeight() {
        return this.maxY - this.minY + 1;
      }
      getSize() {
        return [this.getWidth(), this.getHeight()];
      }
      getWidth() {
        return this.maxX - this.minX + 1;
      }
      intersects(t) {
        return this.minX <= t.maxX && this.maxX >= t.minX && this.minY <= t.maxY && this.maxY >= t.minY;
      }
    }
    function rh(t, e, i, n, s) {
      return void 0 !== s ? ((s.minX = t), (s.maxX = e), (s.minY = i), (s.maxY = n), s) : new sh(t, e, i, n);
    }
    const oh = sh,
      ah = class extends wa {
        constructor(t) {
          super(t),
            (this.extentChanged = !0),
            (this.renderedExtent_ = null),
            this.renderedPixelRatio,
            (this.renderedProjection = null),
            this.renderedRevision,
            (this.renderedTiles = []),
            (this.newTiles_ = !1),
            (this.tmpExtent = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
            (this.tmpTileRange_ = new oh(0, 0, 0, 0));
        }
        isDrawableTile(t) {
          const e = this.getLayer(),
            i = t.getState(),
            n = e.getUseInterimTilesOnError();
          return 2 == i || 4 == i || (3 == i && !n);
        }
        getTile(t, e, i, n) {
          const s = n.pixelRatio,
            r = n.viewState.projection,
            o = this.getLayer();
          let a = o.getSource().getTile(t, e, i, s, r);
          return (
            3 == a.getState() && o.getUseInterimTilesOnError() && o.getPreload() > 0 && (this.newTiles_ = !0),
            this.isDrawableTile(a) || (a = a.getInterimTile()),
            a
          );
        }
        getData(t) {
          const e = this.frameState;
          if (!e) return null;
          const i = this.getLayer(),
            n = oi(e.pixelToCoordinateTransform, t.slice()),
            s = i.getExtent();
          if (s && !Ct(s, n)) return null;
          const r = e.pixelRatio,
            o = e.viewState.projection,
            a = e.viewState,
            h = i.getRenderSource(),
            l = h.getTileGridForProjection(a.projection),
            c = h.getTilePixelRatio(e.pixelRatio);
          for (let t = l.getZForResolution(a.resolution); t >= l.getMinZoom(); --t) {
            const e = l.getTileCoordForCoordAndZ(n, t),
              i = h.getTile(t, e[1], e[2], r, o);
            if (!(i instanceof Ha || i instanceof nh) || (i instanceof nh && 4 === i.getState())) return null;
            if (2 !== i.getState()) continue;
            const s = l.getOrigin(t),
              u = Lr(l.getTileSize(t)),
              d = l.getResolution(t),
              g = Math.floor(c * ((n[0] - s[0]) / d - e[1] * u[0])),
              f = Math.floor(c * ((s[1] - n[1]) / d - e[2] * u[1])),
              _ = Math.round(c * h.getGutterForProjection(a.projection));
            return this.getImageData(i.getImage(), g + _, f + _);
          }
          return null;
        }
        loadedTileCallback(t, e, i) {
          return !!this.isDrawableTile(i) && super.loadedTileCallback(t, e, i);
        }
        prepareFrame(t) {
          return !!this.getLayer().getSource();
        }
        renderFrame(t, e) {
          const i = t.layerStatesArray[t.layerIndex],
            n = t.viewState,
            s = n.projection,
            r = n.resolution,
            o = n.center,
            a = n.rotation,
            h = t.pixelRatio,
            l = this.getLayer(),
            c = l.getSource(),
            u = c.getRevision(),
            d = c.getTileGridForProjection(s),
            g = d.getZForResolution(r, c.zDirection),
            f = d.getResolution(g);
          let _ = t.extent;
          const p = t.viewState.resolution,
            m = c.getTilePixelRatio(h),
            y = Math.round((Vt(_) / p) * h),
            v = Math.round((Yt(_) / p) * h),
            x = i.extent && Oe(i.extent);
          x && (_ = Bt(_, Oe(i.extent)));
          const w = (f * y) / 2 / m,
            C = (f * v) / 2 / m,
            E = [o[0] - w, o[1] - C, o[0] + w, o[1] + C],
            T = d.getTileRangeForExtentAndZ(_, g),
            b = {};
          b[g] = {};
          const I = this.createLoadedTileFinder(c, s, b),
            R = this.tmpExtent,
            M = this.tmpTileRange_;
          this.newTiles_ = !1;
          const P = a ? jt(n.center, p, a, t.size) : void 0;
          for (let e = T.minX; e <= T.maxX; ++e)
            for (let n = T.minY; n <= T.maxY; ++n) {
              if (a && !d.tileCoordIntersectsViewport([g, e, n], P)) continue;
              const s = this.getTile(g, e, n, t);
              if (this.isDrawableTile(s)) {
                const e = U(this);
                if (2 == s.getState()) {
                  b[g][s.tileCoord.toString()] = s;
                  let t = s.inTransition(e);
                  t && 1 !== i.opacity && (s.endTransition(e), (t = !1)),
                    this.newTiles_ || (!t && this.renderedTiles.includes(s)) || (this.newTiles_ = !0);
                }
                if (1 === s.getAlpha(e, t.time)) continue;
              }
              const r = d.getTileCoordChildTileRange(s.tileCoord, M, R);
              let o = !1;
              r && (o = I(g + 1, r)), o || d.forEachTileCoordParentTileRange(s.tileCoord, I, M, R);
            }
          const L = ((f / r) * h) / m;
          ai(this.pixelTransform, t.size[0] / 2, t.size[1] / 2, 1 / h, 1 / h, a, -y / 2, -v / 2);
          const F = ci(this.pixelTransform);
          this.useContainer(e, F, this.getBackground(t));
          const k = this.context,
            A = k.canvas;
          hi(this.inversePixelTransform, this.pixelTransform),
            ai(this.tempTransform, y / 2, v / 2, L, L, 0, -y / 2, -v / 2),
            A.width != y || A.height != v
              ? ((A.width = y), (A.height = v))
              : this.containerReused || k.clearRect(0, 0, y, v),
            x && this.clipUnrotated(k, t, x),
            c.getInterpolate() || (k.imageSmoothingEnabled = !1),
            this.preRender(k, t),
            (this.renderedTiles.length = 0);
          let O,
            D,
            G,
            N = Object.keys(b).map(Number);
          N.sort(S),
            1 !== i.opacity || (this.containerReused && !c.getOpaque(t.viewState.projection))
              ? ((O = []), (D = []))
              : (N = N.reverse());
          for (let e = N.length - 1; e >= 0; --e) {
            const i = N[e],
              n = c.getTilePixelSize(i, h, s),
              r = d.getResolution(i) / f,
              o = n[0] * r * L,
              a = n[1] * r * L,
              l = d.getTileCoordForCoordAndZ(Kt(E), i),
              u = d.getTileCoordExtent(l),
              _ = oi(this.tempTransform, [(m * (u[0] - E[0])) / f, (m * (E[3] - u[3])) / f]),
              p = m * c.getGutterForProjection(s),
              y = b[i];
            for (const e in y) {
              const n = y[e],
                s = n.tileCoord,
                r = l[1] - s[1],
                h = Math.round(_[0] - (r - 1) * o),
                u = l[2] - s[2],
                d = Math.round(_[1] - (u - 1) * a),
                f = Math.round(_[0] - r * o),
                m = Math.round(_[1] - u * a),
                v = h - f,
                x = d - m,
                w = g === i,
                C = w && 1 !== n.getAlpha(U(this), t.time);
              let S = !1;
              if (!C)
                if (O) {
                  G = [f, m, f + v, m, f + v, m + x, f, m + x];
                  for (let t = 0, e = O.length; t < e; ++t)
                    if (g !== i && i < D[t]) {
                      const e = O[t];
                      qt([f, m, f + v, m + x], [e[0], e[3], e[4], e[7]]) &&
                        (S || (k.save(), (S = !0)),
                        k.beginPath(),
                        k.moveTo(G[0], G[1]),
                        k.lineTo(G[2], G[3]),
                        k.lineTo(G[4], G[5]),
                        k.lineTo(G[6], G[7]),
                        k.moveTo(e[6], e[7]),
                        k.lineTo(e[4], e[5]),
                        k.lineTo(e[2], e[3]),
                        k.lineTo(e[0], e[1]),
                        k.clip());
                    }
                  O.push(G), D.push(i);
                } else k.clearRect(f, m, v, x);
              this.drawTileImage(n, t, f, m, v, x, p, w),
                O && !C ? (S && k.restore(), this.renderedTiles.unshift(n)) : this.renderedTiles.push(n),
                this.updateUsedTiles(t.usedTiles, c, n);
            }
          }
          return (
            (this.renderedRevision = u),
            (this.renderedResolution = f),
            (this.extentChanged = !this.renderedExtent_ || !Pt(this.renderedExtent_, E)),
            (this.renderedExtent_ = E),
            (this.renderedPixelRatio = h),
            (this.renderedProjection = s),
            this.manageTilePyramid(t, c, d, h, s, _, g, l.getPreload()),
            this.scheduleExpireCache(t, c),
            this.postRender(k, t),
            i.extent && k.restore(),
            (k.imageSmoothingEnabled = !0),
            F !== A.style.transform && (A.style.transform = F),
            this.container
          );
        }
        drawTileImage(t, e, i, n, s, r, o, a) {
          const h = this.getTileImage(t);
          if (!h) return;
          const l = U(this),
            c = e.layerStatesArray[e.layerIndex],
            u = c.opacity * (a ? t.getAlpha(l, e.time) : 1),
            d = u !== this.context.globalAlpha;
          d && (this.context.save(), (this.context.globalAlpha = u)),
            this.context.drawImage(h, o, o, h.width - 2 * o, h.height - 2 * o, i, n, s, r),
            d && this.context.restore(),
            u !== c.opacity ? (e.animate = !0) : a && t.endTransition(l);
        }
        getImage() {
          const t = this.context;
          return t ? t.canvas : null;
        }
        getTileImage(t) {
          return t.getImage();
        }
        scheduleExpireCache(t, e) {
          if (e.canExpireCache()) {
            const i = function (t, e, i) {
              const n = U(t);
              n in i.usedTiles && t.expireCache(i.viewState.projection, i.usedTiles[n]);
            }.bind(null, e);
            t.postRenderFunctions.push(i);
          }
        }
        updateUsedTiles(t, e, i) {
          const n = U(e);
          n in t || (t[n] = {}), (t[n][i.getKey()] = !0);
        }
        manageTilePyramid(t, e, i, n, s, r, o, a, h) {
          const l = U(e);
          l in t.wantedTiles || (t.wantedTiles[l] = {});
          const c = t.wantedTiles[l],
            u = t.tileQueue,
            d = i.getMinZoom(),
            g = t.viewState.rotation,
            f = g ? jt(t.viewState.center, t.viewState.resolution, g, t.size) : void 0;
          let _,
            p,
            m,
            y,
            v,
            x,
            w = 0;
          for (x = d; x <= o; ++x)
            for (p = i.getTileRangeForExtentAndZ(r, x, p), m = i.getResolution(x), y = p.minX; y <= p.maxX; ++y)
              for (v = p.minY; v <= p.maxY; ++v)
                (g && !i.tileCoordIntersectsViewport([x, y, v], f)) ||
                  (o - x <= a
                    ? (++w,
                      (_ = e.getTile(x, y, v, n, s)),
                      0 == _.getState() &&
                        ((c[_.getKey()] = !0),
                        u.isKeyQueued(_.getKey()) || u.enqueue([_, l, i.getTileCoordCenter(_.tileCoord), m])),
                      void 0 !== h && h(_))
                    : e.useTile(x, y, v, s));
          e.updateCacheSize(w, s);
        }
      },
      hh = class {
        constructor(t) {
          (this.rbush_ = new Dr(t)), (this.items_ = {});
        }
        insert(t, e) {
          const i = { minX: t[0], minY: t[1], maxX: t[2], maxY: t[3], value: e };
          this.rbush_.insert(i), (this.items_[U(e)] = i);
        }
        load(t, e) {
          const i = new Array(e.length);
          for (let n = 0, s = e.length; n < s; n++) {
            const s = t[n],
              r = e[n],
              o = { minX: s[0], minY: s[1], maxX: s[2], maxY: s[3], value: r };
            (i[n] = o), (this.items_[U(r)] = o);
          }
          this.rbush_.load(i);
        }
        remove(t) {
          const e = U(t),
            i = this.items_[e];
          return delete this.items_[e], null !== this.rbush_.remove(i);
        }
        update(t, e) {
          const i = this.items_[U(e)];
          Pt([i.minX, i.minY, i.maxX, i.maxY], t) || (this.remove(e), this.insert(t, e));
        }
        getAll() {
          return this.rbush_.all().map(function (t) {
            return t.value;
          });
        }
        getInExtent(t) {
          const e = { minX: t[0], minY: t[1], maxX: t[2], maxY: t[3] };
          return this.rbush_.search(e).map(function (t) {
            return t.value;
          });
        }
        forEach(t) {
          return this.forEach_(this.getAll(), t);
        }
        forEachInExtent(t, e) {
          return this.forEach_(this.getInExtent(t), e);
        }
        forEach_(t, e) {
          let i;
          for (let n = 0, s = t.length; n < s; n++) if (((i = e(t[n])), i)) return i;
          return i;
        }
        isEmpty() {
          return k(this.items_);
        }
        clear() {
          this.rbush_.clear(), (this.items_ = {});
        }
        getExtent(t) {
          const e = this.rbush_.toJSON();
          return bt(e.minX, e.minY, e.maxX, e.maxY, t);
        }
        concat(t) {
          this.rbush_.load(t.rbush_.all());
          for (const e in t.items_) this.items_[e] = t.items_[e];
        }
      };
    function lh(t, e, i, n, s, r, o) {
      let a, h;
      const l = (i - e) / n;
      if (1 === l) a = e;
      else if (2 === l) (a = e), (h = s);
      else if (0 !== l) {
        let r = t[e],
          o = t[e + 1],
          l = 0;
        const c = [0];
        for (let s = e + n; s < i; s += n) {
          const e = t[s],
            i = t[s + 1];
          (l += Math.sqrt((e - r) * (e - r) + (i - o) * (i - o))), c.push(l), (r = e), (o = i);
        }
        const u = s * l,
          d = (function (t, e, i) {
            let n, s;
            i = i || S;
            let r = 0,
              o = t.length,
              a = !1;
            for (; r < o; ) (n = r + ((o - r) >> 1)), (s = +i(t[n], e)), s < 0 ? (r = n + 1) : ((o = n), (a = !s));
            return a ? r : ~r;
          })(c, u);
        d < 0 ? ((h = (u - c[-d - 2]) / (c[-d - 1] - c[-d - 2])), (a = e + (-d - 2) * n)) : (a = e + d * n);
      }
      (o = o > 1 ? o : 2), (r = r || new Array(o));
      for (let e = 0; e < o; ++e) r[e] = void 0 === a ? NaN : void 0 === h ? t[a + e] : ae(t[a + e], t[a + n + e], h);
      return r;
    }
    function ch(t, e, i, n, s, r) {
      if (i == e) return null;
      let o;
      if (s < t[e + n - 1]) return r ? ((o = t.slice(e, e + n)), (o[n - 1] = s), o) : null;
      if (t[i - 1] < s) return r ? ((o = t.slice(i - n, i)), (o[n - 1] = s), o) : null;
      if (s == t[e + n - 1]) return t.slice(e, e + n);
      let a = e / n,
        h = i / n;
      for (; a < h; ) {
        const e = (a + h) >> 1;
        s < t[(e + 1) * n - 1] ? (h = e) : (a = e + 1);
      }
      const l = t[a * n - 1];
      if (s == l) return t.slice((a - 1) * n, (a - 1) * n + n);
      const c = (s - l) / (t[(a + 1) * n - 1] - l);
      o = [];
      for (let e = 0; e < n - 1; ++e) o.push(ae(t[(a - 1) * n + e], t[a * n + e], c));
      return o.push(s), o;
    }
    function uh(t, e, i, n) {
      const s = [];
      let r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      for (let o = 0, a = i.length; o < a; ++o) {
        const a = i[o];
        (r = Mt(t, e, a[0], n)), s.push((r[0] + r[2]) / 2, (r[1] + r[3]) / 2), (e = a[a.length - 1]);
      }
      return s;
    }
    const dh = [1, 0, 0, 1, 0, 0];
    class gh {
      constructor(t, e, i, n, s, r) {
        this.styleFunction,
          this.extent_,
          (this.id_ = r),
          (this.type_ = t),
          (this.flatCoordinates_ = e),
          (this.flatInteriorPoints_ = null),
          (this.flatMidpoints_ = null),
          (this.ends_ = i),
          (this.properties_ = s),
          this.squaredTolerance_,
          (this.stride_ = n),
          this.simplifiedGeometry_;
      }
      get(t) {
        return this.properties_[t];
      }
      getExtent() {
        return (
          this.extent_ ||
            (this.extent_ =
              'Point' === this.type_
                ? Rt(this.flatCoordinates_)
                : Mt(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2)),
          this.extent_
        );
      }
      getFlatInteriorPoint() {
        if (!this.flatInteriorPoints_) {
          const t = zt(this.getExtent());
          this.flatInteriorPoints_ = ji(this.flatCoordinates_, 0, this.ends_, 2, t, 0);
        }
        return this.flatInteriorPoints_;
      }
      getFlatInteriorPoints() {
        if (!this.flatInteriorPoints_) {
          const t = (function (t, e) {
              const i = [];
              let n,
                s = 0,
                r = 0;
              for (let o = 0, a = e.length; o < a; ++o) {
                const a = e[o],
                  h = Ui(t, s, a, 2);
                if ((void 0 === n && (n = h), h === n)) i.push(e.slice(r, o + 1));
                else {
                  if (0 === i.length) continue;
                  i[i.length - 1].push(e[r]);
                }
                (r = o + 1), (s = a);
              }
              return i;
            })(this.flatCoordinates_, this.ends_),
            e = uh(this.flatCoordinates_, 0, t, 2);
          this.flatInteriorPoints_ = Yi(this.flatCoordinates_, 0, t, 2, e);
        }
        return this.flatInteriorPoints_;
      }
      getFlatMidpoint() {
        return (
          this.flatMidpoints_ ||
            (this.flatMidpoints_ = lh(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5)),
          this.flatMidpoints_
        );
      }
      getFlatMidpoints() {
        if (!this.flatMidpoints_) {
          this.flatMidpoints_ = [];
          const t = this.flatCoordinates_;
          let e = 0;
          const i = this.ends_;
          for (let n = 0, s = i.length; n < s; ++n) {
            const s = i[n],
              r = lh(t, e, s, 2, 0.5);
            b(this.flatMidpoints_, r), (e = s);
          }
        }
        return this.flatMidpoints_;
      }
      getId() {
        return this.id_;
      }
      getOrientedFlatCoordinates() {
        return this.flatCoordinates_;
      }
      getGeometry() {
        return this;
      }
      getSimplifiedGeometry(t) {
        return this;
      }
      simplifyTransformed(t, e) {
        return this;
      }
      getProperties() {
        return this.properties_;
      }
      getPropertiesInternal() {
        return this.properties_;
      }
      getStride() {
        return this.stride_;
      }
      getStyleFunction() {
        return this.styleFunction;
      }
      getType() {
        return this.type_;
      }
      transform(t) {
        const e = (t = we(t)).getExtent(),
          i = t.getWorldExtent();
        if (e && i) {
          const t = Yt(i) / Yt(e);
          ai(dh, i[0], i[3], t, -t, 0, 0, 0),
            ui(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, dh, this.flatCoordinates_);
        }
      }
      applyTransform(t) {
        t(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
      }
      clone() {
        return new gh(
          this.type_,
          this.flatCoordinates_.slice(),
          this.ends_.slice(),
          this.stride_,
          Object.assign({}, this.properties_),
          this.id_,
        );
      }
      getEnds() {
        return this.ends_;
      }
      enableSimplifyTransformed() {
        return (
          (this.simplifyTransformed = L((t, e) => {
            if (t === this.squaredTolerance_) return this.simplifiedGeometry_;
            (this.simplifiedGeometry_ = this.clone()), e && this.simplifiedGeometry_.applyTransform(e);
            const i = this.simplifiedGeometry_.getFlatCoordinates();
            let n;
            switch (this.type_) {
              case 'LineString':
                (i.length = Ti(
                  i,
                  0,
                  this.simplifiedGeometry_.flatCoordinates_.length,
                  this.simplifiedGeometry_.stride_,
                  t,
                  i,
                  0,
                )),
                  (n = [i.length]);
                break;
              case 'MultiLineString':
                (n = []),
                  (i.length = bi(i, 0, this.simplifiedGeometry_.ends_, this.simplifiedGeometry_.stride_, t, i, 0, n));
                break;
              case 'Polygon':
                (n = []),
                  (i.length = Mi(
                    i,
                    0,
                    this.simplifiedGeometry_.ends_,
                    this.simplifiedGeometry_.stride_,
                    Math.sqrt(t),
                    i,
                    0,
                    n,
                  ));
            }
            return (
              n && (this.simplifiedGeometry_ = new gh(this.type_, i, n, 2, this.properties_, this.id_)),
              (this.squaredTolerance_ = t),
              this.simplifiedGeometry_
            );
          })),
          this
        );
      }
    }
    gh.prototype.getFlatCoordinates = gh.prototype.getOrientedFlatCoordinates;
    const fh = gh;
    function _h(t) {
      return t
        ? Array.isArray(t)
          ? function (e) {
              return t;
            }
          : 'function' == typeof t
            ? t
            : function (e) {
                return [t];
              }
        : null;
    }
    const ph = class extends $ {
        constructor(t) {
          super(),
            (this.projection = we(t.projection)),
            (this.attributions_ = _h(t.attributions)),
            (this.attributionsCollapsible_ = void 0 === t.attributionsCollapsible || t.attributionsCollapsible),
            (this.loading = !1),
            (this.state_ = void 0 !== t.state ? t.state : 'ready'),
            (this.wrapX_ = void 0 !== t.wrapX && t.wrapX),
            (this.interpolate_ = !!t.interpolate),
            (this.viewResolver = null),
            (this.viewRejector = null);
          const e = this;
          this.viewPromise_ = new Promise(function (t, i) {
            (e.viewResolver = t), (e.viewRejector = i);
          });
        }
        getAttributions() {
          return this.attributions_;
        }
        getAttributionsCollapsible() {
          return this.attributionsCollapsible_;
        }
        getProjection() {
          return this.projection;
        }
        getResolutions(t) {
          return null;
        }
        getView() {
          return this.viewPromise_;
        }
        getState() {
          return this.state_;
        }
        getWrapX() {
          return this.wrapX_;
        }
        getInterpolate() {
          return this.interpolate_;
        }
        refresh() {
          this.changed();
        }
        setAttributions(t) {
          (this.attributions_ = _h(t)), this.changed();
        }
        setState(t) {
          (this.state_ = t), this.changed();
        }
      },
      mh = 'addfeature',
      yh = 'removefeature';
    function vh(t, e) {
      return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
    }
    function xh(t, e) {
      return function (i, n, s, r, o) {
        const a = this;
        !(function (t, e, i, n, s, r, o) {
          const a = new XMLHttpRequest();
          a.open('GET', 'function' == typeof t ? t(i, n, s) : t, !0),
            'arraybuffer' == e.getType() && (a.responseType = 'arraybuffer'),
            (a.withCredentials = false),
            (a.onload = function (t) {
              if (!a.status || (a.status >= 200 && a.status < 300)) {
                const t = e.getType();
                let n;
                'json' == t
                  ? (n = JSON.parse(a.responseText))
                  : 'text' == t
                    ? (n = a.responseText)
                    : 'xml' == t
                      ? ((n = a.responseXML),
                        n || (n = new DOMParser().parseFromString(a.responseText, 'application/xml')))
                      : 'arraybuffer' == t && (n = a.response),
                  n ? r(e.readFeatures(n, { extent: i, featureProjection: s }), e.readProjection(n)) : o();
              } else o();
            }),
            (a.onerror = o),
            a.send();
        })(
          t,
          e,
          i,
          n,
          s,
          function (t, e) {
            a.addFeatures(t), void 0 !== r && r(t);
          },
          o || P,
        );
      };
    }
    class wh extends x {
      constructor(t, e, i) {
        super(t), (this.feature = e), (this.features = i);
      }
    }
    const Ch = class extends ph {
        constructor(t) {
          super({
            attributions: (t = t || {}).attributions,
            interpolate: !0,
            projection: void 0,
            state: 'ready',
            wrapX: void 0 === t.wrapX || t.wrapX,
          }),
            this.on,
            this.once,
            this.un,
            (this.loader_ = P),
            (this.format_ = t.format),
            (this.overlaps_ = void 0 === t.overlaps || t.overlaps),
            (this.url_ = t.url),
            void 0 !== t.loader
              ? (this.loader_ = t.loader)
              : void 0 !== this.url_ &&
                (We(this.format_, '`format` must be set when `url` is set'),
                (this.loader_ = xh(this.url_, this.format_))),
            (this.strategy_ = void 0 !== t.strategy ? t.strategy : vh);
          const e = void 0 === t.useSpatialIndex || t.useSpatialIndex;
          let i, n;
          (this.featuresRtree_ = e ? new hh() : null),
            (this.loadedExtentsRtree_ = new hh()),
            (this.loadingExtentsCount_ = 0),
            (this.nullGeometryFeatures_ = {}),
            (this.idIndex_ = {}),
            (this.uidIndex_ = {}),
            (this.featureChangeKeys_ = {}),
            (this.featuresCollection_ = null),
            Array.isArray(t.features) ? (n = t.features) : t.features && ((i = t.features), (n = i.getArray())),
            e || void 0 !== i || (i = new un(n)),
            void 0 !== n && this.addFeaturesInternal(n),
            void 0 !== i && this.bindFeaturesCollection_(i);
        }
        addFeature(t) {
          this.addFeatureInternal(t), this.changed();
        }
        addFeatureInternal(t) {
          const e = U(t);
          if (!this.addToIndex_(e, t)) return void (this.featuresCollection_ && this.featuresCollection_.remove(t));
          this.setupChangeEvents_(e, t);
          const i = t.getGeometry();
          if (i) {
            const e = i.getExtent();
            this.featuresRtree_ && this.featuresRtree_.insert(e, t);
          } else this.nullGeometryFeatures_[e] = t;
          this.dispatchEvent(new wh(mh, t));
        }
        setupChangeEvents_(t, e) {
          e instanceof fh ||
            (this.featureChangeKeys_[t] = [
              j(e, O, this.handleFeatureChange_, this),
              j(e, w, this.handleFeatureChange_, this),
            ]);
        }
        addToIndex_(t, e) {
          let i = !0;
          if (void 0 !== e.getId()) {
            const t = String(e.getId());
            if (t in this.idIndex_)
              if (e instanceof fh) {
                const n = this.idIndex_[t];
                n instanceof fh ? (Array.isArray(n) ? n.push(e) : (this.idIndex_[t] = [n, e])) : (i = !1);
              } else i = !1;
            else this.idIndex_[t] = e;
          }
          return (
            i &&
              (We(!(t in this.uidIndex_), 'The passed `feature` was already added to the source'),
              (this.uidIndex_[t] = e)),
            i
          );
        }
        addFeatures(t) {
          this.addFeaturesInternal(t), this.changed();
        }
        addFeaturesInternal(t) {
          const e = [],
            i = [],
            n = [];
          for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e],
              s = U(n);
            this.addToIndex_(s, n) && i.push(n);
          }
          for (let t = 0, s = i.length; t < s; t++) {
            const s = i[t],
              r = U(s);
            this.setupChangeEvents_(r, s);
            const o = s.getGeometry();
            if (o) {
              const t = o.getExtent();
              e.push(t), n.push(s);
            } else this.nullGeometryFeatures_[r] = s;
          }
          if ((this.featuresRtree_ && this.featuresRtree_.load(e, n), this.hasListener(mh)))
            for (let t = 0, e = i.length; t < e; t++) this.dispatchEvent(new wh(mh, i[t]));
        }
        bindFeaturesCollection_(t) {
          let e = !1;
          this.addEventListener(mh, function (i) {
            e || ((e = !0), t.push(i.feature), (e = !1));
          }),
            this.addEventListener(yh, function (i) {
              e || ((e = !0), t.remove(i.feature), (e = !1));
            }),
            t.addEventListener(an, (t) => {
              e || ((e = !0), this.addFeature(t.element), (e = !1));
            }),
            t.addEventListener(hn, (t) => {
              e || ((e = !0), this.removeFeature(t.element), (e = !1));
            }),
            (this.featuresCollection_ = t);
        }
        clear(t) {
          if (t) {
            for (const t in this.featureChangeKeys_) this.featureChangeKeys_[t].forEach(B);
            this.featuresCollection_ || ((this.featureChangeKeys_ = {}), (this.idIndex_ = {}), (this.uidIndex_ = {}));
          } else if (this.featuresRtree_) {
            const t = (t) => {
              this.removeFeatureInternal(t);
            };
            this.featuresRtree_.forEach(t);
            for (const t in this.nullGeometryFeatures_) this.removeFeatureInternal(this.nullGeometryFeatures_[t]);
          }
          this.featuresCollection_ && this.featuresCollection_.clear(),
            this.featuresRtree_ && this.featuresRtree_.clear(),
            (this.nullGeometryFeatures_ = {});
          const e = new wh('clear');
          this.dispatchEvent(e), this.changed();
        }
        forEachFeature(t) {
          if (this.featuresRtree_) return this.featuresRtree_.forEach(t);
          this.featuresCollection_ && this.featuresCollection_.forEach(t);
        }
        forEachFeatureAtCoordinateDirect(t, e) {
          const i = [t[0], t[1], t[0], t[1]];
          return this.forEachFeatureInExtent(i, function (i) {
            const n = i.getGeometry();
            if (n instanceof fh || n.intersectsCoordinate(t)) return e(i);
          });
        }
        forEachFeatureInExtent(t, e) {
          if (this.featuresRtree_) return this.featuresRtree_.forEachInExtent(t, e);
          this.featuresCollection_ && this.featuresCollection_.forEach(e);
        }
        forEachFeatureIntersectingExtent(t, e) {
          return this.forEachFeatureInExtent(t, function (i) {
            const n = i.getGeometry();
            if (n instanceof fh || n.intersectsExtent(t)) {
              const t = e(i);
              if (t) return t;
            }
          });
        }
        getFeaturesCollection() {
          return this.featuresCollection_;
        }
        getFeatures() {
          let t;
          return (
            this.featuresCollection_
              ? (t = this.featuresCollection_.getArray().slice(0))
              : this.featuresRtree_ &&
                ((t = this.featuresRtree_.getAll()),
                k(this.nullGeometryFeatures_) || b(t, Object.values(this.nullGeometryFeatures_))),
            t
          );
        }
        getFeaturesAtCoordinate(t) {
          const e = [];
          return (
            this.forEachFeatureAtCoordinateDirect(t, function (t) {
              e.push(t);
            }),
            e
          );
        }
        getFeaturesInExtent(t, e) {
          if (this.featuresRtree_) {
            if (!(e && e.canWrapX() && this.getWrapX())) return this.featuresRtree_.getInExtent(t);
            const i = (function (t, e) {
              if (e.canWrapX()) {
                const i = e.getExtent();
                if (!isFinite(t[0]) || !isFinite(t[2])) return [[i[0], t[1], i[2], t[3]]];
                Ht(t, e);
                const n = Vt(i);
                if (Vt(t) > n) return [[i[0], t[1], i[2], t[3]]];
                if (t[0] < i[0])
                  return [
                    [t[0] + n, t[1], i[2], t[3]],
                    [i[0], t[1], t[2], t[3]],
                  ];
                if (t[2] > i[2])
                  return [
                    [t[0], t[1], i[2], t[3]],
                    [i[0], t[1], t[2] - n, t[3]],
                  ];
              }
              return [t];
            })(t, e);
            return [].concat(...i.map((t) => this.featuresRtree_.getInExtent(t)));
          }
          return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : [];
        }
        getClosestFeatureToCoordinate(t, e) {
          const i = t[0],
            n = t[1];
          let s = null;
          const r = [NaN, NaN];
          let o = 1 / 0;
          const a = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
          return (
            (e = e || R),
            this.featuresRtree_.forEachInExtent(a, function (t) {
              if (e(t)) {
                const e = t.getGeometry(),
                  h = o;
                if (((o = e instanceof fh ? 0 : e.closestPointXY(i, n, r, o)), o < h)) {
                  s = t;
                  const e = Math.sqrt(o);
                  (a[0] = i - e), (a[1] = n - e), (a[2] = i + e), (a[3] = n + e);
                }
              }
            }),
            s
          );
        }
        getExtent(t) {
          return this.featuresRtree_.getExtent(t);
        }
        getFeatureById(t) {
          const e = this.idIndex_[t.toString()];
          return void 0 !== e ? e : null;
        }
        getFeatureByUid(t) {
          const e = this.uidIndex_[t];
          return void 0 !== e ? e : null;
        }
        getFormat() {
          return this.format_;
        }
        getOverlaps() {
          return this.overlaps_;
        }
        getUrl() {
          return this.url_;
        }
        handleFeatureChange_(t) {
          const e = t.target,
            i = U(e),
            n = e.getGeometry();
          if (n) {
            const t = n.getExtent();
            i in this.nullGeometryFeatures_
              ? (delete this.nullGeometryFeatures_[i], this.featuresRtree_ && this.featuresRtree_.insert(t, e))
              : this.featuresRtree_ && this.featuresRtree_.update(t, e);
          } else
            i in this.nullGeometryFeatures_ ||
              (this.featuresRtree_ && this.featuresRtree_.remove(e), (this.nullGeometryFeatures_[i] = e));
          const s = e.getId();
          if (void 0 !== s) {
            const t = s.toString();
            this.idIndex_[t] !== e && (this.removeFromIdIndex_(e), (this.idIndex_[t] = e));
          } else this.removeFromIdIndex_(e), (this.uidIndex_[i] = e);
          this.changed(), this.dispatchEvent(new wh('changefeature', e));
        }
        hasFeature(t) {
          const e = t.getId();
          return void 0 !== e ? e in this.idIndex_ : U(t) in this.uidIndex_;
        }
        isEmpty() {
          return this.featuresRtree_
            ? this.featuresRtree_.isEmpty() && k(this.nullGeometryFeatures_)
            : !this.featuresCollection_ || 0 === this.featuresCollection_.getLength();
        }
        loadFeatures(t, e, i) {
          const n = this.loadedExtentsRtree_,
            s = this.strategy_(t, e, i);
          for (let t = 0, r = s.length; t < r; ++t) {
            const r = s[t];
            n.forEachInExtent(r, function (t) {
              return St(t.extent, r);
            }) ||
              (++this.loadingExtentsCount_,
              this.dispatchEvent(new wh('featuresloadstart')),
              this.loader_.call(
                this,
                r,
                e,
                i,
                (t) => {
                  --this.loadingExtentsCount_, this.dispatchEvent(new wh('featuresloadend', void 0, t));
                },
                () => {
                  --this.loadingExtentsCount_, this.dispatchEvent(new wh('featuresloaderror'));
                },
              ),
              n.insert(r, { extent: r.slice() }));
          }
          this.loading = !(this.loader_.length < 4) && this.loadingExtentsCount_ > 0;
        }
        refresh() {
          this.clear(!0), this.loadedExtentsRtree_.clear(), super.refresh();
        }
        removeLoadedExtent(t) {
          const e = this.loadedExtentsRtree_;
          let i;
          e.forEachInExtent(t, function (e) {
            if (Pt(e.extent, t)) return (i = e), !0;
          }),
            i && e.remove(i);
        }
        removeFeature(t) {
          if (!t) return;
          const e = U(t);
          e in this.nullGeometryFeatures_
            ? delete this.nullGeometryFeatures_[e]
            : this.featuresRtree_ && this.featuresRtree_.remove(t),
            this.removeFeatureInternal(t) && this.changed();
        }
        removeFeatureInternal(t) {
          const e = U(t),
            i = this.featureChangeKeys_[e];
          if (!i) return;
          i.forEach(B), delete this.featureChangeKeys_[e];
          const n = t.getId();
          return (
            void 0 !== n && delete this.idIndex_[n.toString()],
            delete this.uidIndex_[e],
            this.dispatchEvent(new wh(yh, t)),
            t
          );
        }
        removeFromIdIndex_(t) {
          let e = !1;
          for (const i in this.idIndex_) {
            const n = this.idIndex_[i];
            if (t instanceof fh && Array.isArray(n) && n.includes(t)) n.splice(n.indexOf(t), 1);
            else if (this.idIndex_[i] === t) {
              delete this.idIndex_[i], (e = !0);
              break;
            }
          }
          return e;
        }
        setLoader(t) {
          this.loader_ = t;
        }
        setUrl(t) {
          We(this.format_, '`format` must be set when `url` is set'),
            (this.url_ = t),
            this.setLoader(xh(t, this.format_));
        }
      },
      Sh = class {
        constructor(t) {
          (this.highWaterMark = void 0 !== t ? t : 2048),
            (this.count_ = 0),
            (this.entries_ = {}),
            (this.oldest_ = null),
            (this.newest_ = null);
        }
        canExpireCache() {
          return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
        }
        expireCache(t) {
          for (; this.canExpireCache(); ) this.pop();
        }
        clear() {
          (this.count_ = 0), (this.entries_ = {}), (this.oldest_ = null), (this.newest_ = null);
        }
        containsKey(t) {
          return this.entries_.hasOwnProperty(t);
        }
        forEach(t) {
          let e = this.oldest_;
          for (; e; ) t(e.value_, e.key_, this), (e = e.newer);
        }
        get(t, e) {
          const i = this.entries_[t];
          return (
            We(void 0 !== i, 'Tried to get a value for a key that does not exist in the cache'),
            i === this.newest_ ||
              (i === this.oldest_
                ? ((this.oldest_ = this.oldest_.newer), (this.oldest_.older = null))
                : ((i.newer.older = i.older), (i.older.newer = i.newer)),
              (i.newer = null),
              (i.older = this.newest_),
              (this.newest_.newer = i),
              (this.newest_ = i)),
            i.value_
          );
        }
        remove(t) {
          const e = this.entries_[t];
          return (
            We(void 0 !== e, 'Tried to get a value for a key that does not exist in the cache'),
            e === this.newest_
              ? ((this.newest_ = e.older), this.newest_ && (this.newest_.newer = null))
              : e === this.oldest_
                ? ((this.oldest_ = e.newer), this.oldest_ && (this.oldest_.older = null))
                : ((e.newer.older = e.older), (e.older.newer = e.newer)),
            delete this.entries_[t],
            --this.count_,
            e.value_
          );
        }
        getCount() {
          return this.count_;
        }
        getKeys() {
          const t = new Array(this.count_);
          let e,
            i = 0;
          for (e = this.newest_; e; e = e.older) t[i++] = e.key_;
          return t;
        }
        getValues() {
          const t = new Array(this.count_);
          let e,
            i = 0;
          for (e = this.newest_; e; e = e.older) t[i++] = e.value_;
          return t;
        }
        peekLast() {
          return this.oldest_.value_;
        }
        peekLastKey() {
          return this.oldest_.key_;
        }
        peekFirstKey() {
          return this.newest_.key_;
        }
        peek(t) {
          return this.entries_[t]?.value_;
        }
        pop() {
          const t = this.oldest_;
          return (
            delete this.entries_[t.key_],
            t.newer && (t.newer.older = null),
            (this.oldest_ = t.newer),
            this.oldest_ || (this.newest_ = null),
            --this.count_,
            t.value_
          );
        }
        replace(t, e) {
          this.get(t), (this.entries_[t].value_ = e);
        }
        set(t, e) {
          We(!(t in this.entries_), 'Tried to set a value for a key that is used already');
          const i = { key_: t, newer: null, older: this.newest_, value_: e };
          this.newest_ ? (this.newest_.newer = i) : (this.oldest_ = i),
            (this.newest_ = i),
            (this.entries_[t] = i),
            ++this.count_;
        }
        setSize(t) {
          this.highWaterMark = t;
        }
      };
    function Eh(t, e, i, n) {
      return void 0 !== n ? ((n[0] = t), (n[1] = e), (n[2] = i), n) : [t, e, i];
    }
    function Th(t, e, i) {
      return t + '/' + e + '/' + i;
    }
    function bh(t) {
      return Th(t[0], t[1], t[2]);
    }
    const Ih = class extends Sh {
        clear() {
          for (; this.getCount() > 0; ) this.pop().release();
          super.clear();
        }
        expireCache(t) {
          for (; this.canExpireCache() && !(this.peekLast().getKey() in t); ) this.pop().release();
        }
        pruneExceptNewestZ() {
          if (0 === this.getCount()) return;
          const t = this.peekFirstKey().split('/').map(Number)[0];
          this.forEach((e) => {
            e.tileCoord[0] !== t && (this.remove(bh(e.tileCoord)), e.release());
          });
        }
      },
      Rh = [0, 0, 0],
      Mh = class {
        constructor(t) {
          let e;
          if (
            ((this.minZoom = void 0 !== t.minZoom ? t.minZoom : 0),
            (this.resolutions_ = t.resolutions),
            We(
              (function (t, e, i) {
                const n = ((t, e) => e - t) || S;
                return t.every(function (e, i) {
                  if (0 === i) return !0;
                  const s = n(t[i - 1], e);
                  return !(s > 0 || 0 === s);
                });
              })(this.resolutions_),
              '`resolutions` must be sorted in descending order',
            ),
            !t.origins)
          )
            for (let t = 0, i = this.resolutions_.length - 1; t < i; ++t)
              if (e) {
                if (this.resolutions_[t] / this.resolutions_[t + 1] !== e) {
                  e = void 0;
                  break;
                }
              } else e = this.resolutions_[t] / this.resolutions_[t + 1];
          (this.zoomFactor_ = e),
            (this.maxZoom = this.resolutions_.length - 1),
            (this.origin_ = void 0 !== t.origin ? t.origin : null),
            (this.origins_ = null),
            void 0 !== t.origins &&
              ((this.origins_ = t.origins),
              We(
                this.origins_.length == this.resolutions_.length,
                'Number of `origins` and `resolutions` must be equal',
              ));
          const i = t.extent;
          void 0 === i || this.origin_ || this.origins_ || (this.origin_ = Kt(i)),
            We(
              (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),
              'Either `origin` or `origins` must be configured, never both',
            ),
            (this.tileSizes_ = null),
            void 0 !== t.tileSizes &&
              ((this.tileSizes_ = t.tileSizes),
              We(
                this.tileSizes_.length == this.resolutions_.length,
                'Number of `tileSizes` and `resolutions` must be equal',
              )),
            (this.tileSize_ = void 0 !== t.tileSize ? t.tileSize : this.tileSizes_ ? null : tt),
            We(
              (!this.tileSize_ && this.tileSizes_) || (this.tileSize_ && !this.tileSizes_),
              'Either `tileSize` or `tileSizes` must be configured, never both',
            ),
            (this.extent_ = void 0 !== i ? i : null),
            (this.fullTileRanges_ = null),
            (this.tmpSize_ = [0, 0]),
            (this.tmpExtent_ = [0, 0, 0, 0]),
            void 0 !== t.sizes
              ? (this.fullTileRanges_ = t.sizes.map((t, e) => {
                  const n = new oh(
                    Math.min(0, t[0]),
                    Math.max(t[0] - 1, -1),
                    Math.min(0, t[1]),
                    Math.max(t[1] - 1, -1),
                  );
                  if (i) {
                    const t = this.getTileRangeForExtentAndZ(i, e);
                    (n.minX = Math.max(t.minX, n.minX)),
                      (n.maxX = Math.min(t.maxX, n.maxX)),
                      (n.minY = Math.max(t.minY, n.minY)),
                      (n.maxY = Math.min(t.maxY, n.maxY));
                  }
                  return n;
                }))
              : i && this.calculateTileRanges_(i);
        }
        forEachTileCoord(t, e, i) {
          const n = this.getTileRangeForExtentAndZ(t, e);
          for (let t = n.minX, s = n.maxX; t <= s; ++t) for (let s = n.minY, r = n.maxY; s <= r; ++s) i([e, t, s]);
        }
        forEachTileCoordParentTileRange(t, e, i, n) {
          let s,
            r,
            o,
            a = null,
            h = t[0] - 1;
          for (
            2 === this.zoomFactor_ ? ((r = t[1]), (o = t[2])) : (a = this.getTileCoordExtent(t, n));
            h >= this.minZoom;

          ) {
            if (
              (void 0 !== r && void 0 !== o
                ? ((r = Math.floor(r / 2)), (o = Math.floor(o / 2)), (s = rh(r, r, o, o, i)))
                : (s = this.getTileRangeForExtentAndZ(a, h, i)),
              e(h, s))
            )
              return !0;
            --h;
          }
          return !1;
        }
        getExtent() {
          return this.extent_;
        }
        getMaxZoom() {
          return this.maxZoom;
        }
        getMinZoom() {
          return this.minZoom;
        }
        getOrigin(t) {
          return this.origin_ ? this.origin_ : this.origins_[t];
        }
        getResolution(t) {
          return this.resolutions_[t];
        }
        getResolutions() {
          return this.resolutions_;
        }
        getTileCoordChildTileRange(t, e, i) {
          if (t[0] < this.maxZoom) {
            if (2 === this.zoomFactor_) {
              const i = 2 * t[1],
                n = 2 * t[2];
              return rh(i, i + 1, n, n + 1, e);
            }
            const n = this.getTileCoordExtent(t, i || this.tmpExtent_);
            return this.getTileRangeForExtentAndZ(n, t[0] + 1, e);
          }
          return null;
        }
        getTileRangeForTileCoordAndZ(t, e, i) {
          if (e > this.maxZoom || e < this.minZoom) return null;
          const n = t[0],
            s = t[1],
            r = t[2];
          if (e === n) return rh(s, r, s, r, i);
          if (this.zoomFactor_) {
            const t = Math.pow(this.zoomFactor_, e - n),
              o = Math.floor(s * t),
              a = Math.floor(r * t);
            return e < n ? rh(o, o, a, a, i) : rh(o, Math.floor(t * (s + 1)) - 1, a, Math.floor(t * (r + 1)) - 1, i);
          }
          const o = this.getTileCoordExtent(t, this.tmpExtent_);
          return this.getTileRangeForExtentAndZ(o, e, i);
        }
        getTileRangeForExtentAndZ(t, e, i) {
          this.getTileCoordForXYAndZ_(t[0], t[3], e, !1, Rh);
          const n = Rh[1],
            s = Rh[2];
          return this.getTileCoordForXYAndZ_(t[2], t[1], e, !0, Rh), rh(n, Rh[1], s, Rh[2], i);
        }
        getTileCoordCenter(t) {
          const e = this.getOrigin(t[0]),
            i = this.getResolution(t[0]),
            n = Lr(this.getTileSize(t[0]), this.tmpSize_);
          return [e[0] + (t[1] + 0.5) * n[0] * i, e[1] - (t[2] + 0.5) * n[1] * i];
        }
        getTileCoordExtent(t, e) {
          const i = this.getOrigin(t[0]),
            n = this.getResolution(t[0]),
            s = Lr(this.getTileSize(t[0]), this.tmpSize_),
            r = i[0] + t[1] * s[0] * n,
            o = i[1] - (t[2] + 1) * s[1] * n;
          return bt(r, o, r + s[0] * n, o + s[1] * n, e);
        }
        getTileCoordForCoordAndResolution(t, e, i) {
          return this.getTileCoordForXYAndResolution_(t[0], t[1], e, !1, i);
        }
        getTileCoordForXYAndResolution_(t, e, i, n, s) {
          const r = this.getZForResolution(i),
            o = i / this.getResolution(r),
            a = this.getOrigin(r),
            h = Lr(this.getTileSize(r), this.tmpSize_);
          let l = (o * (t - a[0])) / i / h[0],
            c = (o * (a[1] - e)) / i / h[1];
          return n ? ((l = ce(l, 5) - 1), (c = ce(c, 5) - 1)) : ((l = le(l, 5)), (c = le(c, 5))), Eh(r, l, c, s);
        }
        getTileCoordForXYAndZ_(t, e, i, n, s) {
          const r = this.getOrigin(i),
            o = this.getResolution(i),
            a = Lr(this.getTileSize(i), this.tmpSize_);
          let h = (t - r[0]) / o / a[0],
            l = (r[1] - e) / o / a[1];
          return n ? ((h = ce(h, 5) - 1), (l = ce(l, 5) - 1)) : ((h = le(h, 5)), (l = le(l, 5))), Eh(i, h, l, s);
        }
        getTileCoordForCoordAndZ(t, e, i) {
          return this.getTileCoordForXYAndZ_(t[0], t[1], e, !1, i);
        }
        getTileCoordResolution(t) {
          return this.resolutions_[t[0]];
        }
        getTileSize(t) {
          return this.tileSize_ ? this.tileSize_ : this.tileSizes_[t];
        }
        getFullTileRange(t) {
          return this.fullTileRanges_
            ? this.fullTileRanges_[t]
            : this.extent_
              ? this.getTileRangeForExtentAndZ(this.extent_, t)
              : null;
        }
        getZForResolution(t, e) {
          return ie(E(this.resolutions_, t, e || 0), this.minZoom, this.maxZoom);
        }
        tileCoordIntersectsViewport(t, e) {
          return Zi(e, 0, e.length, 2, this.getTileCoordExtent(t));
        }
        calculateTileRanges_(t) {
          const e = this.resolutions_.length,
            i = new Array(e);
          for (let n = this.minZoom; n < e; ++n) i[n] = this.getTileRangeForExtentAndZ(t, n);
          this.fullTileRanges_ = i;
        }
      };
    function Ph(t) {
      let e = t.getDefaultTileGrid();
      return (
        e ||
          ((e = (function (t, e, i, n) {
            return (function (t, e, i, n) {
              n = void 0 !== n ? n : 'top-left';
              const s = Lh(t, undefined, i);
              return new Mh({ extent: t, origin: Wt(t, n), resolutions: s, tileSize: i });
            })(Fh(t), 0, void 0, void 0);
          })(t)),
          t.setDefaultTileGrid(e)),
        e
      );
    }
    function Lh(t, e, i, n) {
      (e = void 0 !== e ? e : Q), (i = Lr(void 0 !== i ? i : tt));
      const s = Yt(t),
        r = Vt(t);
      n = n > 0 ? n : Math.max(r / i[0], s / i[1]);
      const o = e + 1,
        a = new Array(o);
      for (let t = 0; t < o; ++t) a[t] = n / Math.pow(2, t);
      return a;
    }
    function Fh(t) {
      let e = (t = we(t)).getExtent();
      if (!e) {
        const i = (180 * et.degrees) / t.getMetersPerUnit();
        e = bt(-i, -i, i, i);
      }
      return e;
    }
    class kh extends x {
      constructor(t, e) {
        super(t), (this.tile = e);
      }
    }
    const Ah = class extends ph {
      constructor(t) {
        super({
          attributions: t.attributions,
          attributionsCollapsible: t.attributionsCollapsible,
          projection: t.projection,
          state: t.state,
          wrapX: t.wrapX,
          interpolate: t.interpolate,
        }),
          this.on,
          this.once,
          this.un,
          (this.opaque_ = void 0 !== t.opaque && t.opaque),
          (this.tilePixelRatio_ = void 0 !== t.tilePixelRatio ? t.tilePixelRatio : 1),
          (this.tileGrid = void 0 !== t.tileGrid ? t.tileGrid : null);
        this.tileGrid && Lr(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), [256, 256]),
          (this.tileCache = new Ih(t.cacheSize || 0)),
          (this.tmpSize = [0, 0]),
          (this.key_ = t.key || ''),
          (this.tileOptions = { transition: t.transition, interpolate: t.interpolate }),
          (this.zDirection = t.zDirection ? t.zDirection : 0);
      }
      canExpireCache() {
        return this.tileCache.canExpireCache();
      }
      expireCache(t, e) {
        const i = this.getTileCacheForProjection(t);
        i && i.expireCache(e);
      }
      forEachLoadedTile(t, e, i, n) {
        const s = this.getTileCacheForProjection(t);
        if (!s) return !1;
        let r,
          o,
          a,
          h = !0;
        for (let t = i.minX; t <= i.maxX; ++t)
          for (let l = i.minY; l <= i.maxY; ++l)
            (o = Th(e, t, l)),
              (a = !1),
              s.containsKey(o) && ((r = s.get(o)), (a = 2 === r.getState()), a && (a = !1 !== n(r))),
              a || (h = !1);
        return h;
      }
      getGutterForProjection(t) {
        return 0;
      }
      getKey() {
        return this.key_;
      }
      setKey(t) {
        this.key_ !== t && ((this.key_ = t), this.changed());
      }
      getOpaque(t) {
        return this.opaque_;
      }
      getResolutions(t) {
        const e = t ? this.getTileGridForProjection(t) : this.tileGrid;
        return e ? e.getResolutions() : null;
      }
      getTile(t, e, i, n, s) {
        return V();
      }
      getTileGrid() {
        return this.tileGrid;
      }
      getTileGridForProjection(t) {
        return this.tileGrid ? this.tileGrid : Ph(t);
      }
      getTileCacheForProjection(t) {
        const e = this.getProjection();
        return (
          We(
            null === e || be(e, t),
            'A VectorTile source can only be rendered if it has a projection compatible with the view projection.',
          ),
          this.tileCache
        );
      }
      getTilePixelRatio(t) {
        return this.tilePixelRatio_;
      }
      getTilePixelSize(t, e, i) {
        const n = this.getTileGridForProjection(i),
          s = this.getTilePixelRatio(e),
          r = Lr(n.getTileSize(t), this.tmpSize);
        return 1 == s
          ? r
          : ((o = r),
            (a = s),
            void 0 === (h = this.tmpSize) && (h = [0, 0]),
            (h[0] = (o[0] * a + 0.5) | 0),
            (h[1] = (o[1] * a + 0.5) | 0),
            h);
        var o, a, h;
      }
      getTileCoordForTileUrlFunction(t, e) {
        e = void 0 !== e ? e : this.getProjection();
        const i = this.getTileGridForProjection(e);
        return (
          this.getWrapX() &&
            e.isGlobal() &&
            (t = (function (t, e, i) {
              const n = e[0],
                s = t.getTileCoordCenter(e),
                r = Fh(i);
              if (!Ct(r, s)) {
                const e = Vt(r),
                  i = Math.ceil((r[0] - s[0]) / e);
                return (s[0] += e * i), t.getTileCoordForCoordAndZ(s, n);
              }
              return e;
            })(i, t, e)),
          (function (t, e) {
            const i = t[0],
              n = t[1],
              s = t[2];
            if (e.getMinZoom() > i || i > e.getMaxZoom()) return !1;
            const r = e.getFullTileRange(i);
            return !r || r.containsXY(n, s);
          })(t, i)
            ? t
            : null
        );
      }
      clear() {
        this.tileCache.clear();
      }
      refresh() {
        this.clear(), super.refresh();
      }
      updateCacheSize(t, e) {
        const i = this.getTileCacheForProjection(e);
        t > i.highWaterMark && (i.highWaterMark = t);
      }
      useTile(t, e, i, n) {}
    };
    function Oh(t, e) {
      const i = /\{z\}/g,
        n = /\{x\}/g,
        s = /\{y\}/g,
        r = /\{-y\}/g;
      return function (o, a, h) {
        if (o)
          return t
            .replace(i, o[0].toString())
            .replace(n, o[1].toString())
            .replace(s, o[2].toString())
            .replace(r, function () {
              const t = o[0],
                i = e.getFullTileRange(t);
              if (!i) throw new Error('The {-y} placeholder requires a tile grid with extent');
              return (i.getHeight() - o[2] - 1).toString();
            });
      };
    }
    class Dh extends Ah {
      constructor(t) {
        super({
          attributions: t.attributions,
          cacheSize: t.cacheSize,
          opaque: t.opaque,
          projection: t.projection,
          state: t.state,
          tileGrid: t.tileGrid,
          tilePixelRatio: t.tilePixelRatio,
          wrapX: t.wrapX,
          transition: t.transition,
          interpolate: t.interpolate,
          key: t.key,
          attributionsCollapsible: t.attributionsCollapsible,
          zDirection: t.zDirection,
        }),
          (this.generateTileUrlFunction_ = this.tileUrlFunction === Dh.prototype.tileUrlFunction),
          (this.tileLoadFunction = t.tileLoadFunction),
          t.tileUrlFunction && (this.tileUrlFunction = t.tileUrlFunction),
          (this.urls = null),
          t.urls ? this.setUrls(t.urls) : t.url && this.setUrl(t.url),
          (this.tileLoadingKeys_ = {});
      }
      getTileLoadFunction() {
        return this.tileLoadFunction;
      }
      getTileUrlFunction() {
        return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction
          ? this.tileUrlFunction.bind(this)
          : this.tileUrlFunction;
      }
      getUrls() {
        return this.urls;
      }
      handleTileChange(t) {
        const e = t.target,
          i = U(e),
          n = e.getState();
        let s;
        1 == n
          ? ((this.tileLoadingKeys_[i] = !0), (s = 'tileloadstart'))
          : i in this.tileLoadingKeys_ &&
            (delete this.tileLoadingKeys_[i], (s = 3 == n ? 'tileloaderror' : 2 == n ? 'tileloadend' : void 0)),
          null != s && this.dispatchEvent(new kh(s, e));
      }
      setTileLoadFunction(t) {
        this.tileCache.clear(), (this.tileLoadFunction = t), this.changed();
      }
      setTileUrlFunction(t, e) {
        (this.tileUrlFunction = t), this.tileCache.pruneExceptNewestZ(), void 0 !== e ? this.setKey(e) : this.changed();
      }
      setUrl(t) {
        const e = (function (t) {
          const e = [];
          let i = /\{([a-z])-([a-z])\}/.exec(t);
          if (i) {
            const n = i[1].charCodeAt(0),
              s = i[2].charCodeAt(0);
            let r;
            for (r = n; r <= s; ++r) e.push(t.replace(i[0], String.fromCharCode(r)));
            return e;
          }
          if (((i = /\{(\d+)-(\d+)\}/.exec(t)), i)) {
            const n = parseInt(i[2], 10);
            for (let s = parseInt(i[1], 10); s <= n; s++) e.push(t.replace(i[0], s.toString()));
            return e;
          }
          return e.push(t), e;
        })(t);
        (this.urls = e), this.setUrls(e);
      }
      setUrls(t) {
        this.urls = t;
        const e = t.join('\n');
        this.generateTileUrlFunction_
          ? this.setTileUrlFunction(
              (function (t, e) {
                const i = t.length,
                  n = new Array(i);
                for (let s = 0; s < i; ++s) n[s] = Oh(t[s], e);
                return (function (t) {
                  return 1 === t.length
                    ? t[0]
                    : function (e, i, n) {
                        if (!e) return;
                        const s = (function (t) {
                            return (t[1] << t[0]) + t[2];
                          })(e),
                          r = oe(s, t.length);
                        return t[r](e, i, n);
                      };
                })(n);
              })(t, this.tileGrid),
              e,
            )
          : this.setKey(e);
      }
      tileUrlFunction(t, e, i) {}
      useTile(t, e, i) {
        const n = Th(t, e, i);
        this.tileCache.containsKey(n) && this.tileCache.get(n);
      }
    }
    const Gh = Dh;
    function Nh(t, e) {
      t.getImage().src = e;
    }
    const zh = class extends Gh {
        constructor(t) {
          super({
            attributions: t.attributions,
            cacheSize: t.cacheSize,
            opaque: t.opaque,
            projection: t.projection,
            state: t.state,
            tileGrid: t.tileGrid,
            tileLoadFunction: t.tileLoadFunction ? t.tileLoadFunction : Nh,
            tilePixelRatio: t.tilePixelRatio,
            tileUrlFunction: t.tileUrlFunction,
            url: t.url,
            urls: t.urls,
            wrapX: t.wrapX,
            transition: t.transition,
            interpolate: void 0 === t.interpolate || t.interpolate,
            key: t.key,
            attributionsCollapsible: t.attributionsCollapsible,
            zDirection: t.zDirection,
          }),
            (this.crossOrigin = void 0 !== t.crossOrigin ? t.crossOrigin : null),
            (this.tileClass = void 0 !== t.tileClass ? t.tileClass : Ha),
            (this.tileCacheForProjection = {}),
            (this.tileGridForProjection = {}),
            (this.reprojectionErrorThreshold_ = t.reprojectionErrorThreshold),
            (this.renderReprojectionEdges_ = !1);
        }
        canExpireCache() {
          if (this.tileCache.canExpireCache()) return !0;
          for (const t in this.tileCacheForProjection) if (this.tileCacheForProjection[t].canExpireCache()) return !0;
          return !1;
        }
        expireCache(t, e) {
          const i = this.getTileCacheForProjection(t);
          this.tileCache.expireCache(this.tileCache == i ? e : {});
          for (const t in this.tileCacheForProjection) {
            const n = this.tileCacheForProjection[t];
            n.expireCache(n == i ? e : {});
          }
        }
        getGutterForProjection(t) {
          return this.getProjection() && t && !be(this.getProjection(), t) ? 0 : this.getGutter();
        }
        getGutter() {
          return 0;
        }
        getKey() {
          let t = super.getKey();
          return this.getInterpolate() || (t += ':disable-interpolation'), t;
        }
        getOpaque(t) {
          return !(this.getProjection() && t && !be(this.getProjection(), t)) && super.getOpaque(t);
        }
        getTileGridForProjection(t) {
          const e = this.getProjection();
          if (this.tileGrid && (!e || be(e, t))) return this.tileGrid;
          const i = U(t);
          return (
            i in this.tileGridForProjection || (this.tileGridForProjection[i] = Ph(t)), this.tileGridForProjection[i]
          );
        }
        getTileCacheForProjection(t) {
          const e = this.getProjection();
          if (!e || be(e, t)) return this.tileCache;
          const i = U(t);
          return (
            i in this.tileCacheForProjection || (this.tileCacheForProjection[i] = new Ih(this.tileCache.highWaterMark)),
            this.tileCacheForProjection[i]
          );
        }
        createTile_(t, e, i, n, s, r) {
          const o = [t, e, i],
            a = this.getTileCoordForTileUrlFunction(o, s),
            h = a ? this.tileUrlFunction(a, n, s) : void 0,
            l = new this.tileClass(
              o,
              void 0 !== h ? 0 : 4,
              void 0 !== h ? h : '',
              this.crossOrigin,
              this.tileLoadFunction,
              this.tileOptions,
            );
          return (l.key = r), l.addEventListener(O, this.handleTileChange.bind(this)), l;
        }
        getTile(t, e, i, n, s) {
          const r = this.getProjection();
          if (!r || !s || be(r, s)) return this.getTileInternal(t, e, i, n, r || s);
          const o = this.getTileCacheForProjection(s),
            a = [t, e, i];
          let h;
          const l = bh(a);
          o.containsKey(l) && (h = o.get(l));
          const c = this.getKey();
          if (h && h.key == c) return h;
          const u = this.getTileGridForProjection(r),
            d = this.getTileGridForProjection(s),
            g = this.getTileCoordForTileUrlFunction(a, s),
            f = new nh(
              r,
              u,
              s,
              d,
              a,
              g,
              this.getTilePixelRatio(n),
              this.getGutter(),
              (t, e, i, n) => this.getTileInternal(t, e, i, n, r),
              this.reprojectionErrorThreshold_,
              this.renderReprojectionEdges_,
              this.tileOptions,
            );
          return (f.key = c), h ? ((f.interimTile = h), f.refreshInterimChain(), o.replace(l, f)) : o.set(l, f), f;
        }
        getTileInternal(t, e, i, n, s) {
          let r = null;
          const o = Th(t, e, i),
            a = this.getKey();
          if (this.tileCache.containsKey(o)) {
            if (((r = this.tileCache.get(o)), r.key != a)) {
              const h = r;
              (r = this.createTile_(t, e, i, n, s, a)),
                0 == h.getState() ? (r.interimTile = h.interimTile) : (r.interimTile = h),
                r.refreshInterimChain(),
                this.tileCache.replace(o, r);
            }
          } else (r = this.createTile_(t, e, i, n, s, a)), this.tileCache.set(o, r);
          return r;
        }
        setRenderReprojectionEdges(t) {
          if (this.renderReprojectionEdges_ != t) {
            this.renderReprojectionEdges_ = t;
            for (const t in this.tileCacheForProjection) this.tileCacheForProjection[t].clear();
            this.changed();
          }
        }
        setTileGridForProjection(t, e) {
          const i = we(t);
          if (i) {
            const t = U(i);
            t in this.tileGridForProjection || (this.tileGridForProjection[t] = e);
          }
        }
        clear() {
          super.clear();
          for (const t in this.tileCacheForProjection) this.tileCacheForProjection[t].clear();
        }
      },
      Wh = class extends zh {
        constructor(t) {
          const e = void 0 !== (t = t || {}).projection ? t.projection : 'EPSG:3857',
            i =
              void 0 !== t.tileGrid
                ? t.tileGrid
                : (function (t) {
                    const e = t || {},
                      i = e.extent || we('EPSG:3857').getExtent(),
                      n = {
                        extent: i,
                        minZoom: e.minZoom,
                        tileSize: e.tileSize,
                        resolutions: Lh(i, e.maxZoom, e.tileSize, e.maxResolution),
                      };
                    return new Mh(n);
                  })({
                    extent: Fh(e),
                    maxResolution: t.maxResolution,
                    maxZoom: t.maxZoom,
                    minZoom: t.minZoom,
                    tileSize: t.tileSize,
                  });
          super({
            attributions: t.attributions,
            cacheSize: t.cacheSize,
            crossOrigin: t.crossOrigin,
            interpolate: t.interpolate,
            opaque: t.opaque,
            projection: e,
            reprojectionErrorThreshold: t.reprojectionErrorThreshold,
            tileGrid: i,
            tileLoadFunction: t.tileLoadFunction,
            tilePixelRatio: t.tilePixelRatio,
            tileUrlFunction: t.tileUrlFunction,
            url: t.url,
            urls: t.urls,
            wrapX: void 0 === t.wrapX || t.wrapX,
            transition: t.transition,
            attributionsCollapsible: t.attributionsCollapsible,
            zDirection: t.zDirection,
          }),
            (this.gutter_ = void 0 !== t.gutter ? t.gutter : 0);
        }
        getGutter() {
          return this.gutter_;
        }
      };
    class Xh extends pi {
      constructor(t, e) {
        super(),
          (this.flatMidpoint_ = null),
          (this.flatMidpointRevision_ = -1),
          (this.maxDelta_ = -1),
          (this.maxDeltaRevision_ = -1),
          void 0 === e || Array.isArray(t[0]) ? this.setCoordinates(t, e) : this.setFlatCoordinates(e, t);
      }
      appendCoordinate(t) {
        b(this.flatCoordinates, t), this.changed();
      }
      clone() {
        const t = new Xh(this.flatCoordinates.slice(), this.layout);
        return t.applyProperties(this), t;
      }
      closestPointXY(t, e, i, n) {
        return n < wt(this.getExtent(), t, e)
          ? n
          : (this.maxDeltaRevision_ != this.getRevision() &&
              ((this.maxDelta_ = Math.sqrt(yi(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0))),
              (this.maxDeltaRevision_ = this.getRevision())),
            xi(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, !1, t, e, i, n));
      }
      forEachSegment(t) {
        return Bi(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t);
      }
      getCoordinateAtM(t, e) {
        return 'XYM' != this.layout && 'XYZM' != this.layout
          ? null
          : ((e = void 0 !== e && e), ch(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e));
      }
      getCoordinates() {
        return Pi(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      }
      getCoordinateAt(t, e) {
        return lh(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e, this.stride);
      }
      getLength() {
        return Sa(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      }
      getFlatMidpoint() {
        return (
          this.flatMidpointRevision_ != this.getRevision() &&
            ((this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_ ?? void 0)),
            (this.flatMidpointRevision_ = this.getRevision())),
          this.flatMidpoint_
        );
      }
      getSimplifiedGeometryInternal(t) {
        const e = [];
        return (
          (e.length = Ti(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e, 0)), new Xh(e, 'XY')
        );
      }
      getType() {
        return 'LineString';
      }
      intersectsExtent(t) {
        return Ki(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t);
      }
      setCoordinates(t, e) {
        this.setLayout(e, t, 1),
          this.flatCoordinates || (this.flatCoordinates = []),
          (this.flatCoordinates.length = Si(this.flatCoordinates, 0, t, this.stride)),
          this.changed();
      }
    }
    const jh = Xh;
    class Yh extends pi {
      constructor(t, e, i) {
        super(),
          void 0 !== i && void 0 === e
            ? this.setFlatCoordinates(i, t)
            : ((e = e || 0), this.setCenterAndRadius(t, e, i));
      }
      clone() {
        const t = new Yh(this.flatCoordinates.slice(), void 0, this.layout);
        return t.applyProperties(this), t;
      }
      closestPointXY(t, e, i, n) {
        const s = this.flatCoordinates,
          r = t - s[0],
          o = e - s[1],
          a = r * r + o * o;
        if (a < n) {
          if (0 === a) for (let t = 0; t < this.stride; ++t) i[t] = s[t];
          else {
            const t = this.getRadius() / Math.sqrt(a);
            (i[0] = s[0] + t * r), (i[1] = s[1] + t * o);
            for (let t = 2; t < this.stride; ++t) i[t] = s[t];
          }
          return (i.length = this.stride), a;
        }
        return n;
      }
      containsXY(t, e) {
        const i = this.flatCoordinates,
          n = t - i[0],
          s = e - i[1];
        return n * n + s * s <= this.getRadiusSquared_();
      }
      getCenter() {
        return this.flatCoordinates.slice(0, this.stride);
      }
      computeExtent(t) {
        const e = this.flatCoordinates,
          i = e[this.stride] - e[0];
        return bt(e[0] - i, e[1] - i, e[0] + i, e[1] + i, t);
      }
      getRadius() {
        return Math.sqrt(this.getRadiusSquared_());
      }
      getRadiusSquared_() {
        const t = this.flatCoordinates[this.stride] - this.flatCoordinates[0],
          e = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
        return t * t + e * e;
      }
      getType() {
        return 'Circle';
      }
      intersectsExtent(t) {
        if (qt(t, this.getExtent())) {
          const e = this.getCenter();
          return (
            (t[0] <= e[0] && t[2] >= e[0]) ||
            (t[1] <= e[1] && t[3] >= e[1]) ||
            Ot(t, this.intersectsCoordinate.bind(this))
          );
        }
        return !1;
      }
      setCenter(t) {
        const e = this.stride,
          i = this.flatCoordinates[e] - this.flatCoordinates[0],
          n = t.slice();
        n[e] = n[0] + i;
        for (let i = 1; i < e; ++i) n[e + i] = t[i];
        this.setFlatCoordinates(this.layout, n), this.changed();
      }
      setCenterAndRadius(t, e, i) {
        this.setLayout(i, t, 0), this.flatCoordinates || (this.flatCoordinates = []);
        const n = this.flatCoordinates;
        let s = Ci(n, 0, t, this.stride);
        n[s++] = n[0] + e;
        for (let t = 1, e = this.stride; t < e; ++t) n[s++] = n[t];
        (n.length = s), this.changed();
      }
      getCoordinates() {
        return null;
      }
      setCoordinates(t, e) {}
      setRadius(t) {
        (this.flatCoordinates[this.stride] = this.flatCoordinates[0] + t), this.changed();
      }
      rotate(t, e) {
        const i = this.getCenter(),
          n = this.getStride();
        this.setCenter(di(i, 0, i.length, n, t, e, i)), this.changed();
      }
    }
    Yh.prototype.transform;
    const Bh = Yh;
    class Kh extends fi {
      constructor(t) {
        super(), (this.geometries_ = t || null), (this.changeEventsKeys_ = []), this.listenGeometriesChange_();
      }
      unlistenGeometriesChange_() {
        this.changeEventsKeys_.forEach(B), (this.changeEventsKeys_.length = 0);
      }
      listenGeometriesChange_() {
        if (this.geometries_)
          for (let t = 0, e = this.geometries_.length; t < e; ++t)
            this.changeEventsKeys_.push(j(this.geometries_[t], O, this.changed, this));
      }
      clone() {
        const t = new Kh(null);
        return t.setGeometries(this.geometries_), t.applyProperties(this), t;
      }
      closestPointXY(t, e, i, n) {
        if (n < wt(this.getExtent(), t, e)) return n;
        const s = this.geometries_;
        for (let r = 0, o = s.length; r < o; ++r) n = s[r].closestPointXY(t, e, i, n);
        return n;
      }
      containsXY(t, e) {
        const i = this.geometries_;
        for (let n = 0, s = i.length; n < s; ++n) if (i[n].containsXY(t, e)) return !0;
        return !1;
      }
      computeExtent(t) {
        It(t);
        const e = this.geometries_;
        for (let i = 0, n = e.length; i < n; ++i) Lt(t, e[i].getExtent());
        return t;
      }
      getGeometries() {
        return Zh(this.geometries_);
      }
      getGeometriesArray() {
        return this.geometries_;
      }
      getGeometriesArrayRecursive() {
        let t = [];
        const e = this.geometries_;
        for (let i = 0, n = e.length; i < n; ++i)
          e[i].getType() === this.getType() ? (t = t.concat(e[i].getGeometriesArrayRecursive())) : t.push(e[i]);
        return t;
      }
      getSimplifiedGeometry(t) {
        if (
          (this.simplifiedGeometryRevision !== this.getRevision() &&
            ((this.simplifiedGeometryMaxMinSquaredTolerance = 0),
            (this.simplifiedGeometryRevision = this.getRevision())),
          t < 0 ||
            (0 !== this.simplifiedGeometryMaxMinSquaredTolerance && t < this.simplifiedGeometryMaxMinSquaredTolerance))
        )
          return this;
        const e = [],
          i = this.geometries_;
        let n = !1;
        for (let s = 0, r = i.length; s < r; ++s) {
          const r = i[s],
            o = r.getSimplifiedGeometry(t);
          e.push(o), o !== r && (n = !0);
        }
        if (n) {
          const t = new Kh(null);
          return t.setGeometriesArray(e), t;
        }
        return (this.simplifiedGeometryMaxMinSquaredTolerance = t), this;
      }
      getType() {
        return 'GeometryCollection';
      }
      intersectsExtent(t) {
        const e = this.geometries_;
        for (let i = 0, n = e.length; i < n; ++i) if (e[i].intersectsExtent(t)) return !0;
        return !1;
      }
      isEmpty() {
        return 0 === this.geometries_.length;
      }
      rotate(t, e) {
        const i = this.geometries_;
        for (let n = 0, s = i.length; n < s; ++n) i[n].rotate(t, e);
        this.changed();
      }
      scale(t, e, i) {
        i || (i = zt(this.getExtent()));
        const n = this.geometries_;
        for (let s = 0, r = n.length; s < r; ++s) n[s].scale(t, e, i);
        this.changed();
      }
      setGeometries(t) {
        this.setGeometriesArray(Zh(t));
      }
      setGeometriesArray(t) {
        this.unlistenGeometriesChange_(), (this.geometries_ = t), this.listenGeometriesChange_(), this.changed();
      }
      applyTransform(t) {
        const e = this.geometries_;
        for (let i = 0, n = e.length; i < n; ++i) e[i].applyTransform(t);
        this.changed();
      }
      translate(t, e) {
        const i = this.geometries_;
        for (let n = 0, s = i.length; n < s; ++n) i[n].translate(t, e);
        this.changed();
      }
      disposeInternal() {
        this.unlistenGeometriesChange_(), super.disposeInternal();
      }
    }
    function Zh(t) {
      const e = [];
      for (let i = 0, n = t.length; i < n; ++i) e.push(t[i].clone());
      return e;
    }
    const Vh = Kh;
    class qh extends pi {
      constructor(t, e, i) {
        if ((super(), (this.ends_ = []), (this.maxDelta_ = -1), (this.maxDeltaRevision_ = -1), Array.isArray(t[0])))
          this.setCoordinates(t, e);
        else if (void 0 !== e && i) this.setFlatCoordinates(e, t), (this.ends_ = i);
        else {
          const e = t,
            i = [],
            n = [];
          for (let t = 0, s = e.length; t < s; ++t) b(i, e[t].getFlatCoordinates()), n.push(i.length);
          const s = 0 === e.length ? this.getLayout() : e[0].getLayout();
          this.setFlatCoordinates(s, i), (this.ends_ = n);
        }
      }
      appendLineString(t) {
        b(this.flatCoordinates, t.getFlatCoordinates().slice()),
          this.ends_.push(this.flatCoordinates.length),
          this.changed();
      }
      clone() {
        const t = new qh(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
        return t.applyProperties(this), t;
      }
      closestPointXY(t, e, i, n) {
        return n < wt(this.getExtent(), t, e)
          ? n
          : (this.maxDeltaRevision_ != this.getRevision() &&
              ((this.maxDelta_ = Math.sqrt(vi(this.flatCoordinates, 0, this.ends_, this.stride, 0))),
              (this.maxDeltaRevision_ = this.getRevision())),
            wi(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, !1, t, e, i, n));
      }
      getCoordinateAtM(t, e, i) {
        return ('XYM' != this.layout && 'XYZM' != this.layout) || 0 === this.flatCoordinates.length
          ? null
          : ((e = void 0 !== e && e),
            (i = void 0 !== i && i),
            (function (t, e, i, n, s, r, o) {
              if (o) return ch(t, e, i[i.length - 1], n, s, r);
              let a;
              if (s < t[n - 1]) return r ? ((a = t.slice(0, n)), (a[n - 1] = s), a) : null;
              if (t[t.length - 1] < s) return r ? ((a = t.slice(t.length - n)), (a[n - 1] = s), a) : null;
              for (let r = 0, o = i.length; r < o; ++r) {
                const o = i[r];
                if (e != o) {
                  if (s < t[e + n - 1]) return null;
                  if (s <= t[o - 1]) return ch(t, e, o, n, s, !1);
                  e = o;
                }
              }
              return null;
            })(this.flatCoordinates, 0, this.ends_, this.stride, t, e, i));
      }
      getCoordinates() {
        return Li(this.flatCoordinates, 0, this.ends_, this.stride);
      }
      getEnds() {
        return this.ends_;
      }
      getLineString(t) {
        return t < 0 || this.ends_.length <= t
          ? null
          : new jh(this.flatCoordinates.slice(0 === t ? 0 : this.ends_[t - 1], this.ends_[t]), this.layout);
      }
      getLineStrings() {
        const t = this.flatCoordinates,
          e = this.ends_,
          i = this.layout,
          n = [];
        let s = 0;
        for (let r = 0, o = e.length; r < o; ++r) {
          const o = e[r],
            a = new jh(t.slice(s, o), i);
          n.push(a), (s = o);
        }
        return n;
      }
      getFlatMidpoints() {
        const t = [],
          e = this.flatCoordinates;
        let i = 0;
        const n = this.ends_,
          s = this.stride;
        for (let r = 0, o = n.length; r < o; ++r) {
          const o = n[r];
          b(t, lh(e, i, o, s, 0.5)), (i = o);
        }
        return t;
      }
      getSimplifiedGeometryInternal(t) {
        const e = [],
          i = [];
        return (e.length = bi(this.flatCoordinates, 0, this.ends_, this.stride, t, e, 0, i)), new qh(e, 'XY', i);
      }
      getType() {
        return 'MultiLineString';
      }
      intersectsExtent(t) {
        return (function (t, e, i, n, s) {
          for (let r = 0, o = i.length; r < o; ++r) {
            if (Ki(t, e, i[r], n, s)) return !0;
            e = i[r];
          }
          return !1;
        })(this.flatCoordinates, 0, this.ends_, this.stride, t);
      }
      setCoordinates(t, e) {
        this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
        const i = Ei(this.flatCoordinates, 0, t, this.stride, this.ends_);
        (this.flatCoordinates.length = 0 === i.length ? 0 : i[i.length - 1]), this.changed();
      }
    }
    const Uh = qh;
    class Hh extends pi {
      constructor(t, e) {
        super(), e && !Array.isArray(t[0]) ? this.setFlatCoordinates(e, t) : this.setCoordinates(t, e);
      }
      appendPoint(t) {
        b(this.flatCoordinates, t.getFlatCoordinates()), this.changed();
      }
      clone() {
        const t = new Hh(this.flatCoordinates.slice(), this.layout);
        return t.applyProperties(this), t;
      }
      closestPointXY(t, e, i, n) {
        if (n < wt(this.getExtent(), t, e)) return n;
        const s = this.flatCoordinates,
          r = this.stride;
        for (let o = 0, a = s.length; o < a; o += r) {
          const a = se(t, e, s[o], s[o + 1]);
          if (a < n) {
            n = a;
            for (let t = 0; t < r; ++t) i[t] = s[o + t];
            i.length = r;
          }
        }
        return n;
      }
      getCoordinates() {
        return Pi(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      }
      getPoint(t) {
        const e = this.flatCoordinates.length / this.stride;
        return t < 0 || e <= t
          ? null
          : new Ni(this.flatCoordinates.slice(t * this.stride, (t + 1) * this.stride), this.layout);
      }
      getPoints() {
        const t = this.flatCoordinates,
          e = this.layout,
          i = this.stride,
          n = [];
        for (let s = 0, r = t.length; s < r; s += i) {
          const r = new Ni(t.slice(s, s + i), e);
          n.push(r);
        }
        return n;
      }
      getType() {
        return 'MultiPoint';
      }
      intersectsExtent(t) {
        const e = this.flatCoordinates,
          i = this.stride;
        for (let n = 0, s = e.length; n < s; n += i) if (Et(t, e[n], e[n + 1])) return !0;
        return !1;
      }
      setCoordinates(t, e) {
        this.setLayout(e, t, 1),
          this.flatCoordinates || (this.flatCoordinates = []),
          (this.flatCoordinates.length = Si(this.flatCoordinates, 0, t, this.stride)),
          this.changed();
      }
    }
    const $h = Hh;
    class Jh extends pi {
      constructor(t, e, i) {
        if (
          (super(),
          (this.endss_ = []),
          (this.flatInteriorPointsRevision_ = -1),
          (this.flatInteriorPoints_ = null),
          (this.maxDelta_ = -1),
          (this.maxDeltaRevision_ = -1),
          (this.orientedRevision_ = -1),
          (this.orientedFlatCoordinates_ = null),
          !i && !Array.isArray(t[0]))
        ) {
          const n = t,
            s = [],
            r = [];
          for (let t = 0, e = n.length; t < e; ++t) {
            const e = n[t],
              i = s.length,
              o = e.getEnds();
            for (let t = 0, e = o.length; t < e; ++t) o[t] += i;
            b(s, e.getFlatCoordinates()), r.push(o);
          }
          (e = 0 === n.length ? this.getLayout() : n[0].getLayout()), (t = s), (i = r);
        }
        void 0 !== e && i ? (this.setFlatCoordinates(e, t), (this.endss_ = i)) : this.setCoordinates(t, e);
      }
      appendPolygon(t) {
        let e;
        if (this.flatCoordinates) {
          const i = this.flatCoordinates.length;
          b(this.flatCoordinates, t.getFlatCoordinates()), (e = t.getEnds().slice());
          for (let t = 0, n = e.length; t < n; ++t) e[t] += i;
        } else (this.flatCoordinates = t.getFlatCoordinates().slice()), (e = t.getEnds().slice()), this.endss_.push();
        this.endss_.push(e), this.changed();
      }
      clone() {
        const t = this.endss_.length,
          e = new Array(t);
        for (let i = 0; i < t; ++i) e[i] = this.endss_[i].slice();
        const i = new Jh(this.flatCoordinates.slice(), this.layout, e);
        return i.applyProperties(this), i;
      }
      closestPointXY(t, e, i, n) {
        return n < wt(this.getExtent(), t, e)
          ? n
          : (this.maxDeltaRevision_ != this.getRevision() &&
              ((this.maxDelta_ = Math.sqrt(
                (function (t, e, i, n, s) {
                  for (let r = 0, o = i.length; r < o; ++r) {
                    const o = i[r];
                    (s = vi(t, e, o, n, s)), (e = o[o.length - 1]);
                  }
                  return s;
                })(this.flatCoordinates, 0, this.endss_, this.stride, 0),
              )),
              (this.maxDeltaRevision_ = this.getRevision())),
            (function (t, e, i, n, s, r, o, a, h, l, c) {
              c = c || [NaN, NaN];
              for (let r = 0, u = i.length; r < u; ++r) {
                const u = i[r];
                (l = wi(t, e, u, n, s, true, o, a, h, l, c)), (e = u[u.length - 1]);
              }
              return l;
            })(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, 0, t, e, i, n));
      }
      containsXY(t, e) {
        return (function (t, e, i, n, s, r) {
          if (0 === i.length) return !1;
          for (let o = 0, a = i.length; o < a; ++o) {
            const a = i[o];
            if (Xi(t, e, a, n, s, r)) return !0;
            e = a[a.length - 1];
          }
          return !1;
        })(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t, e);
      }
      getArea() {
        return (function (t, e, i, n) {
          let s = 0;
          for (let r = 0, o = i.length; r < o; ++r) {
            const o = i[r];
            (s += Ai(t, e, o, n)), (e = o[o.length - 1]);
          }
          return s;
        })(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
      }
      getCoordinates(t) {
        let e;
        return (
          void 0 !== t
            ? ((e = this.getOrientedFlatCoordinates().slice()), Ji(e, 0, this.endss_, this.stride, t))
            : (e = this.flatCoordinates),
          Fi(e, 0, this.endss_, this.stride)
        );
      }
      getEndss() {
        return this.endss_;
      }
      getFlatInteriorPoints() {
        if (this.flatInteriorPointsRevision_ != this.getRevision()) {
          const t = uh(this.flatCoordinates, 0, this.endss_, this.stride);
          (this.flatInteriorPoints_ = Yi(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t)),
            (this.flatInteriorPointsRevision_ = this.getRevision());
        }
        return this.flatInteriorPoints_;
      }
      getInteriorPoints() {
        return new $h(this.getFlatInteriorPoints().slice(), 'XYM');
      }
      getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
          const t = this.flatCoordinates;
          !(function (t, e, i, n, s) {
            for (let s = 0, r = i.length; s < r; ++s) {
              const r = i[s];
              if (!Hi(t, e, r, n, undefined)) return !1;
              r.length && (e = r[r.length - 1]);
            }
            return !0;
          })(t, 0, this.endss_, this.stride)
            ? ((this.orientedFlatCoordinates_ = t.slice()),
              (this.orientedFlatCoordinates_.length = Ji(this.orientedFlatCoordinates_, 0, this.endss_, this.stride)))
            : (this.orientedFlatCoordinates_ = t),
            (this.orientedRevision_ = this.getRevision());
        }
        return this.orientedFlatCoordinates_;
      }
      getSimplifiedGeometryInternal(t) {
        const e = [],
          i = [];
        return (
          (e.length = (function (t, e, i, n, s, r, o, a) {
            for (let h = 0, l = i.length; h < l; ++h) {
              const l = i[h],
                c = [];
              (o = Mi(t, e, l, n, s, r, o, c)), a.push(c), (e = l[l.length - 1]);
            }
            return o;
          })(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(t), e, 0, i)),
          new Jh(e, 'XY', i)
        );
      }
      getPolygon(t) {
        if (t < 0 || this.endss_.length <= t) return null;
        let e;
        if (0 === t) e = 0;
        else {
          const i = this.endss_[t - 1];
          e = i[i.length - 1];
        }
        const i = this.endss_[t].slice(),
          n = i[i.length - 1];
        if (0 !== e) for (let t = 0, n = i.length; t < n; ++t) i[t] -= e;
        return new tn(this.flatCoordinates.slice(e, n), this.layout, i);
      }
      getPolygons() {
        const t = this.layout,
          e = this.flatCoordinates,
          i = this.endss_,
          n = [];
        let s = 0;
        for (let r = 0, o = i.length; r < o; ++r) {
          const o = i[r].slice(),
            a = o[o.length - 1];
          if (0 !== s) for (let t = 0, e = o.length; t < e; ++t) o[t] -= s;
          const h = new tn(e.slice(s, a), t, o);
          n.push(h), (s = a);
        }
        return n;
      }
      getType() {
        return 'MultiPolygon';
      }
      intersectsExtent(t) {
        return (function (t, e, i, n, s) {
          for (let r = 0, o = i.length; r < o; ++r) {
            const o = i[r];
            if (Vi(t, e, o, n, s)) return !0;
            e = o[o.length - 1];
          }
          return !1;
        })(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t);
      }
      setCoordinates(t, e) {
        this.setLayout(e, t, 3), this.flatCoordinates || (this.flatCoordinates = []);
        const i = (function (t, e, i, n, s) {
          s = s || [];
          let r = 0;
          for (let o = 0, a = i.length; o < a; ++o) {
            const a = Ei(t, e, i[o], n, s[r]);
            0 === a.length && (a[0] = e), (s[r++] = a), (e = a[a.length - 1]);
          }
          return (s.length = r), s;
        })(this.flatCoordinates, 0, t, this.stride, this.endss_);
        if (0 === i.length) this.flatCoordinates.length = 0;
        else {
          const t = i[i.length - 1];
          this.flatCoordinates.length = 0 === t.length ? 0 : t[t.length - 1];
        }
        this.changed();
      }
    }
    const Qh = Jh,
      tl = 'drawstart';
    class el extends x {
      constructor(t, e) {
        super(t), (this.feature = e);
      }
    }
    function il(t, e) {
      return se(t[0], t[1], e[0], e[1]);
    }
    function nl(t, e) {
      const i = t.length;
      return e < 0 ? t[e + i] : e >= i ? t[e - i] : t[e];
    }
    function sl(t, e, i) {
      let n, s;
      e < i ? ((n = e), (s = i)) : ((n = i), (s = e));
      const r = Math.ceil(n),
        o = Math.floor(s);
      if (r > o) return il(cl(t, n), cl(t, s));
      let a = 0;
      n < r && (a += il(cl(t, n), nl(t, r))), o < s && (a += il(nl(t, o), cl(t, s)));
      for (let e = r; e < o - 1; ++e) a += il(nl(t, e), nl(t, e + 1));
      return a;
    }
    function rl(t, e, i) {
      if (e instanceof jh) al(t, e.getCoordinates(), !1, i);
      else if (e instanceof Uh) {
        const n = e.getCoordinates();
        for (let e = 0, s = n.length; e < s; ++e) al(t, n[e], !1, i);
      } else if (e instanceof tn) {
        const n = e.getCoordinates();
        for (let e = 0, s = n.length; e < s; ++e) al(t, n[e], !0, i);
      } else if (e instanceof Qh) {
        const n = e.getCoordinates();
        for (let e = 0, s = n.length; e < s; ++e) {
          const s = n[e];
          for (let e = 0, n = s.length; e < n; ++e) al(t, s[e], !0, i);
        }
      } else if (e instanceof Vh) {
        const n = e.getGeometries();
        for (let e = 0; e < n.length; ++e) rl(t, n[e], i);
      }
    }
    const ol = { index: -1, endIndex: NaN };
    function al(t, e, i, n) {
      const s = t[0],
        r = t[1];
      for (let t = 0, o = e.length - 1; t < o; ++t) {
        const o = ll(s, r, e[t], e[t + 1]);
        if (0 === o.squaredDistance) {
          const s = t + o.along;
          return void n.push({ coordinates: e, ring: i, startIndex: s, endIndex: s });
        }
      }
    }
    const hl = { along: 0, squaredDistance: 0 };
    function ll(t, e, i, n) {
      const s = i[0],
        r = i[1],
        o = n[0] - s,
        a = n[1] - r;
      let h = 0,
        l = s,
        c = r;
      return (
        (0 === o && 0 === a) ||
          ((h = ie(((t - s) * o + (e - r) * a) / (o * o + a * a), 0, 1)), (l += o * h), (c += a * h)),
        (hl.along = h),
        (hl.squaredDistance = he(se(t, e, l, c), 10)),
        hl
      );
    }
    function cl(t, e) {
      const i = t.length;
      let n = Math.floor(e);
      const s = e - n;
      n >= i ? (n -= i) : n < 0 && (n += i);
      let r = n + 1;
      r >= i && (r -= i);
      const o = t[n],
        a = o[0],
        h = o[1],
        l = t[r];
      return [a + (l[0] - a) * s, h + (l[1] - h) * s];
    }
    function ul() {
      const t = (function () {
        const t = {},
          e = [255, 255, 255, 1],
          i = [0, 153, 255, 1];
        return (
          (t.Polygon = [new qr({ fill: new Kr({ color: [255, 255, 255, 0.5] }) })]),
          (t.MultiPolygon = t.Polygon),
          (t.LineString = [
            new qr({ stroke: new Vr({ color: e, width: 5 }) }),
            new qr({ stroke: new Vr({ color: i, width: 3 }) }),
          ]),
          (t.MultiLineString = t.LineString),
          (t.Circle = t.Polygon.concat(t.LineString)),
          (t.Point = [
            new qr({
              image: new Yr({ radius: 6, fill: new Kr({ color: i }), stroke: new Vr({ color: e, width: 1.5 }) }),
              zIndex: 1 / 0,
            }),
          ]),
          (t.MultiPoint = t.Point),
          (t.GeometryCollection = t.Polygon.concat(t.LineString, t.Point)),
          t
        );
      })();
      return function (e, i) {
        return t[e.getGeometry().getType()];
      };
    }
    var dl = document.getElementById('north'),
      gl = document.getElementById('south'),
      fl = document.getElementById('east'),
      _l = document.getElementById('west'),
      pl = new Ch(),
      ml = new (class extends $ {
        constructor(t) {
          super(), (t = t || {}), this.on, this.once, this.un;
          const e = (function (t) {
            let e = null;
            void 0 !== t.keyboardEventTarget &&
              (e =
                'string' == typeof t.keyboardEventTarget
                  ? document.getElementById(t.keyboardEventTarget)
                  : t.keyboardEventTarget);
            const i = {},
              n = t.layers && 'function' == typeof t.layers.getLayers ? t.layers : new Fs({ layers: t.layers });
            let s, r, o;
            return (
              (i[Xs] = n),
              (i[Ys] = t.target),
              (i[Bs] = t.view instanceof on ? t.view : new on()),
              void 0 !== t.controls &&
                (Array.isArray(t.controls)
                  ? (s = new un(t.controls.slice()))
                  : (We(
                      'function' == typeof t.controls.getArray,
                      'Expected `controls` to be an array or an `ol/Collection.js`',
                    ),
                    (s = t.controls))),
              void 0 !== t.interactions &&
                (Array.isArray(t.interactions)
                  ? (r = new un(t.interactions.slice()))
                  : (We(
                      'function' == typeof t.interactions.getArray,
                      'Expected `interactions` to be an array or an `ol/Collection.js`',
                    ),
                    (r = t.interactions))),
              void 0 !== t.overlays
                ? Array.isArray(t.overlays)
                  ? (o = new un(t.overlays.slice()))
                  : (We(
                      'function' == typeof t.overlays.getArray,
                      'Expected `overlays` to be an array or an `ol/Collection.js`',
                    ),
                    (o = t.overlays))
                : (o = new un()),
              { controls: s, interactions: r, keyboardEventTarget: e, overlays: o, values: i }
            );
          })(t);
          this.renderComplete_,
            (this.loaded_ = !0),
            (this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this)),
            (this.maxTilesLoading_ = void 0 !== t.maxTilesLoading ? t.maxTilesLoading : 16),
            (this.pixelRatio_ = void 0 !== t.pixelRatio ? t.pixelRatio : ii),
            this.postRenderTimeoutHandle_,
            this.animationDelayKey_,
            (this.animationDelay_ = this.animationDelay_.bind(this)),
            (this.coordinateToPixelTransform_ = [1, 0, 0, 1, 0, 0]),
            (this.pixelToCoordinateTransform_ = [1, 0, 0, 1, 0, 0]),
            (this.frameIndex_ = 0),
            (this.frameState_ = null),
            (this.previousExtent_ = null),
            (this.viewPropertyListenerKey_ = null),
            (this.viewChangeListenerKey_ = null),
            (this.layerGroupPropertyListenerKeys_ = null),
            (this.viewport_ = document.createElement('div')),
            (this.viewport_.className = 'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '')),
            (this.viewport_.style.position = 'relative'),
            (this.viewport_.style.overflow = 'hidden'),
            (this.viewport_.style.width = '100%'),
            (this.viewport_.style.height = '100%'),
            (this.overlayContainer_ = document.createElement('div')),
            (this.overlayContainer_.style.position = 'absolute'),
            (this.overlayContainer_.style.zIndex = '0'),
            (this.overlayContainer_.style.width = '100%'),
            (this.overlayContainer_.style.height = '100%'),
            (this.overlayContainer_.style.pointerEvents = 'none'),
            (this.overlayContainer_.className = 'ol-overlaycontainer'),
            this.viewport_.appendChild(this.overlayContainer_),
            (this.overlayContainerStopEvent_ = document.createElement('div')),
            (this.overlayContainerStopEvent_.style.position = 'absolute'),
            (this.overlayContainerStopEvent_.style.zIndex = '0'),
            (this.overlayContainerStopEvent_.style.width = '100%'),
            (this.overlayContainerStopEvent_.style.height = '100%'),
            (this.overlayContainerStopEvent_.style.pointerEvents = 'none'),
            (this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent'),
            this.viewport_.appendChild(this.overlayContainerStopEvent_),
            (this.mapBrowserEventHandler_ = null),
            (this.moveTolerance_ = t.moveTolerance),
            (this.keyboardEventTarget_ = e.keyboardEventTarget),
            (this.targetChangeHandlerKeys_ = null),
            (this.targetElement_ = null),
            (this.resizeObserver_ = new ResizeObserver(() => this.updateSize())),
            (this.controls =
              e.controls ||
              (function (t) {
                t = t || {};
                const e = new un();
                return (
                  (void 0 === t.zoom || t.zoom) && e.push(new $s(t.zoomOptions)),
                  (void 0 === t.rotate || t.rotate) && e.push(new Hs(t.rotateOptions)),
                  (void 0 === t.attribution || t.attribution) && e.push(new Us(t.attributionOptions)),
                  e
                );
              })()),
            (this.interactions =
              e.interactions ||
              (function (t) {
                t = t || {};
                const e = new un(),
                  i = new br(-0.005, 0.05, 100);
                return (
                  (void 0 === t.altShiftDragRotate || t.altShiftDragRotate) && e.push(new pr()),
                  (void 0 === t.doubleClickZoom || t.doubleClickZoom) &&
                    e.push(new er({ delta: t.zoomDelta, duration: t.zoomDuration })),
                  (void 0 === t.dragPan || t.dragPan) && e.push(new _r({ onFocusOnly: t.onFocusOnly, kinetic: i })),
                  (void 0 === t.pinchRotate || t.pinchRotate) && e.push(new Rr()),
                  (void 0 === t.pinchZoom || t.pinchZoom) && e.push(new Mr({ duration: t.zoomDuration })),
                  (void 0 === t.keyboard || t.keyboard) &&
                    (e.push(new Er()), e.push(new Tr({ delta: t.zoomDelta, duration: t.zoomDuration }))),
                  (void 0 === t.mouseWheelZoom || t.mouseWheelZoom) &&
                    e.push(new Ir({ onFocusOnly: t.onFocusOnly, duration: t.zoomDuration })),
                  (void 0 === t.shiftDragZoom || t.shiftDragZoom) && e.push(new xr({ duration: t.zoomDuration })),
                  e
                );
              })({ onFocusOnly: !0 })),
            (this.overlays_ = e.overlays),
            (this.overlayIdIndex_ = {}),
            (this.renderer_ = null),
            (this.postRenderFunctions_ = []),
            (this.tileQueue_ = new Vs(this.getTilePriority.bind(this), this.handleTileChange_.bind(this))),
            this.addChangeListener(Xs, this.handleLayerGroupChanged_),
            this.addChangeListener(Bs, this.handleViewChanged_),
            this.addChangeListener(js, this.handleSizeChanged_),
            this.addChangeListener(Ys, this.handleTargetChanged_),
            this.setProperties(e.values);
          const i = this;
          !t.view ||
            t.view instanceof on ||
            t.view.then(function (t) {
              i.setView(new on(t));
            }),
            this.controls.addEventListener(an, (t) => {
              t.element.setMap(this);
            }),
            this.controls.addEventListener(hn, (t) => {
              t.element.setMap(null);
            }),
            this.interactions.addEventListener(an, (t) => {
              t.element.setMap(this);
            }),
            this.interactions.addEventListener(hn, (t) => {
              t.element.setMap(null);
            }),
            this.overlays_.addEventListener(an, (t) => {
              this.addOverlayInternal_(t.element);
            }),
            this.overlays_.addEventListener(hn, (t) => {
              const e = t.element.getId();
              void 0 !== e && delete this.overlayIdIndex_[e.toString()], t.element.setMap(null);
            }),
            this.controls.forEach((t) => {
              t.setMap(this);
            }),
            this.interactions.forEach((t) => {
              t.setMap(this);
            }),
            this.overlays_.forEach(this.addOverlayInternal_.bind(this));
        }
        addControl(t) {
          this.getControls().push(t);
        }
        addInteraction(t) {
          this.getInteractions().push(t);
        }
        addLayer(t) {
          this.getLayerGroup().getLayers().push(t);
        }
        handleLayerAdd_(t) {
          kr(t.layer, this);
        }
        addOverlay(t) {
          this.getOverlays().push(t);
        }
        addOverlayInternal_(t) {
          const e = t.getId();
          void 0 !== e && (this.overlayIdIndex_[e.toString()] = t), t.setMap(this);
        }
        disposeInternal() {
          this.controls.clear(),
            this.interactions.clear(),
            this.overlays_.clear(),
            this.resizeObserver_.disconnect(),
            this.setTarget(null),
            super.disposeInternal();
        }
        forEachFeatureAtPixel(t, e, i) {
          if (!this.frameState_ || !this.renderer_) return;
          const n = this.getCoordinateFromPixelInternal(t),
            s = void 0 !== (i = void 0 !== i ? i : {}).hitTolerance ? i.hitTolerance : 0,
            r = void 0 !== i.layerFilter ? i.layerFilter : R,
            o = !1 !== i.checkWrapped;
          return this.renderer_.forEachFeatureAtCoordinate(n, this.frameState_, s, o, e, null, r, null);
        }
        getFeaturesAtPixel(t, e) {
          const i = [];
          return (
            this.forEachFeatureAtPixel(
              t,
              function (t) {
                i.push(t);
              },
              e,
            ),
            i
          );
        }
        getAllLayers() {
          const t = [];
          return (
            (function e(i) {
              i.forEach(function (i) {
                i instanceof Fs ? e(i.getLayers()) : t.push(i);
              });
            })(this.getLayers()),
            t
          );
        }
        hasFeatureAtPixel(t, e) {
          if (!this.frameState_ || !this.renderer_) return !1;
          const i = this.getCoordinateFromPixelInternal(t),
            n = void 0 !== (e = void 0 !== e ? e : {}).layerFilter ? e.layerFilter : R,
            s = void 0 !== e.hitTolerance ? e.hitTolerance : 0,
            r = !1 !== e.checkWrapped;
          return this.renderer_.hasFeatureAtCoordinate(i, this.frameState_, s, r, n, null);
        }
        getEventCoordinate(t) {
          return this.getCoordinateFromPixel(this.getEventPixel(t));
        }
        getEventCoordinateInternal(t) {
          return this.getCoordinateFromPixelInternal(this.getEventPixel(t));
        }
        getEventPixel(t) {
          const e = this.viewport_.getBoundingClientRect(),
            i = this.getSize(),
            n = e.width / i[0],
            s = e.height / i[1],
            r = 'changedTouches' in t ? t.changedTouches[0] : t;
          return [(r.clientX - e.left) / n, (r.clientY - e.top) / s];
        }
        getTarget() {
          return this.get(Ys);
        }
        getTargetElement() {
          return this.targetElement_;
        }
        getCoordinateFromPixel(t) {
          return Fe(this.getCoordinateFromPixelInternal(t), this.getView().getProjection());
        }
        getCoordinateFromPixelInternal(t) {
          const e = this.frameState_;
          return e ? oi(e.pixelToCoordinateTransform, t.slice()) : null;
        }
        getControls() {
          return this.controls;
        }
        getOverlays() {
          return this.overlays_;
        }
        getOverlayById(t) {
          const e = this.overlayIdIndex_[t.toString()];
          return void 0 !== e ? e : null;
        }
        getInteractions() {
          return this.interactions;
        }
        getLayerGroup() {
          return this.get(Xs);
        }
        setLayers(t) {
          const e = this.getLayerGroup();
          if (t instanceof un) return void e.setLayers(t);
          const i = e.getLayers();
          i.clear(), i.extend(t);
        }
        getLayers() {
          return this.getLayerGroup().getLayers();
        }
        getLoadingOrNotReady() {
          const t = this.getLayerGroup().getLayerStatesArray();
          for (let e = 0, i = t.length; e < i; ++e) {
            const i = t[e];
            if (!i.visible) continue;
            const n = i.layer.getRenderer();
            if (n && !n.ready) return !0;
            const s = i.layer.getSource();
            if (s && s.loading) return !0;
          }
          return !1;
        }
        getPixelFromCoordinate(t) {
          const e = ke(t, this.getView().getProjection());
          return this.getPixelFromCoordinateInternal(e);
        }
        getPixelFromCoordinateInternal(t) {
          const e = this.frameState_;
          return e ? oi(e.coordinateToPixelTransform, t.slice(0, 2)) : null;
        }
        getRenderer() {
          return this.renderer_;
        }
        getSize() {
          return this.get(js);
        }
        getView() {
          return this.get(Bs);
        }
        getViewport() {
          return this.viewport_;
        }
        getOverlayContainer() {
          return this.overlayContainer_;
        }
        getOverlayContainerStopEvent() {
          return this.overlayContainerStopEvent_;
        }
        getOwnerDocument() {
          const t = this.getTargetElement();
          return t ? t.ownerDocument : document;
        }
        getTilePriority(t, e, i, n) {
          return (function (t, e, i, n, s) {
            if (!t || !(i in t.wantedTiles)) return Ks;
            if (!t.wantedTiles[i][e.getKey()]) return Ks;
            const r = t.viewState.center,
              o = n[0] - r[0],
              a = n[1] - r[1];
            return 65536 * Math.log(s) + Math.sqrt(o * o + a * a) / s;
          })(this.frameState_, t, e, i, n);
        }
        handleBrowserEvent(t, e) {
          e = e || t.type;
          const i = new As(e, this, t);
          this.handleMapBrowserEvent(i);
        }
        handleMapBrowserEvent(t) {
          if (!this.frameState_) return;
          const e = t.originalEvent,
            i = e.type;
          if (i === Ds || i === X || i === N) {
            const t = this.getOwnerDocument(),
              i = this.viewport_.getRootNode ? this.viewport_.getRootNode() : t,
              n = e.target;
            if (this.overlayContainerStopEvent_.contains(n) || !(i === t ? t.documentElement : i).contains(n)) return;
          }
          if (((t.frameState = this.frameState_), !1 !== this.dispatchEvent(t))) {
            const e = this.getInteractions().getArray().slice();
            for (let i = e.length - 1; i >= 0; i--) {
              const n = e[i];
              if (
                n.getMap() === this &&
                n.getActive() &&
                this.getTargetElement() &&
                (!n.handleEvent(t) || t.propagationStopped)
              )
                break;
            }
          }
        }
        handlePostRender() {
          const t = this.frameState_,
            e = this.tileQueue_;
          if (!e.isEmpty()) {
            let i = this.maxTilesLoading_,
              n = i;
            if (t) {
              const e = t.viewHints;
              if (e[0] || e[1]) {
                const e = Date.now() - t.time > 8;
                (i = e ? 0 : 8), (n = e ? 0 : 2);
              }
            }
            e.getTilesLoading() < i && (e.reprioritize(), e.loadMoreTiles(i, n));
          }
          t &&
            this.renderer_ &&
            !t.animate &&
            (!0 === this.renderComplete_
              ? (this.hasListener(Vn) && this.renderer_.dispatchRenderEvent(Vn, t),
                !1 === this.loaded_ && ((this.loaded_ = !0), this.dispatchEvent(new ks(Ws, this, t))))
              : !0 === this.loaded_ && ((this.loaded_ = !1), this.dispatchEvent(new ks(zs, this, t))));
          const i = this.postRenderFunctions_;
          for (let e = 0, n = i.length; e < n; ++e) i[e](this, t);
          i.length = 0;
        }
        handleSizeChanged_() {
          this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0), this.render();
        }
        handleTargetChanged_() {
          if (this.mapBrowserEventHandler_) {
            for (let t = 0, e = this.targetChangeHandlerKeys_.length; t < e; ++t) B(this.targetChangeHandlerKeys_[t]);
            (this.targetChangeHandlerKeys_ = null),
              this.viewport_.removeEventListener(D, this.boundHandleBrowserEvent_),
              this.viewport_.removeEventListener(X, this.boundHandleBrowserEvent_),
              this.mapBrowserEventHandler_.dispose(),
              (this.mapBrowserEventHandler_ = null),
              ls(this.viewport_);
          }
          if (this.targetElement_) {
            this.resizeObserver_.unobserve(this.targetElement_);
            const t = this.targetElement_.getRootNode();
            t instanceof ShadowRoot && this.resizeObserver_.unobserve(t.host), this.setSize(void 0);
          }
          const t = this.getTarget(),
            e = 'string' == typeof t ? document.getElementById(t) : t;
          if (((this.targetElement_ = e), e)) {
            e.appendChild(this.viewport_),
              this.renderer_ || (this.renderer_ = new Rs(this)),
              (this.mapBrowserEventHandler_ = new Gs(this, this.moveTolerance_));
            for (const t in Os)
              this.mapBrowserEventHandler_.addEventListener(Os[t], this.handleMapBrowserEvent.bind(this));
            this.viewport_.addEventListener(D, this.boundHandleBrowserEvent_, !1),
              this.viewport_.addEventListener(X, this.boundHandleBrowserEvent_, !!ri && { passive: !1 });
            const t = this.keyboardEventTarget_ ? this.keyboardEventTarget_ : e;
            this.targetChangeHandlerKeys_ = [
              j(t, N, this.handleBrowserEvent, this),
              j(t, z, this.handleBrowserEvent, this),
            ];
            const i = e.getRootNode();
            i instanceof ShadowRoot && this.resizeObserver_.observe(i.host), this.resizeObserver_.observe(e);
          } else
            this.renderer_ &&
              (clearTimeout(this.postRenderTimeoutHandle_),
              (this.postRenderTimeoutHandle_ = void 0),
              (this.postRenderFunctions_.length = 0),
              this.renderer_.dispose(),
              (this.renderer_ = null)),
              this.animationDelayKey_ &&
                (cancelAnimationFrame(this.animationDelayKey_), (this.animationDelayKey_ = void 0));
          this.updateSize();
        }
        handleTileChange_() {
          this.render();
        }
        handleViewPropertyChanged_() {
          this.render();
        }
        handleViewChanged_() {
          this.viewPropertyListenerKey_ && (B(this.viewPropertyListenerKey_), (this.viewPropertyListenerKey_ = null)),
            this.viewChangeListenerKey_ && (B(this.viewChangeListenerKey_), (this.viewChangeListenerKey_ = null));
          const t = this.getView();
          t &&
            (this.updateViewportSize_(this.getSize()),
            (this.viewPropertyListenerKey_ = j(t, w, this.handleViewPropertyChanged_, this)),
            (this.viewChangeListenerKey_ = j(t, O, this.handleViewPropertyChanged_, this)),
            t.resolveConstraints(0)),
            this.render();
        }
        handleLayerGroupChanged_() {
          this.layerGroupPropertyListenerKeys_ &&
            (this.layerGroupPropertyListenerKeys_.forEach(B), (this.layerGroupPropertyListenerKeys_ = null));
          const t = this.getLayerGroup();
          t &&
            (this.handleLayerAdd_(new Ms('addlayer', t)),
            (this.layerGroupPropertyListenerKeys_ = [
              j(t, w, this.render, this),
              j(t, O, this.render, this),
              j(t, 'addlayer', this.handleLayerAdd_, this),
              j(t, 'removelayer', this.handleLayerRemove_, this),
            ])),
            this.render();
        }
        isRendered() {
          return !!this.frameState_;
        }
        animationDelay_() {
          (this.animationDelayKey_ = void 0), this.renderFrame_(Date.now());
        }
        renderSync() {
          this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_();
        }
        redrawText() {
          const t = this.getLayerGroup().getLayerStatesArray();
          for (let e = 0, i = t.length; e < i; ++e) {
            const i = t[e].layer;
            i.hasRenderer() && i.getRenderer().handleFontsChanged();
          }
        }
        render() {
          this.renderer_ &&
            void 0 === this.animationDelayKey_ &&
            (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_));
        }
        flushDeclutterItems() {
          const t = this.frameState_;
          t && this.renderer_.flushDeclutterItems(t);
        }
        removeControl(t) {
          return this.getControls().remove(t);
        }
        removeInteraction(t) {
          return this.getInteractions().remove(t);
        }
        removeLayer(t) {
          return this.getLayerGroup().getLayers().remove(t);
        }
        handleLayerRemove_(t) {
          Fr(t.layer);
        }
        removeOverlay(t) {
          return this.getOverlays().remove(t);
        }
        renderFrame_(t) {
          const e = this.getSize(),
            i = this.getView(),
            n = this.frameState_;
          let s = null;
          if (void 0 !== e && Pr(e) && i && i.isDef()) {
            const n = i.getHints(this.frameState_ ? this.frameState_.viewHints : void 0),
              r = i.getState();
            if (
              ((s = {
                animate: !1,
                coordinateToPixelTransform: this.coordinateToPixelTransform_,
                declutterTree: null,
                extent: Xt(r.center, r.resolution, r.rotation, e),
                index: this.frameIndex_++,
                layerIndex: 0,
                layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
                pixelRatio: this.pixelRatio_,
                pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
                postRenderFunctions: [],
                size: e,
                tileQueue: this.tileQueue_,
                time: t,
                usedTiles: {},
                viewState: r,
                viewHints: n,
                wantedTiles: {},
                mapId: U(this),
                renderTargets: {},
              }),
              r.nextCenter && r.nextResolution)
            ) {
              const t = isNaN(r.nextRotation) ? r.rotation : r.nextRotation;
              s.nextExtent = Xt(r.nextCenter, r.nextResolution, t, e);
            }
          }
          (this.frameState_ = s),
            this.renderer_.renderFrame(s),
            s &&
              (s.animate && this.render(),
              Array.prototype.push.apply(this.postRenderFunctions_, s.postRenderFunctions),
              n &&
                (!this.previousExtent_ || (!Ut(this.previousExtent_) && !Pt(s.extent, this.previousExtent_))) &&
                (this.dispatchEvent(new ks('movestart', this, n)), (this.previousExtent_ = It(this.previousExtent_))),
              this.previousExtent_ &&
                !s.viewHints[0] &&
                !s.viewHints[1] &&
                !Pt(s.extent, this.previousExtent_) &&
                (this.dispatchEvent(new ks('moveend', this, s)), xt(s.extent, this.previousExtent_))),
            this.dispatchEvent(new ks(Ns, this, s)),
            (this.renderComplete_ =
              this.hasListener(zs) || this.hasListener(Ws) || this.hasListener(Vn)
                ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady()
                : void 0),
            this.postRenderTimeoutHandle_ ||
              (this.postRenderTimeoutHandle_ = setTimeout(() => {
                (this.postRenderTimeoutHandle_ = void 0), this.handlePostRender();
              }, 0));
        }
        setLayerGroup(t) {
          const e = this.getLayerGroup();
          e && this.handleLayerRemove_(new Ms('removelayer', e)), this.set(Xs, t);
        }
        setSize(t) {
          this.set(js, t);
        }
        setTarget(t) {
          this.set(Ys, t);
        }
        setView(t) {
          if (!t || t instanceof on) return void this.set(Bs, t);
          this.set(Bs, new on());
          const e = this;
          t.then(function (t) {
            e.setView(new on(t));
          });
        }
        updateSize() {
          const t = this.getTargetElement();
          let e;
          if (t) {
            const i = getComputedStyle(t),
              n =
                t.offsetWidth -
                parseFloat(i.borderLeftWidth) -
                parseFloat(i.paddingLeft) -
                parseFloat(i.paddingRight) -
                parseFloat(i.borderRightWidth),
              s =
                t.offsetHeight -
                parseFloat(i.borderTopWidth) -
                parseFloat(i.paddingTop) -
                parseFloat(i.paddingBottom) -
                parseFloat(i.borderBottomWidth);
            isNaN(n) ||
              isNaN(s) ||
              ((e = [n, s]),
              !Pr(e) &&
                (t.offsetWidth || t.offsetHeight || t.getClientRects().length) &&
                _e("No map visible because the map container's width or height are 0."));
          }
          const i = this.getSize();
          !e || (i && I(e, i)) || (this.setSize(e), this.updateViewportSize_(e));
        }
        updateViewportSize_(t) {
          const e = this.getView();
          e && e.setViewportSize(t);
        }
      })({
        target: 'coordinate-map',
        layers: [
          new (class extends qa {
            constructor(t) {
              super(t);
            }
            createRenderer() {
              return new ah(this);
            }
          })({
            source: new (class extends Wh {
              constructor(t) {
                let e;
                e =
                  void 0 !== (t = t || {}).attributions
                    ? t.attributions
                    : [
                        '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.',
                      ];
                const i = void 0 !== t.crossOrigin ? t.crossOrigin : 'anonymous',
                  n = void 0 !== t.url ? t.url : 'https://tile.openstreetmap.org/{z}/{x}/{y}.png';
                super({
                  attributions: e,
                  attributionsCollapsible: !1,
                  cacheSize: t.cacheSize,
                  crossOrigin: i,
                  interpolate: t.interpolate,
                  maxZoom: void 0 !== t.maxZoom ? t.maxZoom : 19,
                  opaque: void 0 === t.opaque || t.opaque,
                  reprojectionErrorThreshold: t.reprojectionErrorThreshold,
                  tileLoadFunction: t.tileLoadFunction,
                  transition: t.transition,
                  url: n,
                  wrapX: t.wrapX,
                  zDirection: t.zDirection,
                });
              }
            })(),
          }),
          new Ka({ source: pl }),
        ],
        view: new on({ center: Te([0, 0]), zoom: 2 }),
      }),
      yl = function (t) {
        var e = t.feature.getGeometry().getCoordinates()[0];
        Cl(e);
      },
      vl = new Jr({ stroke: new Vr({ color: 'blue', width: 2 }), fill: new Kr({ color: 'rgb(0, 0, 255, 0.1)' }) }),
      xl = new (class extends nr {
        constructor(t) {
          const e = t;
          e.stopDown || (e.stopDown = M),
            super(e),
            this.on,
            this.once,
            this.un,
            (this.shouldHandle_ = !1),
            (this.downPx_ = null),
            this.downTimeout_,
            this.lastDragTime_,
            this.pointerType_,
            (this.freehand_ = !1),
            (this.source_ = t.source ? t.source : null),
            (this.features_ = t.features ? t.features : null),
            (this.snapTolerance_ = t.snapTolerance ? t.snapTolerance : 12),
            (this.type_ = t.type),
            (this.mode_ = (function (t) {
              switch (t) {
                case 'Point':
                case 'MultiPoint':
                  return 'Point';
                case 'LineString':
                case 'MultiLineString':
                  return 'LineString';
                case 'Polygon':
                case 'MultiPolygon':
                  return 'Polygon';
                case 'Circle':
                  return 'Circle';
                default:
                  throw new Error('Invalid type: ' + t);
              }
            })(this.type_)),
            (this.stopClick_ = !!t.stopClick),
            (this.minPoints_ = t.minPoints ? t.minPoints : 'Polygon' === this.mode_ ? 3 : 2),
            (this.maxPoints_ = 'Circle' === this.mode_ ? 2 : t.maxPoints ? t.maxPoints : 1 / 0),
            (this.finishCondition_ = t.finishCondition ? t.finishCondition : R),
            (this.geometryLayout_ = t.geometryLayout ? t.geometryLayout : 'XY');
          let i = t.geometryFunction;
          if (!i) {
            const t = this.mode_;
            if ('Circle' === t)
              i = function (t, e, i) {
                const n = e || new Bh([NaN, NaN]),
                  s = ke(t[0]),
                  r = Qt(s, ke(t[t.length - 1]));
                n.setCenterAndRadius(s, Math.sqrt(r), this.geometryLayout_);
                const o = Le();
                return o && n.transform(i, o), n;
              };
            else {
              let e;
              'Point' === t ? (e = Ni) : 'LineString' === t ? (e = jh) : 'Polygon' === t && (e = tn),
                (i = function (i, n, s) {
                  return (
                    n
                      ? 'Polygon' === t
                        ? i[0].length
                          ? n.setCoordinates([i[0].concat([i[0][0]])], this.geometryLayout_)
                          : n.setCoordinates([], this.geometryLayout_)
                        : n.setCoordinates(i, this.geometryLayout_)
                      : (n = new e(i, this.geometryLayout_)),
                    n
                  );
                });
            }
          }
          (this.geometryFunction_ = i),
            (this.dragVertexDelay_ = void 0 !== t.dragVertexDelay ? t.dragVertexDelay : 500),
            (this.finishCoordinate_ = null),
            (this.sketchFeature_ = null),
            (this.sketchPoint_ = null),
            (this.sketchCoords_ = null),
            (this.sketchLine_ = null),
            (this.sketchLineCoords_ = null),
            (this.squaredClickTolerance_ = t.clickTolerance ? t.clickTolerance * t.clickTolerance : 36),
            (this.overlay_ = new Ka({
              source: new Ch({ useSpatialIndex: !1, wrapX: !!t.wrapX && t.wrapX }),
              style: t.style ? t.style : ul(),
              updateWhileInteracting: !0,
            })),
            (this.geometryName_ = t.geometryName),
            (this.condition_ = t.condition ? t.condition : cr),
            this.freehandCondition_,
            t.freehand
              ? (this.freehandCondition_ = ar)
              : (this.freehandCondition_ = t.freehandCondition ? t.freehandCondition : ur),
            this.traceCondition_,
            this.setTrace(t.trace || !1),
            (this.traceState_ = { active: !1 }),
            (this.traceSource_ = t.traceSource || t.source || null),
            this.addChangeListener(Js, this.updateState_);
        }
        setTrace(t) {
          let e;
          (e = t ? (!0 === t ? ar : t) : lr), (this.traceCondition_ = e);
        }
        setMap(t) {
          super.setMap(t), this.updateState_();
        }
        getOverlay() {
          return this.overlay_;
        }
        handleEvent(t) {
          t.originalEvent.type === D && t.originalEvent.preventDefault(),
            (this.freehand_ = 'Point' !== this.mode_ && this.freehandCondition_(t));
          let e = t.type === Os.POINTERMOVE,
            i = !0;
          return (
            !this.freehand_ &&
              this.lastDragTime_ &&
              t.type === Os.POINTERDRAG &&
              (Date.now() - this.lastDragTime_ >= this.dragVertexDelay_
                ? ((this.downPx_ = t.pixel), (this.shouldHandle_ = !this.freehand_), (e = !0))
                : (this.lastDragTime_ = void 0),
              this.shouldHandle_ &&
                void 0 !== this.downTimeout_ &&
                (clearTimeout(this.downTimeout_), (this.downTimeout_ = void 0))),
            this.freehand_ && t.type === Os.POINTERDRAG && null !== this.sketchFeature_
              ? (this.addToDrawing_(t.coordinate), (i = !1))
              : this.freehand_ && t.type === Os.POINTERDOWN
                ? (i = !1)
                : e && this.getPointerCount() < 2
                  ? ((i = t.type === Os.POINTERMOVE),
                    i && this.freehand_
                      ? (this.handlePointerMove_(t), this.shouldHandle_ && t.originalEvent.preventDefault())
                      : ('mouse' === t.originalEvent.pointerType ||
                          (t.type === Os.POINTERDRAG && void 0 === this.downTimeout_)) &&
                        this.handlePointerMove_(t))
                  : t.type === Os.DBLCLICK && (i = !1),
            super.handleEvent(t) && i
          );
        }
        handleDownEvent(t) {
          return (
            (this.shouldHandle_ = !this.freehand_),
            this.freehand_
              ? ((this.downPx_ = t.pixel), this.finishCoordinate_ || this.startDrawing_(t.coordinate), !0)
              : this.condition_(t)
                ? ((this.lastDragTime_ = Date.now()),
                  (this.downTimeout_ = setTimeout(() => {
                    this.handlePointerMove_(new As(Os.POINTERMOVE, t.map, t.originalEvent, !1, t.frameState));
                  }, this.dragVertexDelay_)),
                  (this.downPx_ = t.pixel),
                  !0)
                : ((this.lastDragTime_ = void 0), !1)
          );
        }
        deactivateTrace_() {
          this.traceState_ = { active: !1 };
        }
        toggleTraceState_(t) {
          if (!this.traceSource_ || !this.traceCondition_(t)) return;
          if (this.traceState_.active) return void this.deactivateTrace_();
          const e = this.getMap(),
            i = yt([
              e.getCoordinateFromPixel([t.pixel[0] - this.snapTolerance_, t.pixel[1] + this.snapTolerance_]),
              e.getCoordinateFromPixel([t.pixel[0] + this.snapTolerance_, t.pixel[1] - this.snapTolerance_]),
            ]),
            n = this.traceSource_.getFeaturesInExtent(i);
          if (0 === n.length) return;
          const s = (function (t, e) {
            const i = [];
            for (let n = 0; n < e.length; ++n) rl(t, e[n].getGeometry(), i);
            return i;
          })(t.coordinate, n);
          s.length && (this.traceState_ = { active: !0, startPx: t.pixel.slice(), targets: s, targetIndex: -1 });
        }
        addOrRemoveTracedCoordinates_(t, e) {
          const i = t.startIndex <= t.endIndex;
          i === t.startIndex <= e
            ? (i && e > t.endIndex) || (!i && e < t.endIndex)
              ? this.addTracedCoordinates_(t, t.endIndex, e)
              : ((i && e < t.endIndex) || (!i && e > t.endIndex)) && this.removeTracedCoordinates_(e, t.endIndex)
            : (this.removeTracedCoordinates_(t.startIndex, t.endIndex), this.addTracedCoordinates_(t, t.startIndex, e));
        }
        removeTracedCoordinates_(t, e) {
          if (t === e) return;
          let i = 0;
          if (t < e) {
            const n = Math.ceil(t);
            let s = Math.floor(e);
            s === e && (s -= 1), (i = s - n + 1);
          } else {
            const n = Math.floor(t);
            let s = Math.ceil(e);
            s === e && (s += 1), (i = n - s + 1);
          }
          i > 0 && this.removeLastPoints_(i);
        }
        addTracedCoordinates_(t, e, i) {
          if (e === i) return;
          const n = [];
          if (e < i) {
            const s = Math.ceil(e);
            let r = Math.floor(i);
            r === i && (r -= 1);
            for (let e = s; e <= r; ++e) n.push(nl(t.coordinates, e));
          } else {
            const s = Math.floor(e);
            let r = Math.ceil(i);
            r === i && (r += 1);
            for (let e = s; e >= r; --e) n.push(nl(t.coordinates, e));
          }
          n.length && this.appendCoordinates(n);
        }
        updateTrace_(t) {
          const e = this.traceState_;
          if (!e.active) return;
          if (-1 === e.targetIndex && te(e.startPx, t.pixel) < this.snapTolerance_) return;
          const i = (function (t, e, i, n) {
            const s = t[0],
              r = t[1];
            let o = 1 / 0,
              a = -1,
              h = NaN;
            for (let t = 0; t < e.targets.length; ++t) {
              const i = e.targets[t],
                n = i.coordinates;
              let l,
                c = 1 / 0;
              for (let t = 0; t < n.length - 1; ++t) {
                const e = ll(s, r, n[t], n[t + 1]);
                e.squaredDistance < c && ((c = e.squaredDistance), (l = t + e.along));
              }
              c < o &&
                ((o = c),
                i.ring &&
                  e.targetIndex === t &&
                  (i.endIndex > i.startIndex
                    ? l < i.startIndex && (l += n.length)
                    : i.endIndex < i.startIndex && l > i.startIndex && (l -= n.length)),
                (h = l),
                (a = t));
            }
            const l = e.targets[a];
            let c = l.ring;
            if (e.targetIndex === a && c) {
              const t = cl(l.coordinates, h);
              te(i.getPixelFromCoordinate(t), e.startPx) > n && (c = !1);
            }
            if (c) {
              const t = l.coordinates,
                e = t.length,
                i = l.startIndex,
                n = h;
              if (i < n) {
                const s = sl(t, i, n);
                sl(t, i, n - e) < s && (h -= e);
              } else {
                const s = sl(t, i, n);
                sl(t, i, n + e) < s && (h += e);
              }
            }
            return (ol.index = a), (ol.endIndex = h), ol;
          })(t.coordinate, e, this.getMap(), this.snapTolerance_);
          if (e.targetIndex !== i.index) {
            if (-1 !== e.targetIndex) {
              const t = e.targets[e.targetIndex];
              this.removeTracedCoordinates_(t.startIndex, t.endIndex);
            }
            const t = e.targets[i.index];
            this.addTracedCoordinates_(t, t.startIndex, i.endIndex);
          } else {
            const t = e.targets[e.targetIndex];
            this.addOrRemoveTracedCoordinates_(t, i.endIndex);
          }
          e.targetIndex = i.index;
          const n = e.targets[e.targetIndex];
          n.endIndex = i.endIndex;
          const s = cl(n.coordinates, n.endIndex),
            r = this.getMap().getPixelFromCoordinate(s);
          (t.coordinate = s), (t.pixel = [Math.round(r[0]), Math.round(r[1])]);
        }
        handleUpEvent(t) {
          let e = !0;
          if (0 === this.getPointerCount()) {
            this.downTimeout_ && (clearTimeout(this.downTimeout_), (this.downTimeout_ = void 0)),
              this.handlePointerMove_(t);
            const i = this.traceState_.active;
            if ((this.toggleTraceState_(t), this.shouldHandle_)) {
              const n = !this.finishCoordinate_;
              n && this.startDrawing_(t.coordinate),
                !n && this.freehand_
                  ? this.finishDrawing()
                  : this.freehand_ ||
                    (n && 'Point' !== this.mode_) ||
                    (this.atFinish_(t.pixel, i)
                      ? this.finishCondition_(t) && this.finishDrawing()
                      : this.addToDrawing_(t.coordinate)),
                (e = !1);
            } else this.freehand_ && this.abortDrawing();
          }
          return !e && this.stopClick_ && t.preventDefault(), e;
        }
        handlePointerMove_(t) {
          if (
            ((this.pointerType_ = t.originalEvent.pointerType),
            this.downPx_ && ((!this.freehand_ && this.shouldHandle_) || (this.freehand_ && !this.shouldHandle_)))
          ) {
            const e = this.downPx_,
              i = t.pixel,
              n = e[0] - i[0],
              s = e[1] - i[1],
              r = n * n + s * s;
            if (
              ((this.shouldHandle_ = this.freehand_
                ? r > this.squaredClickTolerance_
                : r <= this.squaredClickTolerance_),
              !this.shouldHandle_)
            )
              return;
          }
          this.finishCoordinate_
            ? (this.updateTrace_(t), this.modifyDrawing_(t.coordinate))
            : this.createOrUpdateSketchPoint_(t.coordinate.slice());
        }
        atFinish_(t, e) {
          let i = !1;
          if (this.sketchFeature_) {
            let n = !1,
              s = [this.finishCoordinate_];
            const r = this.mode_;
            if ('Point' === r) i = !0;
            else if ('Circle' === r) i = 2 === this.sketchCoords_.length;
            else if ('LineString' === r) n = !e && this.sketchCoords_.length > this.minPoints_;
            else if ('Polygon' === r) {
              const t = this.sketchCoords_;
              (n = t[0].length > this.minPoints_),
                (s = [t[0][0], t[0][t[0].length - 2]]),
                (s = e ? [t[0][0]] : [t[0][0], t[0][t[0].length - 2]]);
            }
            if (n) {
              const e = this.getMap();
              for (let n = 0, r = s.length; n < r; n++) {
                const r = s[n],
                  o = e.getPixelFromCoordinate(r),
                  a = t[0] - o[0],
                  h = t[1] - o[1],
                  l = this.freehand_ ? 1 : this.snapTolerance_;
                if (((i = Math.sqrt(a * a + h * h) <= l), i)) {
                  this.finishCoordinate_ = r;
                  break;
                }
              }
            }
          }
          return i;
        }
        createOrUpdateSketchPoint_(t) {
          this.sketchPoint_
            ? this.sketchPoint_.getGeometry().setCoordinates(t)
            : ((this.sketchPoint_ = new Or(new Ni(t))), this.updateSketchFeatures_());
        }
        createOrUpdateCustomSketchLine_(t) {
          this.sketchLine_ || (this.sketchLine_ = new Or());
          const e = t.getLinearRing(0);
          let i = this.sketchLine_.getGeometry();
          i
            ? (i.setFlatCoordinates(e.getLayout(), e.getFlatCoordinates()), i.changed())
            : ((i = new jh(e.getFlatCoordinates(), e.getLayout())), this.sketchLine_.setGeometry(i));
        }
        startDrawing_(t) {
          const e = this.getMap().getView().getProjection(),
            i = _i(this.geometryLayout_);
          for (; t.length < i; ) t.push(0);
          (this.finishCoordinate_ = t),
            'Point' === this.mode_
              ? (this.sketchCoords_ = t.slice())
              : 'Polygon' === this.mode_
                ? ((this.sketchCoords_ = [[t.slice(), t.slice()]]), (this.sketchLineCoords_ = this.sketchCoords_[0]))
                : (this.sketchCoords_ = [t.slice(), t.slice()]),
            this.sketchLineCoords_ && (this.sketchLine_ = new Or(new jh(this.sketchLineCoords_)));
          const n = this.geometryFunction_(this.sketchCoords_, void 0, e);
          (this.sketchFeature_ = new Or()),
            this.geometryName_ && this.sketchFeature_.setGeometryName(this.geometryName_),
            this.sketchFeature_.setGeometry(n),
            this.updateSketchFeatures_(),
            this.dispatchEvent(new el(tl, this.sketchFeature_));
        }
        modifyDrawing_(t) {
          const e = this.getMap(),
            i = this.sketchFeature_.getGeometry(),
            n = e.getView().getProjection(),
            s = _i(this.geometryLayout_);
          let r, o;
          for (; t.length < s; ) t.push(0);
          'Point' === this.mode_
            ? (o = this.sketchCoords_)
            : 'Polygon' === this.mode_
              ? ((r = this.sketchCoords_[0]),
                (o = r[r.length - 1]),
                this.atFinish_(e.getPixelFromCoordinate(t)) && (t = this.finishCoordinate_.slice()))
              : ((r = this.sketchCoords_), (o = r[r.length - 1])),
            (o[0] = t[0]),
            (o[1] = t[1]),
            this.geometryFunction_(this.sketchCoords_, i, n),
            this.sketchPoint_ && this.sketchPoint_.getGeometry().setCoordinates(t),
            'Polygon' === i.getType() && 'Polygon' !== this.mode_
              ? this.createOrUpdateCustomSketchLine_(i)
              : this.sketchLineCoords_ && this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_),
            this.updateSketchFeatures_();
        }
        addToDrawing_(t) {
          const e = this.sketchFeature_.getGeometry(),
            i = this.getMap().getView().getProjection();
          let n, s;
          const r = this.mode_;
          'LineString' === r || 'Circle' === r
            ? ((this.finishCoordinate_ = t.slice()),
              (s = this.sketchCoords_),
              s.length >= this.maxPoints_ && (this.freehand_ ? s.pop() : (n = !0)),
              s.push(t.slice()),
              this.geometryFunction_(s, e, i))
            : 'Polygon' === r &&
              ((s = this.sketchCoords_[0]),
              s.length >= this.maxPoints_ && (this.freehand_ ? s.pop() : (n = !0)),
              s.push(t.slice()),
              n && (this.finishCoordinate_ = s[0]),
              this.geometryFunction_(this.sketchCoords_, e, i)),
            this.createOrUpdateSketchPoint_(t.slice()),
            this.updateSketchFeatures_(),
            n && this.finishDrawing();
        }
        removeLastPoints_(t) {
          if (!this.sketchFeature_) return;
          const e = this.sketchFeature_.getGeometry(),
            i = this.getMap().getView().getProjection(),
            n = this.mode_;
          for (let s = 0; s < t; ++s) {
            let t;
            if ('LineString' === n || 'Circle' === n) {
              if (((t = this.sketchCoords_), t.splice(-2, 1), t.length >= 2)) {
                this.finishCoordinate_ = t[t.length - 2].slice();
                const e = this.finishCoordinate_.slice();
                (t[t.length - 1] = e), this.createOrUpdateSketchPoint_(e);
              }
              this.geometryFunction_(t, e, i),
                'Polygon' === e.getType() && this.sketchLine_ && this.createOrUpdateCustomSketchLine_(e);
            } else if ('Polygon' === n) {
              (t = this.sketchCoords_[0]), t.splice(-2, 1);
              const n = this.sketchLine_.getGeometry();
              if (t.length >= 2) {
                const e = t[t.length - 2].slice();
                (t[t.length - 1] = e), this.createOrUpdateSketchPoint_(e);
              }
              n.setCoordinates(t), this.geometryFunction_(this.sketchCoords_, e, i);
            }
            if (1 === t.length) {
              this.abortDrawing();
              break;
            }
          }
          this.updateSketchFeatures_();
        }
        removeLastPoint() {
          this.removeLastPoints_(1);
        }
        finishDrawing() {
          const t = this.abortDrawing_();
          if (!t) return;
          let e = this.sketchCoords_;
          const i = t.getGeometry(),
            n = this.getMap().getView().getProjection();
          'LineString' === this.mode_
            ? (e.pop(), this.geometryFunction_(e, i, n))
            : 'Polygon' === this.mode_ && (e[0].pop(), this.geometryFunction_(e, i, n), (e = i.getCoordinates())),
            'MultiPoint' === this.type_
              ? t.setGeometry(new $h([e]))
              : 'MultiLineString' === this.type_
                ? t.setGeometry(new Uh([e]))
                : 'MultiPolygon' === this.type_ && t.setGeometry(new Qh([e])),
            this.dispatchEvent(new el('drawend', t)),
            this.features_ && this.features_.push(t),
            this.source_ && this.source_.addFeature(t);
        }
        abortDrawing_() {
          this.finishCoordinate_ = null;
          const t = this.sketchFeature_;
          return (
            (this.sketchFeature_ = null),
            (this.sketchPoint_ = null),
            (this.sketchLine_ = null),
            this.overlay_.getSource().clear(!0),
            this.deactivateTrace_(),
            t
          );
        }
        abortDrawing() {
          const t = this.abortDrawing_();
          t && this.dispatchEvent(new el('drawabort', t));
        }
        appendCoordinates(t) {
          const e = this.mode_,
            i = !this.sketchFeature_;
          let n;
          if ((i && this.startDrawing_(t[0]), 'LineString' === e || 'Circle' === e)) n = this.sketchCoords_;
          else {
            if ('Polygon' !== e) return;
            n = this.sketchCoords_ && this.sketchCoords_.length ? this.sketchCoords_[0] : [];
          }
          i && n.shift(), n.pop();
          for (let e = 0; e < t.length; e++) this.addToDrawing_(t[e]);
          const s = t[t.length - 1];
          this.addToDrawing_(s), this.modifyDrawing_(s);
        }
        extend(t) {
          const e = t.getGeometry();
          (this.sketchFeature_ = t), (this.sketchCoords_ = e.getCoordinates());
          const i = this.sketchCoords_[this.sketchCoords_.length - 1];
          (this.finishCoordinate_ = i.slice()),
            this.sketchCoords_.push(i.slice()),
            (this.sketchPoint_ = new Or(new Ni(i))),
            this.updateSketchFeatures_(),
            this.dispatchEvent(new el(tl, this.sketchFeature_));
        }
        updateSketchFeatures_() {
          const t = [];
          this.sketchFeature_ && t.push(this.sketchFeature_),
            this.sketchLine_ && t.push(this.sketchLine_),
            this.sketchPoint_ && t.push(this.sketchPoint_);
          const e = this.overlay_.getSource();
          e.clear(!0), e.addFeatures(t);
        }
        updateState_() {
          const t = this.getMap(),
            e = this.getActive();
          (t && e) || this.abortDrawing(), this.overlay_.setMap(e ? t : null);
        }
      })({
        source: pl,
        type: 'Circle',
        geometryFunction: function (t, e, i) {
          const n = yt(
              [t[0], t[t.length - 1]].map(function (t) {
                return ke(t);
              }),
            ),
            s = [[Gt(n), Nt(n), Zt(n), Kt(n), Gt(n)]];
          e ? e.setCoordinates(s) : (e = new tn(s));
          const r = Le();
          return r && e.transform(i, r), e;
        },
        style: vl,
      }),
      wl = new Jr({ stroke: new Vr({ color: 'red', width: 2 }), fill: new Kr({ color: 'rgb(255, 0, 0, 0.5)' }) }),
      Cl = function (t) {
        if (5 === t.length) {
          var e = t.map(function (t) {
              return Me(t, 'EPSG:3857', 'EPSG:4326');
            }),
            i = e[0][0],
            n = e[0][1],
            s = e[2][0],
            r = e[2][1];
          (dl.value = n),
            (gl.value = r),
            (fl.value = s),
            (_l.value = i),
            f(document.querySelector('[data-do-browser-storage]'), !1, !0),
            setTimeout(function () {
              o(document.querySelector('[data-do-browser-storage]'));
            }, 200);
          var a = new tn([t]),
            h = new Or({ geometry: a });
          h.setStyle(wl), pl.clear(), pl.addFeature(h);
        } else console.error('Invalid rectangle coordinates');
      },
      Sl = function () {
        var t = parseFloat(dl.value),
          e = parseFloat(gl.value),
          i = parseFloat(fl.value),
          n = parseFloat(_l.value);
        isNaN(t) || isNaN(e) || isNaN(i),
          isNaN(n)
            ? console.error('Invalid coordinates. Please enter valid numbers')
            : Cl([
                [n, t],
                [i, t],
                [i, e],
                [n, e],
                [n, t],
              ]);
      },
      El = new Ch(),
      Tl = new Ka({
        source: El,
        style: new Jr({ stroke: new Vr({ color: 'rgba(0, 0, 0, 0.5)', width: 1, lineDash: [5, 5] }) }),
      });
    (function () {
      if ('undefined' != typeof Storage) {
        var t = document.querySelectorAll('[data-do-browser-storage]');
        t.length > 0 &&
          t.forEach(function (t) {
            t instanceof HTMLFormElement && (f(t), _(t));
          }),
          (i = document.querySelectorAll('[data-do-storage-reset]')).length > 0 &&
            i.forEach(function (t) {
              t.addEventListener('click', function () {
                sessionStorage.setItem(u, d);
              });
            }),
          (e = document.querySelectorAll('[data-do-storage-skip]')).length > 0 &&
            e.forEach(function (t) {
              t.addEventListener('click', function (t) {
                var e = t.target.closest('form');
                e && (f(e, !0), _(e));
              });
            });
      }
      var e, i;
    })(),
      document.addEventListener('DOMContentLoaded', function () {
        var t = document.querySelector('[data-fetch-results]');
        if (t) {
          var e = t.getAttribute('data-action');
          v(e);
        }
      }),
      a(),
      document.getElementById('coordinate-map') &&
        ([dl, gl, fl, _l].forEach(function (t) {
          t.addEventListener('change', Sl);
        }),
        xl.on('drawend', yl),
        ml.addInteraction(xl),
        ml.addLayer(Tl),
        (function () {
          for (var t = [], e = -90; e <= 90; e += 10) {
            var i = new jh([Te([-180, e]), Te([180, e])]);
            t.push(new Or(i));
          }
          for (var n = -180; n <= 180; n += 10) {
            var s = new jh([Te([n, -90]), Te([n, 90])]);
            t.push(new Or(s));
          }
          El.clear(), El.addFeatures(t);
        })(),
        navigator.geolocation
          ? navigator.geolocation.getCurrentPosition(
              function (t) {
                var e = t.coords.latitude,
                  i = Te([t.coords.longitude, e]);
                ml.getView().setCenter(i), ml.getView().setZoom(4);
              },
              function (t) {
                switch (t.code) {
                  case t.PERMISSION_DENIED:
                    console.error('User denied the request for geolocation.');
                    break;
                  case t.POSITION_UNAVAILABLE:
                    console.error('Location information is unavailable.');
                    break;
                  case t.TIMEOUT:
                    console.error('The request to get user location timed out.');
                    break;
                  case t.UNKNOWN_ERROR:
                    console.error('An unknown error occurred.');
                }
              },
            )
          : console.error('Geolocation is not supported by this browser.'));
  })();
})();
